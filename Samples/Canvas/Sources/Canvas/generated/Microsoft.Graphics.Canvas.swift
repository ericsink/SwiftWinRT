// this file is automatically generated.
// if you modify it by hand, your changes will probably be lost.


import CWinRT;
@_spi(IUnknown) import WinRT;
import C;

extension Microsoft.Graphics.Canvas {
// type: Microsoft.Graphics.Canvas.CanvasActiveLayer
// runtime class
public class CanvasActiveLayer
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.ICanvasActiveLayer;
    public init(plok: Microsoft.Graphics.Canvas.ICanvasActiveLayer?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.ICanvasActiveLayer { return _self; }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.CanvasAlphaMode
// enum type
public typealias CanvasAlphaMode = _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode;

// type: Microsoft.Graphics.Canvas.CanvasAntialiasing
// enum type
public typealias CanvasAntialiasing = _q_CMicrosoft_CGraphics_CCanvas_CCanvasAntialiasing;

// type: Microsoft.Graphics.Canvas.CanvasBitmap
// runtime class
open class CanvasBitmap
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.ICanvasBitmap;
    public init(plok: Microsoft.Graphics.Canvas.ICanvasBitmap?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.ICanvasBitmap { return _self; }
    // COMPOSABLE: Microsoft.Graphics.Canvas.ICanvasBitmapFactory
// composable interface not needed: Microsoft.Graphics.Canvas.ICanvasBitmapFactory
    private struct _ICanvasBitmapStatics {
        static var x : ICanvasBitmapStatics =
            try! RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasBitmap")
    }
    public static var CanvasBitmapStatics : ICanvasBitmapStatics {
        _ICanvasBitmapStatics.x
    }
    public static func CreateFromDirect3D11Surface(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, surface : Optional<Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface>) throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try Microsoft.Graphics.Canvas.CanvasBitmap(plok: CanvasBitmapStatics.CreateFromDirect3D11Surface(resourceCreator: resourceCreator, surface: surface));
    }
    public static func CreateFromDirect3D11Surface(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, surface : Optional<Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface>, dpi : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try Microsoft.Graphics.Canvas.CanvasBitmap(plok: CanvasBitmapStatics.CreateFromDirect3D11SurfaceWithDpi(resourceCreator: resourceCreator, surface: surface, dpi: dpi));
    }
    public static func CreateFromDirect3D11Surface(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, surface : Optional<Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface>, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try Microsoft.Graphics.Canvas.CanvasBitmap(plok: CanvasBitmapStatics.CreateFromDirect3D11SurfaceWithDpiAndAlpha(resourceCreator: resourceCreator, surface: surface, dpi: dpi, alpha: alpha));
    }
    public static func CreateFromBytes(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, bytesLength : UINT32, bytes : Optional<UnsafeMutablePointer<UINT8>>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, format : Windows.Graphics.DirectX.DirectXPixelFormat) throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try Microsoft.Graphics.Canvas.CanvasBitmap(plok: CanvasBitmapStatics.CreateFromBytes(resourceCreator: resourceCreator, bytesLength: bytesLength, bytes: bytes, widthInPixels: widthInPixels, heightInPixels: heightInPixels, format: format));
    }
    public static func CreateFromBytes(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, bytesLength : UINT32, bytes : Optional<UnsafeMutablePointer<UINT8>>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, format : Windows.Graphics.DirectX.DirectXPixelFormat, dpi : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try Microsoft.Graphics.Canvas.CanvasBitmap(plok: CanvasBitmapStatics.CreateFromBytesWithDpi(resourceCreator: resourceCreator, bytesLength: bytesLength, bytes: bytes, widthInPixels: widthInPixels, heightInPixels: heightInPixels, format: format, dpi: dpi));
    }
    public static func CreateFromBytes(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, bytesLength : UINT32, bytes : Optional<UnsafeMutablePointer<UINT8>>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, format : Windows.Graphics.DirectX.DirectXPixelFormat, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try Microsoft.Graphics.Canvas.CanvasBitmap(plok: CanvasBitmapStatics.CreateFromBytesWithDpiAndAlpha(resourceCreator: resourceCreator, bytesLength: bytesLength, bytes: bytes, widthInPixels: widthInPixels, heightInPixels: heightInPixels, format: format, dpi: dpi, alpha: alpha));
    }
    public static func CreateFromBytes(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, buffer : Optional<Windows.Storage.Streams.IBuffer>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, format : Windows.Graphics.DirectX.DirectXPixelFormat) throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try Microsoft.Graphics.Canvas.CanvasBitmap(plok: CanvasBitmapStatics.CreateFromBytesWithBuffer(resourceCreator: resourceCreator, buffer: buffer, widthInPixels: widthInPixels, heightInPixels: heightInPixels, format: format));
    }
    public static func CreateFromBytes(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, buffer : Optional<Windows.Storage.Streams.IBuffer>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, format : Windows.Graphics.DirectX.DirectXPixelFormat, dpi : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try Microsoft.Graphics.Canvas.CanvasBitmap(plok: CanvasBitmapStatics.CreateFromBytesWithBufferAndDpi(resourceCreator: resourceCreator, buffer: buffer, widthInPixels: widthInPixels, heightInPixels: heightInPixels, format: format, dpi: dpi));
    }
    public static func CreateFromBytes(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, buffer : Optional<Windows.Storage.Streams.IBuffer>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, format : Windows.Graphics.DirectX.DirectXPixelFormat, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try Microsoft.Graphics.Canvas.CanvasBitmap(plok: CanvasBitmapStatics.CreateFromBytesWithBufferAndDpiAndAlpha(resourceCreator: resourceCreator, buffer: buffer, widthInPixels: widthInPixels, heightInPixels: heightInPixels, format: format, dpi: dpi, alpha: alpha));
    }
    public static func CreateFromColors(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, colorsLength : UINT32, colors : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32) throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try Microsoft.Graphics.Canvas.CanvasBitmap(plok: CanvasBitmapStatics.CreateFromColors(resourceCreator: resourceCreator, colorsLength: colorsLength, colors: colors, widthInPixels: widthInPixels, heightInPixels: heightInPixels));
    }
    public static func CreateFromColors(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, colorsLength : UINT32, colors : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, dpi : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try Microsoft.Graphics.Canvas.CanvasBitmap(plok: CanvasBitmapStatics.CreateFromColorsWithDpi(resourceCreator: resourceCreator, colorsLength: colorsLength, colors: colors, widthInPixels: widthInPixels, heightInPixels: heightInPixels, dpi: dpi));
    }
    public static func CreateFromColors(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, colorsLength : UINT32, colors : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try Microsoft.Graphics.Canvas.CanvasBitmap(plok: CanvasBitmapStatics.CreateFromColorsWithDpiAndAlpha(resourceCreator: resourceCreator, colorsLength: colorsLength, colors: colors, widthInPixels: widthInPixels, heightInPixels: heightInPixels, dpi: dpi, alpha: alpha));
    }
    public static func CreateFromSoftwareBitmap(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, sourceBitmap : Optional<Windows.Graphics.Imaging.SoftwareBitmap>) throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try Microsoft.Graphics.Canvas.CanvasBitmap(plok: CanvasBitmapStatics.CreateFromSoftwareBitmap(resourceCreator: resourceCreator, sourceBitmap: sourceBitmap!.Interface()));
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Swift.String) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        return try CanvasBitmapStatics.LoadAsyncFromHstring(resourceCreator: resourceCreator, fileName: fileName);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Swift.String) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, fileName: fileName)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Swift.String, dpi : Swift.Float) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        return try CanvasBitmapStatics.LoadAsyncFromHstringWithDpi(resourceCreator: resourceCreator, fileName: fileName, dpi: dpi);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Swift.String, dpi : Swift.Float) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, fileName: fileName, dpi: dpi)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Swift.String, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        return try CanvasBitmapStatics.LoadAsyncFromHstringWithDpiAndAlpha(resourceCreator: resourceCreator, fileName: fileName, dpi: dpi, alpha: alpha);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Swift.String, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, fileName: fileName, dpi: dpi, alpha: alpha)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.Uri>) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        return try CanvasBitmapStatics.LoadAsyncFromUri(resourceCreator: resourceCreator, uri: uri!.Interface());
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.Uri>) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, uri: uri)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.Uri>, dpi : Swift.Float) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        return try CanvasBitmapStatics.LoadAsyncFromUriWithDpi(resourceCreator: resourceCreator, uri: uri!.Interface(), dpi: dpi);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.Uri>, dpi : Swift.Float) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, uri: uri, dpi: dpi)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.Uri>, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        return try CanvasBitmapStatics.LoadAsyncFromUriWithDpiAndAlpha(resourceCreator: resourceCreator, uri: uri!.Interface(), dpi: dpi, alpha: alpha);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.Uri>, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, uri: uri, dpi: dpi, alpha: alpha)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        return try CanvasBitmapStatics.LoadAsyncFromStream(resourceCreator: resourceCreator, stream: stream);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, stream: stream)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, dpi : Swift.Float) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        return try CanvasBitmapStatics.LoadAsyncFromStreamWithDpi(resourceCreator: resourceCreator, stream: stream, dpi: dpi);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, dpi : Swift.Float) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, stream: stream, dpi: dpi)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        return try CanvasBitmapStatics.LoadAsyncFromStreamWithDpiAndAlpha(resourceCreator: resourceCreator, stream: stream, dpi: dpi, alpha: alpha);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, stream: stream, dpi: dpi, alpha: alpha)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func get_SizeInPixels() throws -> Windows.Graphics.Imaging.BitmapSize {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.get_SizeInPixels();
    }
    public func get_Size() throws -> Windows.Foundation.Size {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.get_Size();
    }
    public func get_Bounds() throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.get_Bounds();
    }
    public func get_Format() throws -> Windows.Graphics.DirectX.DirectXPixelFormat {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.get_Format();
    }
    public func get_AlphaMode() throws -> Microsoft.Graphics.Canvas.CanvasAlphaMode {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.get_AlphaMode();
    }
    public func SaveAsync(fileName : Swift.String) throws -> Optional<Windows.Foundation.IAsyncAction> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.SaveToFileAsync(fileName: fileName);
    }
    public func Save(fileName : Swift.String) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.SaveAsync(fileName: fileName)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func SaveAsync(fileName : Swift.String, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat) throws -> Optional<Windows.Foundation.IAsyncAction> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.SaveToFileWithBitmapFileFormatAsync(fileName: fileName, fileFormat: fileFormat);
    }
    public func Save(fileName : Swift.String, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.SaveAsync(fileName: fileName, fileFormat: fileFormat)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func SaveAsync(fileName : Swift.String, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float) throws -> Optional<Windows.Foundation.IAsyncAction> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.SaveToFileWithBitmapFileFormatAndQualityAsync(fileName: fileName, fileFormat: fileFormat, quality: quality);
    }
    public func Save(fileName : Swift.String, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.SaveAsync(fileName: fileName, fileFormat: fileFormat, quality: quality)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func SaveAsync(stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat) throws -> Optional<Windows.Foundation.IAsyncAction> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.SaveToStreamAsync(stream: stream, fileFormat: fileFormat);
    }
    public func Save(stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.SaveAsync(stream: stream, fileFormat: fileFormat)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func SaveAsync(stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float) throws -> Optional<Windows.Foundation.IAsyncAction> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.SaveToStreamWithQualityAsync(stream: stream, fileFormat: fileFormat, quality: quality);
    }
    public func Save(stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.SaveAsync(stream: stream, fileFormat: fileFormat, quality: quality)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func GetPixelBytes() throws -> UINT32 {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.GetPixelBytes();
    }
    public func GetPixelBytes(left : Swift.Int32, top : Swift.Int32, width : Swift.Int32, height : Swift.Int32) throws -> UINT32 {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.GetPixelBytesWithSubrectangle(left: left, top: top, width: width, height: height);
    }
    public func GetPixelBytes(buffer : Optional<Windows.Storage.Streams.IBuffer>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.GetPixelBytesWithBuffer(buffer: buffer);
    }
    public func GetPixelBytes(buffer : Optional<Windows.Storage.Streams.IBuffer>, left : Swift.Int32, top : Swift.Int32, width : Swift.Int32, height : Swift.Int32) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.GetPixelBytesWithBufferAndSubrectangle(buffer: buffer, left: left, top: top, width: width, height: height);
    }
    public func GetPixelColors() throws -> UINT32 {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.GetPixelColors();
    }
    public func GetPixelColors(left : Swift.Int32, top : Swift.Int32, width : Swift.Int32, height : Swift.Int32) throws -> UINT32 {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.GetPixelColorsWithSubrectangle(left: left, top: top, width: width, height: height);
    }
    public func SetPixelBytes(valueElementsLength : UINT32, valueElements : Optional<UnsafeMutablePointer<UINT8>>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.SetPixelBytes(valueElementsLength: valueElementsLength, valueElements: valueElements);
    }
    public func SetPixelBytes(valueElementsLength : UINT32, valueElements : Optional<UnsafeMutablePointer<UINT8>>, left : Swift.Int32, top : Swift.Int32, width : Swift.Int32, height : Swift.Int32) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.SetPixelBytesWithSubrectangle(valueElementsLength: valueElementsLength, valueElements: valueElements, left: left, top: top, width: width, height: height);
    }
    public func SetPixelBytes(buffer : Optional<Windows.Storage.Streams.IBuffer>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.SetPixelBytesWithBuffer(buffer: buffer);
    }
    public func SetPixelBytes(buffer : Optional<Windows.Storage.Streams.IBuffer>, left : Swift.Int32, top : Swift.Int32, width : Swift.Int32, height : Swift.Int32) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.SetPixelBytesWithBufferAndSubrectangle(buffer: buffer, left: left, top: top, width: width, height: height);
    }
    public func SetPixelColors(valueElementsLength : UINT32, valueElements : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.SetPixelColors(valueElementsLength: valueElementsLength, valueElements: valueElements);
    }
    public func SetPixelColors(valueElementsLength : UINT32, valueElements : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>, left : Swift.Int32, top : Swift.Int32, width : Swift.Int32, height : Swift.Int32) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.SetPixelColorsWithSubrectangle(valueElementsLength: valueElementsLength, valueElements: valueElements, left: left, top: top, width: width, height: height);
    }
    public func CopyPixelsFromBitmap(otherBitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.CopyPixelsFromBitmap(otherBitmap: otherBitmap!.Interface());
    }
    public func CopyPixelsFromBitmap(otherBitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, destX : Swift.Int32, destY : Swift.Int32) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.CopyPixelsFromBitmapWithDestPoint(otherBitmap: otherBitmap!.Interface(), destX: destX, destY: destY);
    }
    public func CopyPixelsFromBitmap(otherBitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, destX : Swift.Int32, destY : Swift.Int32, sourceRectLeft : Swift.Int32, sourceRectTop : Swift.Int32, sourceRectWidth : Swift.Int32, sourceRectHeight : Swift.Int32) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.CopyPixelsFromBitmapWithDestPointAndSourceRect(otherBitmap: otherBitmap!.Interface(), destX: destX, destY: destY, sourceRectLeft: sourceRectLeft, sourceRectTop: sourceRectTop, sourceRectWidth: sourceRectWidth, sourceRectHeight: sourceRectHeight);
    }
    public var AlphaMode : Microsoft.Graphics.Canvas.CanvasAlphaMode {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.AlphaMode;
        }
    }
    public var Bounds : Windows.Foundation.Rect {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.Bounds;
        }
    }
    public var Format : Windows.Graphics.DirectX.DirectXPixelFormat {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.Format;
        }
    }
    public var Size : Windows.Foundation.Size {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.Size;
        }
    }
    public var SizeInPixels : Windows.Graphics.Imaging.BitmapSize {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasBitmap = try _self.QueryInterface();
        return try _ifc.SizeInPixels;
        }
    }
    public func get_Dpi() throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.get_Dpi();
    }
    public func ConvertPixelsToDips(pixels : Swift.Int32) throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.ConvertPixelsToDips(pixels: pixels);
    }
    public func ConvertDipsToPixels(dips : Swift.Float, dpiRounding : Microsoft.Graphics.Canvas.CanvasDpiRounding) throws -> Swift.Int32 {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.ConvertDipsToPixels(dips: dips, dpiRounding: dpiRounding);
    }
    public var Dpi : Swift.Float {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.Dpi;
        }
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreator = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.get_Device());
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreator = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.Device);
        }
    }
    public func get_Description() throws -> Windows.Graphics.DirectX.Direct3D11.Direct3DSurfaceDescription {
        let _ifc : Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface = try _self.QueryInterface();
        return try _ifc.get_Description();
    }
    public var Description : Windows.Graphics.DirectX.Direct3D11.Direct3DSurfaceDescription {
        get throws {
        let _ifc : Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface = try _self.QueryInterface();
        return try _ifc.Description;
        }
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
    public func GetBounds(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>) throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasImage = try _self.QueryInterface();
        return try _ifc.GetBounds(resourceCreator: resourceCreator);
    }
    public func GetBounds(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, transform : Windows.Foundation.Numerics.Matrix3x2) throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasImage = try _self.QueryInterface();
        return try _ifc.GetBoundsWithTransform(resourceCreator: resourceCreator, transform: transform);
    }
}

// type: Microsoft.Graphics.Canvas.CanvasBitmapFileFormat
// enum type
public typealias CanvasBitmapFileFormat = _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat;

// type: Microsoft.Graphics.Canvas.CanvasBlend
// enum type
public typealias CanvasBlend = _q_CMicrosoft_CGraphics_CCanvas_CCanvasBlend;

// type: Microsoft.Graphics.Canvas.CanvasBufferPrecision
// enum type
public typealias CanvasBufferPrecision = _q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision;

// type: Microsoft.Graphics.Canvas.CanvasColorSpace
// enum type
public typealias CanvasColorSpace = _q_CMicrosoft_CGraphics_CCanvas_CCanvasColorSpace;

// type: Microsoft.Graphics.Canvas.CanvasCommandList
// runtime class
public class CanvasCommandList
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.ICanvasCommandList;
    public init(plok: Microsoft.Graphics.Canvas.ICanvasCommandList?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.ICanvasCommandList { return _self; }
    public init(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>) throws {
        let _af : ICanvasCommandListFactory = try RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasCommandList");
        _self = try _af.Create(resourceCreator: resourceCreator)!;
        try super.init(plok: _self.QueryInterface())
    }
    public func CreateDrawingSession() throws -> Optional<Microsoft.Graphics.Canvas.CanvasDrawingSession> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasCommandList = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDrawingSession(plok: _ifc.CreateDrawingSession());
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasCommandList = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.get_Device());
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasCommandList = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.Device);
        }
    }
    public func GetBounds(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>) throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasImage = try _self.QueryInterface();
        return try _ifc.GetBounds(resourceCreator: resourceCreator);
    }
    public func GetBounds(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, transform : Windows.Foundation.Numerics.Matrix3x2) throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasImage = try _self.QueryInterface();
        return try _ifc.GetBoundsWithTransform(resourceCreator: resourceCreator, transform: transform);
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.CanvasComposite
// enum type
public typealias CanvasComposite = _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite;

// type: Microsoft.Graphics.Canvas.CanvasDebugLevel
// enum type
public typealias CanvasDebugLevel = _q_CMicrosoft_CGraphics_CCanvas_CCanvasDebugLevel;

// type: Microsoft.Graphics.Canvas.CanvasDevice
// runtime class
public class CanvasDevice
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.ICanvasDevice;
    public init(plok: Microsoft.Graphics.Canvas.ICanvasDevice?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.ICanvasDevice { return _self; }
    public init(forceSoftwareRenderer : boolean) throws {
        let _af : ICanvasDeviceFactory = try RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasDevice");
        _self = try _af.CreateWithForceSoftwareRendererOption(forceSoftwareRenderer: forceSoftwareRenderer)!;
        try super.init(plok: _self.QueryInterface())
    }
    public init() throws {
        _self = try RoActivateInstance("Microsoft.Graphics.Canvas.CanvasDevice")
        try super.init(plok: _self.QueryInterface())
    }
    private struct _ICanvasDeviceStatics {
        static var x : ICanvasDeviceStatics =
            try! RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasDevice")
    }
    public static var CanvasDeviceStatics : ICanvasDeviceStatics {
        _ICanvasDeviceStatics.x
    }
    public static func CreateFromDirect3D11Device(direct3DDevice : Optional<Windows.Graphics.DirectX.Direct3D11.IDirect3DDevice>) throws -> Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: CanvasDeviceStatics.CreateFromDirect3D11Device(direct3DDevice: direct3DDevice));
    }
    public static func GetSharedDevice() throws -> Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: CanvasDeviceStatics.GetSharedDevice());
    }
    public static func GetSharedDevice(forceSoftwareRenderer : boolean) throws -> Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: CanvasDeviceStatics.GetSharedDeviceWithForceSoftwareRenderer(forceSoftwareRenderer: forceSoftwareRenderer));
    }
    public static func put_DebugLevel(value : Microsoft.Graphics.Canvas.CanvasDebugLevel) throws -> Void {
        return try CanvasDeviceStatics.put_DebugLevel(value: value);
    }
    public static func get_DebugLevel() throws -> Microsoft.Graphics.Canvas.CanvasDebugLevel {
        return try CanvasDeviceStatics.get_DebugLevel();
    }
    public static var DebugLevel : Microsoft.Graphics.Canvas.CanvasDebugLevel {
        get throws {
        return try CanvasDeviceStatics.DebugLevel;
        }
    }
    public func get_ForceSoftwareRenderer() throws -> boolean {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.get_ForceSoftwareRenderer();
    }
    public func get_MaximumBitmapSizeInPixels() throws -> Swift.Int32 {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.get_MaximumBitmapSizeInPixels();
    }
    public func IsPixelFormatSupported(pixelFormat : Windows.Graphics.DirectX.DirectXPixelFormat) throws -> boolean {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.IsPixelFormatSupported(pixelFormat: pixelFormat);
    }
    public func IsBufferPrecisionSupported(bufferPrecision : Microsoft.Graphics.Canvas.CanvasBufferPrecision) throws -> boolean {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.IsBufferPrecisionSupported(bufferPrecision: bufferPrecision);
    }
    public func get_MaximumCacheSize() throws -> Swift.UInt64 {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.get_MaximumCacheSize();
    }
    public func put_MaximumCacheSize(value : Swift.UInt64) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.put_MaximumCacheSize(value: value);
    }
    public func get_LowPriority() throws -> boolean {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.get_LowPriority();
    }
    public func put_LowPriority(value : boolean) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.put_LowPriority(value: value);
    }
    public func add_DeviceLost(value : @escaping (Optional<Microsoft.Graphics.Canvas.CanvasDevice>, Optional<WinRT.Object>) throws -> Void) throws -> Windows.Foundation.EventRegistrationToken {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.add_DeviceLost(value: ClosedGenerics.impl_TypedEventHandler_2__q_CMicrosoft_CGraphics_CCanvas_CCanvasDevice_IInspectable(cb: value).Interface());
    }
    public func remove_DeviceLost(token : Windows.Foundation.EventRegistrationToken) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.remove_DeviceLost(token: token);
    }
    public func IsDeviceLost(hresult : Swift.Int32) throws -> boolean {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.IsDeviceLost(hresult: hresult);
    }
    public func RaiseDeviceLost() throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.RaiseDeviceLost();
    }
    public func Lock() throws -> Optional<Microsoft.Graphics.Canvas.CanvasLock> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasLock(plok: _ifc.Lock());
    }
    public var ForceSoftwareRenderer : boolean {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.ForceSoftwareRenderer;
        }
    }
    public var LowPriority : boolean {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.LowPriority;
        }
    }
    public var MaximumBitmapSizeInPixels : Swift.Int32 {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.MaximumBitmapSizeInPixels;
        }
    }
    public var MaximumCacheSize : Swift.UInt64 {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDevice = try _self.QueryInterface();
        return try _ifc.MaximumCacheSize;
        }
    }
    public func Trim() throws -> Void {
        let _ifc : Windows.Graphics.DirectX.Direct3D11.IDirect3DDevice = try _self.QueryInterface();
        return try _ifc.Trim();
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreator = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.get_Device());
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreator = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.Device);
        }
    }
}

// type: Microsoft.Graphics.Canvas.CanvasDpiRounding
// enum type
public typealias CanvasDpiRounding = _q_CMicrosoft_CGraphics_CCanvas_CCanvasDpiRounding;

// type: Microsoft.Graphics.Canvas.CanvasDrawingSession
// runtime class
public class CanvasDrawingSession
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.ICanvasDrawingSession;
    public init(plok: Microsoft.Graphics.Canvas.ICanvasDrawingSession?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.ICanvasDrawingSession { return _self; }
    public func Clear(color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.Clear(color: color);
    }
    public func Clear(color : Windows.Foundation.Numerics.Vector4) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.ClearHdr(color: color);
    }
    public func Flush() throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.Flush();
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageAtOrigin(image: image);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, offset : Windows.Foundation.Numerics.Vector2) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageAtOffset(image: image, offset: offset);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, x : Swift.Float, y : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageAtCoords(image: image, x: x, y: y);
    }
    public func DrawImage(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, destinationRectangle : Windows.Foundation.Rect) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageToRect(bitmap: bitmap!.Interface(), destinationRectangle: destinationRectangle);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, offset : Windows.Foundation.Numerics.Vector2, sourceRectangle : Windows.Foundation.Rect) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageAtOffsetWithSourceRect(image: image, offset: offset, sourceRectangle: sourceRectangle);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, x : Swift.Float, y : Swift.Float, sourceRectangle : Windows.Foundation.Rect) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageAtCoordsWithSourceRect(image: image, x: x, y: y, sourceRectangle: sourceRectangle);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, destinationRectangle : Windows.Foundation.Rect, sourceRectangle : Windows.Foundation.Rect) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageToRectWithSourceRect(image: image, destinationRectangle: destinationRectangle, sourceRectangle: sourceRectangle);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, offset : Windows.Foundation.Numerics.Vector2, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageAtOffsetWithSourceRectAndOpacity(image: image, offset: offset, sourceRectangle: sourceRectangle, opacity: opacity);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, x : Swift.Float, y : Swift.Float, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageAtCoordsWithSourceRectAndOpacity(image: image, x: x, y: y, sourceRectangle: sourceRectangle, opacity: opacity);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, destinationRectangle : Windows.Foundation.Rect, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageToRectWithSourceRectAndOpacity(image: image, destinationRectangle: destinationRectangle, sourceRectangle: sourceRectangle, opacity: opacity);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, offset : Windows.Foundation.Numerics.Vector2, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolation(image: image, offset: offset, sourceRectangle: sourceRectangle, opacity: opacity, interpolation: interpolation);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, x : Swift.Float, y : Swift.Float, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolation(image: image, x: x, y: y, sourceRectangle: sourceRectangle, opacity: opacity, interpolation: interpolation);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, destinationRectangle : Windows.Foundation.Rect, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageToRectWithSourceRectAndOpacityAndInterpolation(image: image, destinationRectangle: destinationRectangle, sourceRectangle: sourceRectangle, opacity: opacity, interpolation: interpolation);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, offset : Windows.Foundation.Numerics.Vector2, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, composite : Microsoft.Graphics.Canvas.CanvasComposite) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndComposite(image: image, offset: offset, sourceRectangle: sourceRectangle, opacity: opacity, interpolation: interpolation, composite: composite);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, x : Swift.Float, y : Swift.Float, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, composite : Microsoft.Graphics.Canvas.CanvasComposite) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndComposite(image: image, x: x, y: y, sourceRectangle: sourceRectangle, opacity: opacity, interpolation: interpolation, composite: composite);
    }
    public func DrawImage(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, destinationRectangle : Windows.Foundation.Rect, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, composite : Microsoft.Graphics.Canvas.CanvasComposite) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndComposite(image: image, destinationRectangle: destinationRectangle, sourceRectangle: sourceRectangle, opacity: opacity, interpolation: interpolation, composite: composite);
    }
    public func DrawImage(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, perspective : Windows.Foundation.Numerics.Matrix4x4) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndPerspective(bitmap: bitmap!.Interface(), offset: offset, sourceRectangle: sourceRectangle, opacity: opacity, interpolation: interpolation, perspective: perspective);
    }
    public func DrawImage(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, x : Swift.Float, y : Swift.Float, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, perspective : Windows.Foundation.Numerics.Matrix4x4) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndPerspective(bitmap: bitmap!.Interface(), x: x, y: y, sourceRectangle: sourceRectangle, opacity: opacity, interpolation: interpolation, perspective: perspective);
    }
    public func DrawImage(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, destinationRectangle : Windows.Foundation.Rect, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, perspective : Windows.Foundation.Numerics.Matrix4x4) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndPerspective(bitmap: bitmap!.Interface(), destinationRectangle: destinationRectangle, sourceRectangle: sourceRectangle, opacity: opacity, interpolation: interpolation, perspective: perspective);
    }
    public func DrawLine(point0 : Windows.Foundation.Numerics.Vector2, point1 : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawLineWithBrush(point0: point0, point1: point1, brush: brush);
    }
    public func DrawLine(x0 : Swift.Float, y0 : Swift.Float, x1 : Swift.Float, y1 : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawLineAtCoordsWithBrush(x0: x0, y0: y0, x1: x1, y1: y1, brush: brush);
    }
    public func DrawLine(point0 : Windows.Foundation.Numerics.Vector2, point1 : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawLineWithColor(point0: point0, point1: point1, color: color);
    }
    public func DrawLine(x0 : Swift.Float, y0 : Swift.Float, x1 : Swift.Float, y1 : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawLineAtCoordsWithColor(x0: x0, y0: y0, x1: x1, y1: y1, color: color);
    }
    public func DrawLine(point0 : Windows.Foundation.Numerics.Vector2, point1 : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawLineWithBrushAndStrokeWidth(point0: point0, point1: point1, brush: brush, strokeWidth: strokeWidth);
    }
    public func DrawLine(x0 : Swift.Float, y0 : Swift.Float, x1 : Swift.Float, y1 : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawLineAtCoordsWithBrushAndStrokeWidth(x0: x0, y0: y0, x1: x1, y1: y1, brush: brush, strokeWidth: strokeWidth);
    }
    public func DrawLine(point0 : Windows.Foundation.Numerics.Vector2, point1 : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawLineWithColorAndStrokeWidth(point0: point0, point1: point1, color: color, strokeWidth: strokeWidth);
    }
    public func DrawLine(x0 : Swift.Float, y0 : Swift.Float, x1 : Swift.Float, y1 : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawLineAtCoordsWithColorAndStrokeWidth(x0: x0, y0: y0, x1: x1, y1: y1, color: color, strokeWidth: strokeWidth);
    }
    public func DrawLine(point0 : Windows.Foundation.Numerics.Vector2, point1 : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawLineWithBrushAndStrokeWidthAndStrokeStyle(point0: point0, point1: point1, brush: brush, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawLine(x0 : Swift.Float, y0 : Swift.Float, x1 : Swift.Float, y1 : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawLineAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x0: x0, y0: y0, x1: x1, y1: y1, brush: brush, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawLine(point0 : Windows.Foundation.Numerics.Vector2, point1 : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawLineWithColorAndStrokeWidthAndStrokeStyle(point0: point0, point1: point1, color: color, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawLine(x0 : Swift.Float, y0 : Swift.Float, x1 : Swift.Float, y1 : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawLineAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x0: x0, y0: y0, x1: x1, y1: y1, color: color, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawRectangle(rect : Windows.Foundation.Rect, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRectangleWithBrush(rect: rect, brush: brush);
    }
    public func DrawRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRectangleAtCoordsWithBrush(x: x, y: y, w: w, h: h, brush: brush);
    }
    public func DrawRectangle(rect : Windows.Foundation.Rect, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRectangleWithColor(rect: rect, color: color);
    }
    public func DrawRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRectangleAtCoordsWithColor(x: x, y: y, w: w, h: h, color: color);
    }
    public func DrawRectangle(rect : Windows.Foundation.Rect, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRectangleWithBrushAndStrokeWidth(rect: rect, brush: brush, strokeWidth: strokeWidth);
    }
    public func DrawRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRectangleAtCoordsWithBrushAndStrokeWidth(x: x, y: y, w: w, h: h, brush: brush, strokeWidth: strokeWidth);
    }
    public func DrawRectangle(rect : Windows.Foundation.Rect, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRectangleWithColorAndStrokeWidth(rect: rect, color: color, strokeWidth: strokeWidth);
    }
    public func DrawRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRectangleAtCoordsWithColorAndStrokeWidth(x: x, y: y, w: w, h: h, color: color, strokeWidth: strokeWidth);
    }
    public func DrawRectangle(rect : Windows.Foundation.Rect, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRectangleWithBrushAndStrokeWidthAndStrokeStyle(rect: rect, brush: brush, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x: x, y: y, w: w, h: h, brush: brush, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawRectangle(rect : Windows.Foundation.Rect, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRectangleWithColorAndStrokeWidthAndStrokeStyle(rect: rect, color: color, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x: x, y: y, w: w, h: h, color: color, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func FillRectangle(rect : Windows.Foundation.Rect, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillRectangleWithBrush(rect: rect, brush: brush);
    }
    public func FillRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillRectangleAtCoordsWithBrush(x: x, y: y, w: w, h: h, brush: brush);
    }
    public func FillRectangle(rect : Windows.Foundation.Rect, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillRectangleWithColor(rect: rect, color: color);
    }
    public func FillRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillRectangleAtCoordsWithColor(x: x, y: y, w: w, h: h, color: color);
    }
    public func FillRectangle(rect : Windows.Foundation.Rect, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillRectangleWithBrushAndOpacityBrush(rect: rect, brush: brush, opacityBrush: opacityBrush);
    }
    public func FillRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillRectangleAtCoordsWithBrushAndOpacityBrush(x: x, y: y, w: w, h: h, brush: brush, opacityBrush: opacityBrush);
    }
    public func DrawRoundedRectangle(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRoundedRectangleWithBrush(rect: rect, radiusX: radiusX, radiusY: radiusY, brush: brush);
    }
    public func DrawRoundedRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRoundedRectangleAtCoordsWithBrush(x: x, y: y, w: w, h: h, radiusX: radiusX, radiusY: radiusY, brush: brush);
    }
    public func DrawRoundedRectangle(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRoundedRectangleWithColor(rect: rect, radiusX: radiusX, radiusY: radiusY, color: color);
    }
    public func DrawRoundedRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRoundedRectangleAtCoordsWithColor(x: x, y: y, w: w, h: h, radiusX: radiusX, radiusY: radiusY, color: color);
    }
    public func DrawRoundedRectangle(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRoundedRectangleWithBrushAndStrokeWidth(rect: rect, radiusX: radiusX, radiusY: radiusY, brush: brush, strokeWidth: strokeWidth);
    }
    public func DrawRoundedRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidth(x: x, y: y, w: w, h: h, radiusX: radiusX, radiusY: radiusY, brush: brush, strokeWidth: strokeWidth);
    }
    public func DrawRoundedRectangle(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRoundedRectangleWithColorAndStrokeWidth(rect: rect, radiusX: radiusX, radiusY: radiusY, color: color, strokeWidth: strokeWidth);
    }
    public func DrawRoundedRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRoundedRectangleAtCoordsWithColorAndStrokeWidth(x: x, y: y, w: w, h: h, radiusX: radiusX, radiusY: radiusY, color: color, strokeWidth: strokeWidth);
    }
    public func DrawRoundedRectangle(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRoundedRectangleWithBrushAndStrokeWidthAndStrokeStyle(rect: rect, radiusX: radiusX, radiusY: radiusY, brush: brush, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawRoundedRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x: x, y: y, w: w, h: h, radiusX: radiusX, radiusY: radiusY, brush: brush, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawRoundedRectangle(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRoundedRectangleWithColorAndStrokeWidthAndStrokeStyle(rect: rect, radiusX: radiusX, radiusY: radiusY, color: color, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawRoundedRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawRoundedRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x: x, y: y, w: w, h: h, radiusX: radiusX, radiusY: radiusY, color: color, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func FillRoundedRectangle(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillRoundedRectangleWithBrush(rect: rect, radiusX: radiusX, radiusY: radiusY, brush: brush);
    }
    public func FillRoundedRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillRoundedRectangleAtCoordsWithBrush(x: x, y: y, w: w, h: h, radiusX: radiusX, radiusY: radiusY, brush: brush);
    }
    public func FillRoundedRectangle(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillRoundedRectangleWithColor(rect: rect, radiusX: radiusX, radiusY: radiusY, color: color);
    }
    public func FillRoundedRectangle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillRoundedRectangleAtCoordsWithColor(x: x, y: y, w: w, h: h, radiusX: radiusX, radiusY: radiusY, color: color);
    }
    public func DrawEllipse(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawEllipseWithBrush(centerPoint: centerPoint, radiusX: radiusX, radiusY: radiusY, brush: brush);
    }
    public func DrawEllipse(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawEllipseAtCoordsWithBrush(x: x, y: y, radiusX: radiusX, radiusY: radiusY, brush: brush);
    }
    public func DrawEllipse(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawEllipseWithColor(centerPoint: centerPoint, radiusX: radiusX, radiusY: radiusY, color: color);
    }
    public func DrawEllipse(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawEllipseAtCoordsWithColor(x: x, y: y, radiusX: radiusX, radiusY: radiusY, color: color);
    }
    public func DrawEllipse(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawEllipseWithBrushAndStrokeWidth(centerPoint: centerPoint, radiusX: radiusX, radiusY: radiusY, brush: brush, strokeWidth: strokeWidth);
    }
    public func DrawEllipse(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawEllipseAtCoordsWithBrushAndStrokeWidth(x: x, y: y, radiusX: radiusX, radiusY: radiusY, brush: brush, strokeWidth: strokeWidth);
    }
    public func DrawEllipse(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawEllipseWithColorAndStrokeWidth(centerPoint: centerPoint, radiusX: radiusX, radiusY: radiusY, color: color, strokeWidth: strokeWidth);
    }
    public func DrawEllipse(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawEllipseAtCoordsWithColorAndStrokeWidth(x: x, y: y, radiusX: radiusX, radiusY: radiusY, color: color, strokeWidth: strokeWidth);
    }
    public func DrawEllipse(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawEllipseWithBrushAndStrokeWidthAndStrokeStyle(centerPoint: centerPoint, radiusX: radiusX, radiusY: radiusY, brush: brush, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawEllipse(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawEllipseAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x: x, y: y, radiusX: radiusX, radiusY: radiusY, brush: brush, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawEllipse(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawEllipseWithColorAndStrokeWidthAndStrokeStyle(centerPoint: centerPoint, radiusX: radiusX, radiusY: radiusY, color: color, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawEllipse(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawEllipseAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x: x, y: y, radiusX: radiusX, radiusY: radiusY, color: color, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func FillEllipse(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillEllipseWithBrush(centerPoint: centerPoint, radiusX: radiusX, radiusY: radiusY, brush: brush);
    }
    public func FillEllipse(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillEllipseAtCoordsWithBrush(x: x, y: y, radiusX: radiusX, radiusY: radiusY, brush: brush);
    }
    public func FillEllipse(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillEllipseWithColor(centerPoint: centerPoint, radiusX: radiusX, radiusY: radiusY, color: color);
    }
    public func FillEllipse(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillEllipseAtCoordsWithColor(x: x, y: y, radiusX: radiusX, radiusY: radiusY, color: color);
    }
    public func DrawCircle(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCircleWithBrush(centerPoint: centerPoint, radius: radius, brush: brush);
    }
    public func DrawCircle(x : Swift.Float, y : Swift.Float, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCircleAtCoordsWithBrush(x: x, y: y, radius: radius, brush: brush);
    }
    public func DrawCircle(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCircleWithColor(centerPoint: centerPoint, radius: radius, color: color);
    }
    public func DrawCircle(x : Swift.Float, y : Swift.Float, radius : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCircleAtCoordsWithColor(x: x, y: y, radius: radius, color: color);
    }
    public func DrawCircle(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCircleWithBrushAndStrokeWidth(centerPoint: centerPoint, radius: radius, brush: brush, strokeWidth: strokeWidth);
    }
    public func DrawCircle(x : Swift.Float, y : Swift.Float, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCircleAtCoordsWithBrushAndStrokeWidth(x: x, y: y, radius: radius, brush: brush, strokeWidth: strokeWidth);
    }
    public func DrawCircle(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCircleWithColorAndStrokeWidth(centerPoint: centerPoint, radius: radius, color: color, strokeWidth: strokeWidth);
    }
    public func DrawCircle(x : Swift.Float, y : Swift.Float, radius : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCircleAtCoordsWithColorAndStrokeWidth(x: x, y: y, radius: radius, color: color, strokeWidth: strokeWidth);
    }
    public func DrawCircle(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCircleWithBrushAndStrokeWidthAndStrokeStyle(centerPoint: centerPoint, radius: radius, brush: brush, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawCircle(x : Swift.Float, y : Swift.Float, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCircleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x: x, y: y, radius: radius, brush: brush, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawCircle(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCircleWithColorAndStrokeWidthAndStrokeStyle(centerPoint: centerPoint, radius: radius, color: color, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawCircle(x : Swift.Float, y : Swift.Float, radius : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCircleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x: x, y: y, radius: radius, color: color, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func FillCircle(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillCircleWithBrush(centerPoint: centerPoint, radius: radius, brush: brush);
    }
    public func FillCircle(x : Swift.Float, y : Swift.Float, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillCircleAtCoordsWithBrush(x: x, y: y, radius: radius, brush: brush);
    }
    public func FillCircle(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillCircleWithColor(centerPoint: centerPoint, radius: radius, color: color);
    }
    public func FillCircle(x : Swift.Float, y : Swift.Float, radius : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillCircleAtCoordsWithColor(x: x, y: y, radius: radius, color: color);
    }
    public func DrawText(text : Swift.String, point : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextAtPointWithColor(text: text, point: point, color: color);
    }
    public func DrawText(text : Swift.String, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextAtPointCoordsWithColor(text: text, x: x, y: y, color: color);
    }
    public func DrawText(text : Swift.String, point : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, format : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextFormat>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextAtPointWithBrushAndFormat(text: text, point: point, brush: brush, format: format!.Interface());
    }
    public func DrawText(text : Swift.String, rectangle : Windows.Foundation.Rect, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, format : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextFormat>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextAtRectWithBrushAndFormat(text: text, rectangle: rectangle, brush: brush, format: format!.Interface());
    }
    public func DrawText(text : Swift.String, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, format : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextFormat>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextAtPointCoordsWithBrushAndFormat(text: text, x: x, y: y, brush: brush, format: format!.Interface());
    }
    public func DrawText(text : Swift.String, x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, format : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextFormat>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextAtRectCoordsWithBrushAndFormat(text: text, x: x, y: y, w: w, h: h, brush: brush, format: format!.Interface());
    }
    public func DrawText(text : Swift.String, point : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color, format : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextFormat>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextAtPointWithColorAndFormat(text: text, point: point, color: color, format: format!.Interface());
    }
    public func DrawText(text : Swift.String, rectangle : Windows.Foundation.Rect, color : Windows.UI.Color, format : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextFormat>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextAtRectWithColorAndFormat(text: text, rectangle: rectangle, color: color, format: format!.Interface());
    }
    public func DrawText(text : Swift.String, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color, format : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextFormat>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextAtPointCoordsWithColorAndFormat(text: text, x: x, y: y, color: color, format: format!.Interface());
    }
    public func DrawText(text : Swift.String, x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, color : Windows.UI.Color, format : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextFormat>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextAtRectCoordsWithColorAndFormat(text: text, x: x, y: y, w: w, h: h, color: color, format: format!.Interface());
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryWithBrush(geometry: geometry!.Interface(), offset: offset, brush: brush);
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryWithColor(geometry: geometry!.Interface(), offset: offset, color: color);
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryAtCoordsWithBrush(geometry: geometry!.Interface(), x: x, y: y, brush: brush);
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryAtCoordsWithColor(geometry: geometry!.Interface(), x: x, y: y, color: color);
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryAtOriginWithBrush(geometry: geometry!.Interface(), brush: brush);
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryAtOriginWithColor(geometry: geometry!.Interface(), color: color);
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryWithBrushAndStrokeWidth(geometry: geometry!.Interface(), offset: offset, brush: brush, strokeWidth: strokeWidth);
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryWithColorAndStrokeWidth(geometry: geometry!.Interface(), offset: offset, color: color, strokeWidth: strokeWidth);
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryAtCoordsWithBrushAndStrokeWidth(geometry: geometry!.Interface(), x: x, y: y, brush: brush, strokeWidth: strokeWidth);
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryAtCoordsWithColorAndStrokeWidth(geometry: geometry!.Interface(), x: x, y: y, color: color, strokeWidth: strokeWidth);
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryAtOriginWithBrushAndStrokeWidth(geometry: geometry!.Interface(), brush: brush, strokeWidth: strokeWidth);
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryAtOriginWithColorAndStrokeWidth(geometry: geometry!.Interface(), color: color, strokeWidth: strokeWidth);
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryWithBrushAndStrokeWidthAndStrokeStyle(geometry: geometry!.Interface(), offset: offset, brush: brush, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryWithColorAndStrokeWidthAndStrokeStyle(geometry: geometry!.Interface(), offset: offset, color: color, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(geometry: geometry!.Interface(), x: x, y: y, brush: brush, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryAtCoordsWithColorAndStrokeWidthAndStrokeStyle(geometry: geometry!.Interface(), x: x, y: y, color: color, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryAtOriginWithBrushAndStrokeWidthAndStrokeStyle(geometry: geometry!.Interface(), brush: brush, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func DrawGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGeometryAtOriginWithColorAndStrokeWidthAndStrokeStyle(geometry: geometry!.Interface(), color: color, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func FillGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillGeometryWithBrush(geometry: geometry!.Interface(), offset: offset, brush: brush);
    }
    public func FillGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillGeometryWithBrushAndOpacityBrush(geometry: geometry!.Interface(), offset: offset, brush: brush, opacityBrush: opacityBrush);
    }
    public func FillGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillGeometryWithColor(geometry: geometry!.Interface(), offset: offset, color: color);
    }
    public func FillGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillGeometryAtCoordsWithBrush(geometry: geometry!.Interface(), x: x, y: y, brush: brush);
    }
    public func FillGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillGeometryAtCoordsWithBrushAndOpacityBrush(geometry: geometry!.Interface(), x: x, y: y, brush: brush, opacityBrush: opacityBrush);
    }
    public func FillGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillGeometryAtCoordsWithColor(geometry: geometry!.Interface(), x: x, y: y, color: color);
    }
    public func FillGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillGeometryAtOriginWithBrush(geometry: geometry!.Interface(), brush: brush);
    }
    public func FillGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillGeometryAtOriginWithBrushAndOpacityBrush(geometry: geometry!.Interface(), brush: brush, opacityBrush: opacityBrush);
    }
    public func FillGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.FillGeometryAtOriginWithColor(geometry: geometry!.Interface(), color: color);
    }
    public func DrawCachedGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry>, offset : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCachedGeometryWithBrush(geometry: geometry!.Interface(), offset: offset, brush: brush);
    }
    public func DrawCachedGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry>, offset : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCachedGeometryWithColor(geometry: geometry!.Interface(), offset: offset, color: color);
    }
    public func DrawCachedGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCachedGeometryAtCoordsWithBrush(geometry: geometry!.Interface(), x: x, y: y, brush: brush);
    }
    public func DrawCachedGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCachedGeometryAtCoordsWithColor(geometry: geometry!.Interface(), x: x, y: y, color: color);
    }
    public func DrawCachedGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry>, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCachedGeometryAtOriginWithBrush(geometry: geometry!.Interface(), brush: brush);
    }
    public func DrawCachedGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry>, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawCachedGeometryAtOriginWithColor(geometry: geometry!.Interface(), color: color);
    }
    public func DrawTextLayout(textLayout : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextLayout>, point : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextLayoutWithBrush(textLayout: textLayout!.Interface(), point: point, brush: brush);
    }
    public func DrawTextLayout(textLayout : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextLayout>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextLayoutAtCoordsWithBrush(textLayout: textLayout!.Interface(), x: x, y: y, brush: brush);
    }
    public func DrawTextLayout(textLayout : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextLayout>, point : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextLayoutWithColor(textLayout: textLayout!.Interface(), point: point, color: color);
    }
    public func DrawTextLayout(textLayout : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextLayout>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawTextLayoutAtCoordsWithColor(textLayout: textLayout!.Interface(), x: x, y: y, color: color);
    }
    public func DrawGradientMesh(gradientMesh : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGradientMesh>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGradientMeshAtOrigin(gradientMesh: gradientMesh!.Interface());
    }
    public func DrawGradientMesh(gradientMesh : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGradientMesh>, point : Windows.Foundation.Numerics.Vector2) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGradientMesh(gradientMesh: gradientMesh!.Interface(), point: point);
    }
    public func DrawGradientMesh(gradientMesh : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGradientMesh>, x : Swift.Float, y : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGradientMeshAtCoords(gradientMesh: gradientMesh!.Interface(), x: x, y: y);
    }
    public func DrawSvg(svgDocument : Optional<Microsoft.Graphics.Canvas.Svg.CanvasSvgDocument>, viewportSize : Windows.Foundation.Size) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawSvgAtOrigin(svgDocument: svgDocument!.Interface(), viewportSize: viewportSize);
    }
    public func DrawSvg(svgDocument : Optional<Microsoft.Graphics.Canvas.Svg.CanvasSvgDocument>, viewportSize : Windows.Foundation.Size, point : Windows.Foundation.Numerics.Vector2) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawSvgAtPoint(svgDocument: svgDocument!.Interface(), viewportSize: viewportSize, point: point);
    }
    public func DrawSvg(svgDocument : Optional<Microsoft.Graphics.Canvas.Svg.CanvasSvgDocument>, viewportSize : Windows.Foundation.Size, x : Swift.Float, y : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawSvgAtCoords(svgDocument: svgDocument!.Interface(), viewportSize: viewportSize, x: x, y: y);
    }
    public func get_Antialiasing() throws -> Microsoft.Graphics.Canvas.CanvasAntialiasing {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.get_Antialiasing();
    }
    public func put_Antialiasing(value : Microsoft.Graphics.Canvas.CanvasAntialiasing) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.put_Antialiasing(value: value);
    }
    public func get_Blend() throws -> Microsoft.Graphics.Canvas.CanvasBlend {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.get_Blend();
    }
    public func put_Blend(value : Microsoft.Graphics.Canvas.CanvasBlend) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.put_Blend(value: value);
    }
    public func get_TextAntialiasing() throws -> Microsoft.Graphics.Canvas.Text.CanvasTextAntialiasing {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.get_TextAntialiasing();
    }
    public func put_TextAntialiasing(value : Microsoft.Graphics.Canvas.Text.CanvasTextAntialiasing) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.put_TextAntialiasing(value: value);
    }
    public func get_TextRenderingParameters() throws -> Optional<Microsoft.Graphics.Canvas.Text.CanvasTextRenderingParameters> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.Text.CanvasTextRenderingParameters(plok: _ifc.get_TextRenderingParameters());
    }
    public func put_TextRenderingParameters(value : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextRenderingParameters>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.put_TextRenderingParameters(value: value!.Interface());
    }
    public func get_Transform() throws -> Windows.Foundation.Numerics.Matrix3x2 {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.get_Transform();
    }
    public func put_Transform(value : Windows.Foundation.Numerics.Matrix3x2) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.put_Transform(value: value);
    }
    public func get_Units() throws -> Microsoft.Graphics.Canvas.CanvasUnits {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.get_Units();
    }
    public func put_Units(value : Microsoft.Graphics.Canvas.CanvasUnits) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.put_Units(value: value);
    }
    public func get_EffectBufferPrecision() throws -> Optional<ClosedGenerics.IReference_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.get_EffectBufferPrecision();
    }
    public func put_EffectBufferPrecision(value : Optional<ClosedGenerics.IReference_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.put_EffectBufferPrecision(value: value);
    }
    public func get_EffectTileSize() throws -> Windows.Graphics.Imaging.BitmapSize {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.get_EffectTileSize();
    }
    public func put_EffectTileSize(value : Windows.Graphics.Imaging.BitmapSize) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.put_EffectTileSize(value: value);
    }
    public func CreateLayer(opacity : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.CanvasActiveLayer> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasActiveLayer(plok: _ifc.CreateLayerWithOpacity(opacity: opacity));
    }
    public func CreateLayer(opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Optional<Microsoft.Graphics.Canvas.CanvasActiveLayer> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasActiveLayer(plok: _ifc.CreateLayerWithOpacityBrush(opacityBrush: opacityBrush));
    }
    public func CreateLayer(opacity : Swift.Float, clipRectangle : Windows.Foundation.Rect) throws -> Optional<Microsoft.Graphics.Canvas.CanvasActiveLayer> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasActiveLayer(plok: _ifc.CreateLayerWithOpacityAndClipRectangle(opacity: opacity, clipRectangle: clipRectangle));
    }
    public func CreateLayer(opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, clipRectangle : Windows.Foundation.Rect) throws -> Optional<Microsoft.Graphics.Canvas.CanvasActiveLayer> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasActiveLayer(plok: _ifc.CreateLayerWithOpacityBrushAndClipRectangle(opacityBrush: opacityBrush, clipRectangle: clipRectangle));
    }
    public func CreateLayer(opacity : Swift.Float, clipGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>) throws -> Optional<Microsoft.Graphics.Canvas.CanvasActiveLayer> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasActiveLayer(plok: _ifc.CreateLayerWithOpacityAndClipGeometry(opacity: opacity, clipGeometry: clipGeometry!.Interface()));
    }
    public func CreateLayer(opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, clipGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>) throws -> Optional<Microsoft.Graphics.Canvas.CanvasActiveLayer> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasActiveLayer(plok: _ifc.CreateLayerWithOpacityBrushAndClipGeometry(opacityBrush: opacityBrush, clipGeometry: clipGeometry!.Interface()));
    }
    public func CreateLayer(opacity : Swift.Float, clipGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, geometryTransform : Windows.Foundation.Numerics.Matrix3x2) throws -> Optional<Microsoft.Graphics.Canvas.CanvasActiveLayer> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasActiveLayer(plok: _ifc.CreateLayerWithOpacityAndClipGeometryAndTransform(opacity: opacity, clipGeometry: clipGeometry!.Interface(), geometryTransform: geometryTransform));
    }
    public func CreateLayer(opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, clipGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, geometryTransform : Windows.Foundation.Numerics.Matrix3x2) throws -> Optional<Microsoft.Graphics.Canvas.CanvasActiveLayer> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasActiveLayer(plok: _ifc.CreateLayerWithOpacityBrushAndClipGeometryAndTransform(opacityBrush: opacityBrush, clipGeometry: clipGeometry!.Interface(), geometryTransform: geometryTransform));
    }
    public func CreateLayer(opacity : Swift.Float, opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, clipRectangle : Windows.Foundation.Rect, clipGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, geometryTransform : Windows.Foundation.Numerics.Matrix3x2, options : Microsoft.Graphics.Canvas.CanvasLayerOptions) throws -> Optional<Microsoft.Graphics.Canvas.CanvasActiveLayer> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasActiveLayer(plok: _ifc.CreateLayerWithAllOptions(opacity: opacity, opacityBrush: opacityBrush, clipRectangle: clipRectangle, clipGeometry: clipGeometry!.Interface(), geometryTransform: geometryTransform, options: options));
    }
    public func DrawGlyphRun(point : Windows.Foundation.Numerics.Vector2, fontFace : Optional<Microsoft.Graphics.Canvas.Text.CanvasFontFace>, fontSize : Swift.Float, glyphsLength : UINT32, glyphs : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasGlyph>>, isSideways : boolean, bidiLevel : Swift.UInt32, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGlyphRun(point: point, fontFace: fontFace!.Interface(), fontSize: fontSize, glyphsLength: glyphsLength, glyphs: glyphs, isSideways: isSideways, bidiLevel: bidiLevel, brush: brush);
    }
    public func DrawGlyphRun(point : Windows.Foundation.Numerics.Vector2, fontFace : Optional<Microsoft.Graphics.Canvas.Text.CanvasFontFace>, fontSize : Swift.Float, glyphsLength : UINT32, glyphs : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasGlyph>>, isSideways : boolean, bidiLevel : Swift.UInt32, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, measuringMode : Microsoft.Graphics.Canvas.Text.CanvasTextMeasuringMode) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGlyphRunWithMeasuringMode(point: point, fontFace: fontFace!.Interface(), fontSize: fontSize, glyphsLength: glyphsLength, glyphs: glyphs, isSideways: isSideways, bidiLevel: bidiLevel, brush: brush, measuringMode: measuringMode);
    }
    public func DrawGlyphRun(point : Windows.Foundation.Numerics.Vector2, fontFace : Optional<Microsoft.Graphics.Canvas.Text.CanvasFontFace>, fontSize : Swift.Float, glyphsLength : UINT32, glyphs : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasGlyph>>, isSideways : boolean, bidiLevel : Swift.UInt32, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, measuringMode : Microsoft.Graphics.Canvas.Text.CanvasTextMeasuringMode, localeName : Swift.String, textString : Swift.String, clusterMapIndicesLength : UINT32, clusterMapIndices : Optional<UnsafeMutablePointer<INT32>>, textPosition : Swift.UInt32) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.DrawGlyphRunWithMeasuringModeAndDescription(point: point, fontFace: fontFace!.Interface(), fontSize: fontSize, glyphsLength: glyphsLength, glyphs: glyphs, isSideways: isSideways, bidiLevel: bidiLevel, brush: brush, measuringMode: measuringMode, localeName: localeName, textString: textString, clusterMapIndicesLength: clusterMapIndicesLength, clusterMapIndices: clusterMapIndices, textPosition: textPosition);
    }
    public func CreateSpriteBatch() throws -> Optional<Microsoft.Graphics.Canvas.CanvasSpriteBatch> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasSpriteBatch(plok: _ifc.CreateSpriteBatch());
    }
    public func CreateSpriteBatch(sortMode : Microsoft.Graphics.Canvas.CanvasSpriteSortMode) throws -> Optional<Microsoft.Graphics.Canvas.CanvasSpriteBatch> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasSpriteBatch(plok: _ifc.CreateSpriteBatchWithSortMode(sortMode: sortMode));
    }
    public func CreateSpriteBatch(sortMode : Microsoft.Graphics.Canvas.CanvasSpriteSortMode, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation) throws -> Optional<Microsoft.Graphics.Canvas.CanvasSpriteBatch> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasSpriteBatch(plok: _ifc.CreateSpriteBatchWithSortModeAndInterpolation(sortMode: sortMode, interpolation: interpolation));
    }
    public func CreateSpriteBatch(sortMode : Microsoft.Graphics.Canvas.CanvasSpriteSortMode, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, options : Microsoft.Graphics.Canvas.CanvasSpriteOptions) throws -> Optional<Microsoft.Graphics.Canvas.CanvasSpriteBatch> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasSpriteBatch(plok: _ifc.CreateSpriteBatchWithSortModeAndInterpolationAndOptions(sortMode: sortMode, interpolation: interpolation, options: options));
    }
    public var Antialiasing : Microsoft.Graphics.Canvas.CanvasAntialiasing {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.Antialiasing;
        }
    }
    public var Blend : Microsoft.Graphics.Canvas.CanvasBlend {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.Blend;
        }
    }
    public var EffectBufferPrecision : Optional<ClosedGenerics.IReference_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision> {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.EffectBufferPrecision;
        }
    }
    public var EffectTileSize : Windows.Graphics.Imaging.BitmapSize {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.EffectTileSize;
        }
    }
    public var TextAntialiasing : Microsoft.Graphics.Canvas.Text.CanvasTextAntialiasing {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.TextAntialiasing;
        }
    }
    public var TextRenderingParameters : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextRenderingParameters> {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.Text.CanvasTextRenderingParameters(plok: _ifc.TextRenderingParameters);
        }
    }
    public var Transform : Windows.Foundation.Numerics.Matrix3x2 {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.Transform;
        }
    }
    public var Units : Microsoft.Graphics.Canvas.CanvasUnits {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasDrawingSession = try _self.QueryInterface();
        return try _ifc.Units;
        }
    }
    public func get_Dpi() throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.get_Dpi();
    }
    public func ConvertPixelsToDips(pixels : Swift.Int32) throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.ConvertPixelsToDips(pixels: pixels);
    }
    public func ConvertDipsToPixels(dips : Swift.Float, dpiRounding : Microsoft.Graphics.Canvas.CanvasDpiRounding) throws -> Swift.Int32 {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.ConvertDipsToPixels(dips: dips, dpiRounding: dpiRounding);
    }
    public var Dpi : Swift.Float {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.Dpi;
        }
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreator = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.get_Device());
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreator = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.Device);
        }
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.CanvasEdgeBehavior
// enum type
public typealias CanvasEdgeBehavior = _q_CMicrosoft_CGraphics_CCanvas_CCanvasEdgeBehavior;

// type: Microsoft.Graphics.Canvas.CanvasImage
// static class
public class CanvasImage
{
    private struct _ICanvasImageStatics {
        static var x : ICanvasImageStatics =
            try! RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasImage")
    }
    public static var CanvasImageStatics : ICanvasImageStatics {
        _ICanvasImageStatics.x
    }
    public static func SaveAsync(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, dpi : Swift.Float, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat) throws -> Optional<Windows.Foundation.IAsyncAction> {
        return try CanvasImageStatics.SaveAsync(image: image, sourceRectangle: sourceRectangle, dpi: dpi, resourceCreator: resourceCreator, stream: stream, fileFormat: fileFormat);
    }
    public static func Save(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, dpi : Swift.Float, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Self.SaveAsync(image: image, sourceRectangle: sourceRectangle, dpi: dpi, resourceCreator: resourceCreator, stream: stream, fileFormat: fileFormat)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func SaveAsync(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, dpi : Swift.Float, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float) throws -> Optional<Windows.Foundation.IAsyncAction> {
        return try CanvasImageStatics.SaveWithQualityAsync(image: image, sourceRectangle: sourceRectangle, dpi: dpi, resourceCreator: resourceCreator, stream: stream, fileFormat: fileFormat, quality: quality);
    }
    public static func Save(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, dpi : Swift.Float, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Self.SaveAsync(image: image, sourceRectangle: sourceRectangle, dpi: dpi, resourceCreator: resourceCreator, stream: stream, fileFormat: fileFormat, quality: quality)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func SaveAsync(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, dpi : Swift.Float, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float, bufferPrecision : Microsoft.Graphics.Canvas.CanvasBufferPrecision) throws -> Optional<Windows.Foundation.IAsyncAction> {
        return try CanvasImageStatics.SaveWithQualityAndBufferPrecisionAsync(image: image, sourceRectangle: sourceRectangle, dpi: dpi, resourceCreator: resourceCreator, stream: stream, fileFormat: fileFormat, quality: quality, bufferPrecision: bufferPrecision);
    }
    public static func Save(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, dpi : Swift.Float, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float, bufferPrecision : Microsoft.Graphics.Canvas.CanvasBufferPrecision) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Self.SaveAsync(image: image, sourceRectangle: sourceRectangle, dpi: dpi, resourceCreator: resourceCreator, stream: stream, fileFormat: fileFormat, quality: quality, bufferPrecision: bufferPrecision)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func ComputeHistogram(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, channelSelect : Microsoft.Graphics.Canvas.Effects.EffectChannelSelect, numberOfBins : Swift.Int32) throws -> UINT32 {
        return try CanvasImageStatics.ComputeHistogram(image: image, sourceRectangle: sourceRectangle, resourceCreator: resourceCreator, channelSelect: channelSelect, numberOfBins: numberOfBins);
    }
    public static func IsHistogramSupported(device : Optional<Microsoft.Graphics.Canvas.CanvasDevice>) throws -> boolean {
        return try CanvasImageStatics.IsHistogramSupported(device: device!.Interface());
    }
}

// type: Microsoft.Graphics.Canvas.CanvasImageInterpolation
// enum type
public typealias CanvasImageInterpolation = _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation;

// type: Microsoft.Graphics.Canvas.CanvasLayerOptions
// enum type
public typealias CanvasLayerOptions = _q_CMicrosoft_CGraphics_CCanvas_CCanvasLayerOptions;

// type: Microsoft.Graphics.Canvas.CanvasLock
// runtime class
public class CanvasLock
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.ICanvasLock;
    public init(plok: Microsoft.Graphics.Canvas.ICanvasLock?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.ICanvasLock { return _self; }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.CanvasRenderTarget
// runtime class
public class CanvasRenderTarget
    :
    Microsoft.Graphics.Canvas.CanvasBitmap
{
    private var _self : Microsoft.Graphics.Canvas.ICanvasRenderTarget;
    public init(plok: Microsoft.Graphics.Canvas.ICanvasRenderTarget?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.ICanvasRenderTarget { return _self; }
    public init(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi>, size : Windows.Foundation.Size) throws {
        let _af : ICanvasRenderTargetFactory = try RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasRenderTarget");
        _self = try _af.CreateWithSize(resourceCreator: resourceCreator, size: size)!;
        try super.init(plok: _self.QueryInterface())
    }
    public init(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi>, width : Swift.Float, height : Swift.Float) throws {
        let _af : ICanvasRenderTargetFactory = try RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasRenderTarget");
        _self = try _af.CreateWithWidthAndHeight(resourceCreator: resourceCreator, width: width, height: height)!;
        try super.init(plok: _self.QueryInterface())
    }
    public init(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, width : Swift.Float, height : Swift.Float, dpi : Swift.Float) throws {
        let _af : ICanvasRenderTargetFactory = try RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasRenderTarget");
        _self = try _af.CreateWithWidthAndHeightAndDpi(resourceCreator: resourceCreator, width: width, height: height, dpi: dpi)!;
        try super.init(plok: _self.QueryInterface())
    }
    public init(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, width : Swift.Float, height : Swift.Float, dpi : Swift.Float, format : Windows.Graphics.DirectX.DirectXPixelFormat, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws {
        let _af : ICanvasRenderTargetFactory = try RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasRenderTarget");
        _self = try _af.CreateWithWidthAndHeightAndDpiAndFormatAndAlpha(resourceCreator: resourceCreator, width: width, height: height, dpi: dpi, format: format, alpha: alpha)!;
        try super.init(plok: _self.QueryInterface())
    }
    private struct _ICanvasRenderTargetStatics {
        static var x : ICanvasRenderTargetStatics =
            try! RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasRenderTarget")
    }
    public static var CanvasRenderTargetStatics : ICanvasRenderTargetStatics {
        _ICanvasRenderTargetStatics.x
    }
// method not needed: CreateFromDirect3D11Surface
// method not needed: CreateFromDirect3D11Surface
// method not needed: CreateFromDirect3D11Surface
    public func CreateDrawingSession() throws -> Optional<Microsoft.Graphics.Canvas.CanvasDrawingSession> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasRenderTarget = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDrawingSession(plok: _ifc.CreateDrawingSession());
    }
}

// type: Microsoft.Graphics.Canvas.CanvasSpriteBatch
// runtime class
public class CanvasSpriteBatch
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.ICanvasSpriteBatch;
    public init(plok: Microsoft.Graphics.Canvas.ICanvasSpriteBatch?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.ICanvasSpriteBatch { return _self; }
    private struct _ICanvasSpriteBatchStatics {
        static var x : ICanvasSpriteBatchStatics =
            try! RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasSpriteBatch")
    }
    public static var CanvasSpriteBatchStatics : ICanvasSpriteBatchStatics {
        _ICanvasSpriteBatchStatics.x
    }
    public static func IsSupported(device : Optional<Microsoft.Graphics.Canvas.CanvasDevice>) throws -> boolean {
        return try CanvasSpriteBatchStatics.IsSupported(device: device!.Interface());
    }
    public func Draw(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, destRect : Windows.Foundation.Rect) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawToRect(bitmap: bitmap!.Interface(), destRect: destRect);
    }
    public func Draw(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawAtOffset(bitmap: bitmap!.Interface(), offset: offset);
    }
    public func Draw(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, transform : Windows.Foundation.Numerics.Matrix3x2) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawWithTransform(bitmap: bitmap!.Interface(), transform: transform);
    }
    public func Draw(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, destRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawToRectWithTint(bitmap: bitmap!.Interface(), destRect: destRect, tint: tint);
    }
    public func Draw(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2, tint : Windows.Foundation.Numerics.Vector4) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawAtOffsetWithTint(bitmap: bitmap!.Interface(), offset: offset, tint: tint);
    }
    public func Draw(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, transform : Windows.Foundation.Numerics.Matrix3x2, tint : Windows.Foundation.Numerics.Vector4) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawWithTransformAndTint(bitmap: bitmap!.Interface(), transform: transform, tint: tint);
    }
    public func Draw(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, destRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4, flip : Microsoft.Graphics.Canvas.CanvasSpriteFlip) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawToRectWithTintAndFlip(bitmap: bitmap!.Interface(), destRect: destRect, tint: tint, flip: flip);
    }
    public func Draw(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, transform : Windows.Foundation.Numerics.Matrix3x2, tint : Windows.Foundation.Numerics.Vector4, flip : Microsoft.Graphics.Canvas.CanvasSpriteFlip) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawWithTransformAndTintAndFlip(bitmap: bitmap!.Interface(), transform: transform, tint: tint, flip: flip);
    }
    public func Draw(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2, tint : Windows.Foundation.Numerics.Vector4, origin : Windows.Foundation.Numerics.Vector2, rotation : Swift.Float, scale : Windows.Foundation.Numerics.Vector2, flip : Microsoft.Graphics.Canvas.CanvasSpriteFlip) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawAtOffsetWithTintAndTransform(bitmap: bitmap!.Interface(), offset: offset, tint: tint, origin: origin, rotation: rotation, scale: scale, flip: flip);
    }
    public func DrawFromSpriteSheet(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, destRect : Windows.Foundation.Rect, sourceRect : Windows.Foundation.Rect) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawFromSpriteSheetToRect(bitmap: bitmap!.Interface(), destRect: destRect, sourceRect: sourceRect);
    }
    public func DrawFromSpriteSheet(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2, sourceRect : Windows.Foundation.Rect) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawFromSpriteSheetAtOffset(bitmap: bitmap!.Interface(), offset: offset, sourceRect: sourceRect);
    }
    public func DrawFromSpriteSheet(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, transform : Windows.Foundation.Numerics.Matrix3x2, sourceRect : Windows.Foundation.Rect) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawFromSpriteSheetWithTransform(bitmap: bitmap!.Interface(), transform: transform, sourceRect: sourceRect);
    }
    public func DrawFromSpriteSheet(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, destRect : Windows.Foundation.Rect, sourceRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawFromSpriteSheetToRectWithTint(bitmap: bitmap!.Interface(), destRect: destRect, sourceRect: sourceRect, tint: tint);
    }
    public func DrawFromSpriteSheet(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2, sourceRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawFromSpriteSheetAtOffsetWithTint(bitmap: bitmap!.Interface(), offset: offset, sourceRect: sourceRect, tint: tint);
    }
    public func DrawFromSpriteSheet(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, transform : Windows.Foundation.Numerics.Matrix3x2, sourceRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawFromSpriteSheetWithTransformAndTint(bitmap: bitmap!.Interface(), transform: transform, sourceRect: sourceRect, tint: tint);
    }
    public func DrawFromSpriteSheet(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, destRect : Windows.Foundation.Rect, sourceRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4, flip : Microsoft.Graphics.Canvas.CanvasSpriteFlip) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawFromSpriteSheetToRectWithTintAndFlip(bitmap: bitmap!.Interface(), destRect: destRect, sourceRect: sourceRect, tint: tint, flip: flip);
    }
    public func DrawFromSpriteSheet(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, transform : Windows.Foundation.Numerics.Matrix3x2, sourceRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4, flip : Microsoft.Graphics.Canvas.CanvasSpriteFlip) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawFromSpriteSheetWithTransformAndTintAndFlip(bitmap: bitmap!.Interface(), transform: transform, sourceRect: sourceRect, tint: tint, flip: flip);
    }
    public func DrawFromSpriteSheet(bitmap : Optional<Microsoft.Graphics.Canvas.CanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2, sourceRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4, origin : Windows.Foundation.Numerics.Vector2, rotation : Swift.Float, scale : Windows.Foundation.Numerics.Vector2, flip : Microsoft.Graphics.Canvas.CanvasSpriteFlip) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSpriteBatch = try _self.QueryInterface();
        return try _ifc.DrawFromSpriteSheetAtOffsetWithTintAndTransform(bitmap: bitmap!.Interface(), offset: offset, sourceRect: sourceRect, tint: tint, origin: origin, rotation: rotation, scale: scale, flip: flip);
    }
    public func get_Dpi() throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.get_Dpi();
    }
    public func ConvertPixelsToDips(pixels : Swift.Int32) throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.ConvertPixelsToDips(pixels: pixels);
    }
    public func ConvertDipsToPixels(dips : Swift.Float, dpiRounding : Microsoft.Graphics.Canvas.CanvasDpiRounding) throws -> Swift.Int32 {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.ConvertDipsToPixels(dips: dips, dpiRounding: dpiRounding);
    }
    public var Dpi : Swift.Float {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.Dpi;
        }
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreator = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.get_Device());
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreator = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.Device);
        }
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.CanvasSpriteFlip
// enum type
public typealias CanvasSpriteFlip = _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteFlip;

// type: Microsoft.Graphics.Canvas.CanvasSpriteOptions
// enum type
public typealias CanvasSpriteOptions = _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteOptions;

// type: Microsoft.Graphics.Canvas.CanvasSpriteSortMode
// enum type
public typealias CanvasSpriteSortMode = _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteSortMode;

// type: Microsoft.Graphics.Canvas.CanvasSwapChain
// runtime class
public class CanvasSwapChain
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.ICanvasSwapChain;
    public init(plok: Microsoft.Graphics.Canvas.ICanvasSwapChain?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.ICanvasSwapChain { return _self; }
    public init(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi>, size : Windows.Foundation.Size) throws {
        let _af : ICanvasSwapChainFactory = try RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasSwapChain");
        _self = try _af.CreateWithSize(resourceCreator: resourceCreator, size: size)!;
        try super.init(plok: _self.QueryInterface())
    }
    public init(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi>, width : Swift.Float, height : Swift.Float) throws {
        let _af : ICanvasSwapChainFactory = try RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasSwapChain");
        _self = try _af.CreateWithWidthAndHeight(resourceCreator: resourceCreator, width: width, height: height)!;
        try super.init(plok: _self.QueryInterface())
    }
    public init(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, width : Swift.Float, height : Swift.Float, dpi : Swift.Float) throws {
        let _af : ICanvasSwapChainFactory = try RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasSwapChain");
        _self = try _af.CreateWithWidthAndHeightAndDpi(resourceCreator: resourceCreator, width: width, height: height, dpi: dpi)!;
        try super.init(plok: _self.QueryInterface())
    }
    public init(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, width : Swift.Float, height : Swift.Float, dpi : Swift.Float, format : Windows.Graphics.DirectX.DirectXPixelFormat, bufferCount : Swift.Int32, alphaMode : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws {
        let _af : ICanvasSwapChainFactory = try RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasSwapChain");
        _self = try _af.CreateWithAllOptions(resourceCreator: resourceCreator, width: width, height: height, dpi: dpi, format: format, bufferCount: bufferCount, alphaMode: alphaMode)!;
        try super.init(plok: _self.QueryInterface())
    }
    private struct _ICanvasSwapChainStatics {
        static var x : ICanvasSwapChainStatics =
            try! RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasSwapChain")
    }
    public static var CanvasSwapChainStatics : ICanvasSwapChainStatics {
        _ICanvasSwapChainStatics.x
    }
    public static func CreateForCoreWindow(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, coreWindow : Optional<Windows.UI.Core.CoreWindow>, dpi : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.CanvasSwapChain> {
        return try Microsoft.Graphics.Canvas.CanvasSwapChain(plok: CanvasSwapChainStatics.CreateForCoreWindowWithDpi(resourceCreator: resourceCreator, coreWindow: coreWindow!.Interface(), dpi: dpi));
    }
    public static func CreateForCoreWindow(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, coreWindow : Optional<Windows.UI.Core.CoreWindow>, width : Swift.Float, height : Swift.Float, dpi : Swift.Float, format : Windows.Graphics.DirectX.DirectXPixelFormat, bufferCount : Swift.Int32) throws -> Optional<Microsoft.Graphics.Canvas.CanvasSwapChain> {
        return try Microsoft.Graphics.Canvas.CanvasSwapChain(plok: CanvasSwapChainStatics.CreateForCoreWindowWithAllOptions(resourceCreator: resourceCreator, coreWindow: coreWindow!.Interface(), width: width, height: height, dpi: dpi, format: format, bufferCount: bufferCount));
    }
    public func Present() throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.Present();
    }
    public func Present(syncInterval : Swift.Int32) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.PresentWithSyncInterval(syncInterval: syncInterval);
    }
    public func ResizeBuffers(newSize : Windows.Foundation.Size) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.ResizeBuffersWithSize(newSize: newSize);
    }
    public func ResizeBuffers(newWidth : Swift.Float, newHeight : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.ResizeBuffersWithWidthAndHeight(newWidth: newWidth, newHeight: newHeight);
    }
    public func ResizeBuffers(newWidth : Swift.Float, newHeight : Swift.Float, newDpi : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.ResizeBuffersWithWidthAndHeightAndDpi(newWidth: newWidth, newHeight: newHeight, newDpi: newDpi);
    }
    public func ResizeBuffers(newWidth : Swift.Float, newHeight : Swift.Float, newDpi : Swift.Float, newFormat : Windows.Graphics.DirectX.DirectXPixelFormat, bufferCount : Swift.Int32) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.ResizeBuffersWithAllOptions(newWidth: newWidth, newHeight: newHeight, newDpi: newDpi, newFormat: newFormat, bufferCount: bufferCount);
    }
    public func get_Size() throws -> Windows.Foundation.Size {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.get_Size();
    }
    public func get_SizeInPixels() throws -> Windows.Graphics.Imaging.BitmapSize {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.get_SizeInPixels();
    }
    public func get_Format() throws -> Windows.Graphics.DirectX.DirectXPixelFormat {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.get_Format();
    }
    public func get_BufferCount() throws -> Swift.Int32 {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.get_BufferCount();
    }
    public func get_AlphaMode() throws -> Microsoft.Graphics.Canvas.CanvasAlphaMode {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.get_AlphaMode();
    }
    public func get_Rotation() throws -> Microsoft.Graphics.Canvas.CanvasSwapChainRotation {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.get_Rotation();
    }
    public func put_Rotation(value : Microsoft.Graphics.Canvas.CanvasSwapChainRotation) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.put_Rotation(value: value);
    }
    public func get_SourceSize() throws -> Windows.Foundation.Size {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.get_SourceSize();
    }
    public func put_SourceSize(value : Windows.Foundation.Size) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.put_SourceSize(value: value);
    }
    public func get_TransformMatrix() throws -> Windows.Foundation.Numerics.Matrix3x2 {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.get_TransformMatrix();
    }
    public func put_TransformMatrix(value : Windows.Foundation.Numerics.Matrix3x2) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.put_TransformMatrix(value: value);
    }
    public func CreateDrawingSession(clearColor : Windows.UI.Color) throws -> Optional<Microsoft.Graphics.Canvas.CanvasDrawingSession> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDrawingSession(plok: _ifc.CreateDrawingSession(clearColor: clearColor));
    }
    public func WaitForVerticalBlank() throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.WaitForVerticalBlank();
    }
    public var AlphaMode : Microsoft.Graphics.Canvas.CanvasAlphaMode {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.AlphaMode;
        }
    }
    public var BufferCount : Swift.Int32 {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.BufferCount;
        }
    }
    public var Format : Windows.Graphics.DirectX.DirectXPixelFormat {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.Format;
        }
    }
    public var Rotation : Microsoft.Graphics.Canvas.CanvasSwapChainRotation {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.Rotation;
        }
    }
    public var Size : Windows.Foundation.Size {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.Size;
        }
    }
    public var SizeInPixels : Windows.Graphics.Imaging.BitmapSize {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.SizeInPixels;
        }
    }
    public var SourceSize : Windows.Foundation.Size {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.SourceSize;
        }
    }
    public var TransformMatrix : Windows.Foundation.Numerics.Matrix3x2 {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasSwapChain = try _self.QueryInterface();
        return try _ifc.TransformMatrix;
        }
    }
    public func get_Dpi() throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.get_Dpi();
    }
    public func ConvertPixelsToDips(pixels : Swift.Int32) throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.ConvertPixelsToDips(pixels: pixels);
    }
    public func ConvertDipsToPixels(dips : Swift.Float, dpiRounding : Microsoft.Graphics.Canvas.CanvasDpiRounding) throws -> Swift.Int32 {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.ConvertDipsToPixels(dips: dips, dpiRounding: dpiRounding);
    }
    public var Dpi : Swift.Float {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi = try _self.QueryInterface();
        return try _ifc.Dpi;
        }
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreator = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.get_Device());
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasResourceCreator = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.Device);
        }
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.CanvasSwapChainRotation
// enum type
public typealias CanvasSwapChainRotation = _q_CMicrosoft_CGraphics_CCanvas_CCanvasSwapChainRotation;

// type: Microsoft.Graphics.Canvas.CanvasUnits
// enum type
public typealias CanvasUnits = _q_CMicrosoft_CGraphics_CCanvas_CCanvasUnits;

// type: Microsoft.Graphics.Canvas.CanvasVirtualBitmap
// runtime class
public class CanvasVirtualBitmap
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.ICanvasVirtualBitmap;
    public init(plok: Microsoft.Graphics.Canvas.ICanvasVirtualBitmap?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.ICanvasVirtualBitmap { return _self; }
    private struct _ICanvasVirtualBitmapStatics {
        static var x : ICanvasVirtualBitmapStatics =
            try! RoGetActivationFactory("Microsoft.Graphics.Canvas.CanvasVirtualBitmap")
    }
    public static var CanvasVirtualBitmapStatics : ICanvasVirtualBitmapStatics {
        _ICanvasVirtualBitmapStatics.x
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Swift.String) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        return try CanvasVirtualBitmapStatics.LoadAsyncFromFileName(resourceCreator: resourceCreator, fileName: fileName);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Swift.String) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasVirtualBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, fileName: fileName)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Swift.String, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        return try CanvasVirtualBitmapStatics.LoadAsyncFromFileNameWithOptions(resourceCreator: resourceCreator, fileName: fileName, options: options);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Swift.String, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasVirtualBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, fileName: fileName, options: options)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Swift.String, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        return try CanvasVirtualBitmapStatics.LoadAsyncFromFileNameWithOptionsAndAlpha(resourceCreator: resourceCreator, fileName: fileName, options: options, alpha: alpha);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Swift.String, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasVirtualBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, fileName: fileName, options: options, alpha: alpha)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.Uri>) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        return try CanvasVirtualBitmapStatics.LoadAsyncFromUri(resourceCreator: resourceCreator, uri: uri!.Interface());
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.Uri>) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasVirtualBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, uri: uri)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.Uri>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        return try CanvasVirtualBitmapStatics.LoadAsyncFromUriWithOptions(resourceCreator: resourceCreator, uri: uri!.Interface(), options: options);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.Uri>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasVirtualBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, uri: uri, options: options)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.Uri>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        return try CanvasVirtualBitmapStatics.LoadAsyncFromUriWithOptionsAndAlpha(resourceCreator: resourceCreator, uri: uri!.Interface(), options: options, alpha: alpha);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.Uri>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasVirtualBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, uri: uri, options: options, alpha: alpha)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        return try CanvasVirtualBitmapStatics.LoadAsyncFromStream(resourceCreator: resourceCreator, stream: stream);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasVirtualBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, stream: stream)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        return try CanvasVirtualBitmapStatics.LoadAsyncFromStreamWithOptions(resourceCreator: resourceCreator, stream: stream, options: options);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasVirtualBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, stream: stream, options: options)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public static func LoadAsync(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        return try CanvasVirtualBitmapStatics.LoadAsyncFromStreamWithOptionsAndAlpha(resourceCreator: resourceCreator, stream: stream, options: options, alpha: alpha);
    }
    public static func Load(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) async throws -> Optional<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Microsoft.Graphics.Canvas.CanvasVirtualBitmap(plok: Self.LoadAsync(resourceCreator: resourceCreator, stream: stream, options: options, alpha: alpha)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasVirtualBitmap = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.get_Device());
    }
    public func get_IsCachedOnDemand() throws -> boolean {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasVirtualBitmap = try _self.QueryInterface();
        return try _ifc.get_IsCachedOnDemand();
    }
    public func get_SizeInPixels() throws -> Windows.Graphics.Imaging.BitmapSize {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasVirtualBitmap = try _self.QueryInterface();
        return try _ifc.get_SizeInPixels();
    }
    public func get_Size() throws -> Windows.Foundation.Size {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasVirtualBitmap = try _self.QueryInterface();
        return try _ifc.get_Size();
    }
    public func get_Bounds() throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasVirtualBitmap = try _self.QueryInterface();
        return try _ifc.get_Bounds();
    }
    public var Bounds : Windows.Foundation.Rect {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasVirtualBitmap = try _self.QueryInterface();
        return try _ifc.Bounds;
        }
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasVirtualBitmap = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.Device);
        }
    }
    public var IsCachedOnDemand : boolean {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasVirtualBitmap = try _self.QueryInterface();
        return try _ifc.IsCachedOnDemand;
        }
    }
    public var Size : Windows.Foundation.Size {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasVirtualBitmap = try _self.QueryInterface();
        return try _ifc.Size;
        }
    }
    public var SizeInPixels : Windows.Graphics.Imaging.BitmapSize {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasVirtualBitmap = try _self.QueryInterface();
        return try _ifc.SizeInPixels;
        }
    }
    public func GetBounds(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>) throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasImage = try _self.QueryInterface();
        return try _ifc.GetBounds(resourceCreator: resourceCreator);
    }
    public func GetBounds(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, transform : Windows.Foundation.Numerics.Matrix3x2) throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.ICanvasImage = try _self.QueryInterface();
        return try _ifc.GetBoundsWithTransform(resourceCreator: resourceCreator, transform: transform);
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions
// enum type
public typealias CanvasVirtualBitmapOptions = _q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmapOptions;

// type: Microsoft.Graphics.Canvas.ICanvasActiveLayer
// interface type
open class ICanvasActiveLayer
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x49ecfc58, Data2: 0x5e1c, Data3 : 0x4ee3, Data4 : (0x80, 0x88, 0x54, 0x2f, 0x94, 0xe9, 0x3c, 0x60)) }
} // ICanvasActiveLayer


// type: Microsoft.Graphics.Canvas.ICanvasBitmap
// interface type
open class ICanvasBitmap
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xc57532ed, Data2: 0x709e, Data3 : 0x4ac2, Data4 : (0x86, 0xbe, 0xa1, 0xec, 0x3a, 0x7f, 0xa8, 0xfe)) }
    // [IsSpecialName] Windows.Graphics.Imaging.BitmapSize get_SizeInPixels()
    private func _n_get_SizeInPixels(_ __presult: UnsafeMutablePointer<_q_CWindows_CGraphics_CImaging_CBitmapSize>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_SizeInPixels(pThis, __presult))
        }
    }
    public func get_SizeInPixels() throws -> Windows.Graphics.Imaging.BitmapSize {
        var __result : _q_CWindows_CGraphics_CImaging_CBitmapSize = _q_CWindows_CGraphics_CImaging_CBitmapSize(Width: 0, Height: 0);
        try self._n_get_SizeInPixels(&__result);
        return __result;
    }
    // [IsSpecialName] Windows.Foundation.Size get_Size()
    private func _n_get_Size(_ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CSize>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, __presult))
        }
    }
    public func get_Size() throws -> Windows.Foundation.Size {
        var __result : _q_CWindows_CFoundation_CSize = _q_CWindows_CFoundation_CSize(Width: 0, Height: 0);
        try self._n_get_Size(&__result);
        return __result;
    }
    // [IsSpecialName] Windows.Foundation.Rect get_Bounds()
    private func _n_get_Bounds(_ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CRect>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Bounds(pThis, __presult))
        }
    }
    public func get_Bounds() throws -> Windows.Foundation.Rect {
        var __result : _q_CWindows_CFoundation_CRect = _q_CWindows_CFoundation_CRect(X: 0, Y: 0, Width: 0, Height: 0);
        try self._n_get_Bounds(&__result);
        return __result;
    }
    // [IsSpecialName] Windows.Graphics.DirectX.DirectXPixelFormat get_Format()
    private func _n_get_Format(_ __presult: UnsafeMutablePointer<_q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Format(pThis, __presult))
        }
    }
    public func get_Format() throws -> Windows.Graphics.DirectX.DirectXPixelFormat {
        var __result : _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat = _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat_Unknown;
        try self._n_get_Format(&__result);
        return __result;
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.CanvasAlphaMode get_AlphaMode()
    private func _n_get_AlphaMode(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_AlphaMode(pThis, __presult))
        }
    }
    public func get_AlphaMode() throws -> Microsoft.Graphics.Canvas.CanvasAlphaMode {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode = _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode_Premultiplied;
        try self._n_get_AlphaMode(&__result);
        return __result;
    }
    // Windows.Foundation.IAsyncAction SaveAsync(System.String)
    private func _n_SaveToFileAsync(_ fileName : Optional<HSTRING>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SaveToFileAsync(pThis, fileName, __presult))
        }
    }
    public func SaveToFileAsync(fileName : Optional<Swift.String>) throws -> Optional<Windows.Foundation.IAsyncAction> {
        let __hstr_fileName = try HString(fileName!);
        return try withExtendedLifetime(__hstr_fileName) {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>> = nil;
        try self._n_SaveToFileAsync(__hstr_fileName.Raw(), &__result);
        return Windows.Foundation.IAsyncAction(consuming: __result);
        }
    }
    public func SaveToFile(fileName : Optional<Swift.String>) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.SaveToFileAsync(fileName: fileName)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncAction SaveAsync(System.String, Microsoft.Graphics.Canvas.CanvasBitmapFileFormat)
    private func _n_SaveToFileWithBitmapFileFormatAsync(_ fileName : Optional<HSTRING>, _ fileFormat : _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SaveToFileWithBitmapFileFormatAsync(pThis, fileName, fileFormat, __presult))
        }
    }
    public func SaveToFileWithBitmapFileFormatAsync(fileName : Optional<Swift.String>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat) throws -> Optional<Windows.Foundation.IAsyncAction> {
        let __hstr_fileName = try HString(fileName!);
        return try withExtendedLifetime(__hstr_fileName) {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>> = nil;
        try self._n_SaveToFileWithBitmapFileFormatAsync(__hstr_fileName.Raw(), fileFormat, &__result);
        return Windows.Foundation.IAsyncAction(consuming: __result);
        }
    }
    public func SaveToFileWithBitmapFileFormat(fileName : Optional<Swift.String>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.SaveToFileWithBitmapFileFormatAsync(fileName: fileName, fileFormat: fileFormat)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncAction SaveAsync(System.String, Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, System.Single)
    private func _n_SaveToFileWithBitmapFileFormatAndQualityAsync(_ fileName : Optional<HSTRING>, _ fileFormat : _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat, _ quality : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SaveToFileWithBitmapFileFormatAndQualityAsync(pThis, fileName, fileFormat, quality, __presult))
        }
    }
    public func SaveToFileWithBitmapFileFormatAndQualityAsync(fileName : Optional<Swift.String>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float) throws -> Optional<Windows.Foundation.IAsyncAction> {
        let __hstr_fileName = try HString(fileName!);
        return try withExtendedLifetime(__hstr_fileName) {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>> = nil;
        try self._n_SaveToFileWithBitmapFileFormatAndQualityAsync(__hstr_fileName.Raw(), fileFormat, quality, &__result);
        return Windows.Foundation.IAsyncAction(consuming: __result);
        }
    }
    public func SaveToFileWithBitmapFileFormatAndQuality(fileName : Optional<Swift.String>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.SaveToFileWithBitmapFileFormatAndQualityAsync(fileName: fileName, fileFormat: fileFormat, quality: quality)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncAction SaveAsync(Windows.Storage.Streams.IRandomAccessStream, Microsoft.Graphics.Canvas.CanvasBitmapFileFormat)
    private func _n_SaveToStreamAsync(_ stream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIRandomAccessStream>>, _ fileFormat : _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SaveToStreamAsync(pThis, stream, fileFormat, __presult))
        }
    }
    public func SaveToStreamAsync(stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat) throws -> Optional<Windows.Foundation.IAsyncAction> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>> = nil;
        try self._n_SaveToStreamAsync(RawPointer(stream), fileFormat, &__result);
        return Windows.Foundation.IAsyncAction(consuming: __result);
    }
    public func SaveToStream(stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.SaveToStreamAsync(stream: stream, fileFormat: fileFormat)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncAction SaveAsync(Windows.Storage.Streams.IRandomAccessStream, Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, System.Single)
    private func _n_SaveToStreamWithQualityAsync(_ stream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIRandomAccessStream>>, _ fileFormat : _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat, _ quality : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SaveToStreamWithQualityAsync(pThis, stream, fileFormat, quality, __presult))
        }
    }
    public func SaveToStreamWithQualityAsync(stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float) throws -> Optional<Windows.Foundation.IAsyncAction> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>> = nil;
        try self._n_SaveToStreamWithQualityAsync(RawPointer(stream), fileFormat, quality, &__result);
        return Windows.Foundation.IAsyncAction(consuming: __result);
    }
    public func SaveToStreamWithQuality(stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.SaveToStreamWithQualityAsync(stream: stream, fileFormat: fileFormat, quality: quality)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // System.Byte[] GetPixelBytes()
    private func _n_GetPixelBytes(_ __presultLength: UnsafeMutablePointer<UINT32>?, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<UINT8>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetPixelBytes(pThis, __presultLength, __presult))
        }
    }
    public func GetPixelBytes() throws -> UINT32 {
        var __resultLength : UINT32 = 0;
        var __result : Optional<UnsafeMutablePointer<UINT8>> = nil;
        try self._n_GetPixelBytes(&__resultLength, &__result);
        return __resultLength;
    }
    // System.Byte[] GetPixelBytes(System.Int32, System.Int32, System.Int32, System.Int32)
    private func _n_GetPixelBytesWithSubrectangle(_ left : INT32, _ top : INT32, _ width : INT32, _ height : INT32, _ __presultLength: UnsafeMutablePointer<UINT32>?, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<UINT8>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetPixelBytesWithSubrectangle(pThis, left, top, width, height, __presultLength, __presult))
        }
    }
    public func GetPixelBytesWithSubrectangle(left : Swift.Int32, top : Swift.Int32, width : Swift.Int32, height : Swift.Int32) throws -> UINT32 {
        var __resultLength : UINT32 = 0;
        var __result : Optional<UnsafeMutablePointer<UINT8>> = nil;
        try self._n_GetPixelBytesWithSubrectangle(left, top, width, height, &__resultLength, &__result);
        return __resultLength;
    }
    // void GetPixelBytes(Windows.Storage.Streams.IBuffer)
    private func _n_GetPixelBytesWithBuffer(_ buffer : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetPixelBytesWithBuffer(pThis, buffer))
        }
    }
    public func GetPixelBytesWithBuffer(buffer : Optional<Windows.Storage.Streams.IBuffer>) throws -> Void {
        try self._n_GetPixelBytesWithBuffer(RawPointer(buffer));
    }
    // void GetPixelBytes(Windows.Storage.Streams.IBuffer, System.Int32, System.Int32, System.Int32, System.Int32)
    private func _n_GetPixelBytesWithBufferAndSubrectangle(_ buffer : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ left : INT32, _ top : INT32, _ width : INT32, _ height : INT32) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetPixelBytesWithBufferAndSubrectangle(pThis, buffer, left, top, width, height))
        }
    }
    public func GetPixelBytesWithBufferAndSubrectangle(buffer : Optional<Windows.Storage.Streams.IBuffer>, left : Swift.Int32, top : Swift.Int32, width : Swift.Int32, height : Swift.Int32) throws -> Void {
        try self._n_GetPixelBytesWithBufferAndSubrectangle(RawPointer(buffer), left, top, width, height);
    }
    // Windows.UI.Color[] GetPixelColors()
    private func _n_GetPixelColors(_ __presultLength: UnsafeMutablePointer<UINT32>?, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetPixelColors(pThis, __presultLength, __presult))
        }
    }
    public func GetPixelColors() throws -> UINT32 {
        var __resultLength : UINT32 = 0;
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>> = nil;
        try self._n_GetPixelColors(&__resultLength, &__result);
        return __resultLength;
    }
    // Windows.UI.Color[] GetPixelColors(System.Int32, System.Int32, System.Int32, System.Int32)
    private func _n_GetPixelColorsWithSubrectangle(_ left : INT32, _ top : INT32, _ width : INT32, _ height : INT32, _ __presultLength: UnsafeMutablePointer<UINT32>?, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetPixelColorsWithSubrectangle(pThis, left, top, width, height, __presultLength, __presult))
        }
    }
    public func GetPixelColorsWithSubrectangle(left : Swift.Int32, top : Swift.Int32, width : Swift.Int32, height : Swift.Int32) throws -> UINT32 {
        var __resultLength : UINT32 = 0;
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>> = nil;
        try self._n_GetPixelColorsWithSubrectangle(left, top, width, height, &__resultLength, &__result);
        return __resultLength;
    }
    // void SetPixelBytes(System.Byte[])
    private func _n_SetPixelBytes(_ valueElementsLength : UINT32, _ valueElements : Optional<UnsafeMutablePointer<UINT8>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetPixelBytes(pThis, valueElementsLength, valueElements))
        }
    }
    public func SetPixelBytes(valueElementsLength : UINT32, valueElements : Optional<UnsafeMutablePointer<UINT8>>) throws -> Void {
        try self._n_SetPixelBytes(valueElementsLength, valueElements);
    }
    // void SetPixelBytes(System.Byte[], System.Int32, System.Int32, System.Int32, System.Int32)
    private func _n_SetPixelBytesWithSubrectangle(_ valueElementsLength : UINT32, _ valueElements : Optional<UnsafeMutablePointer<UINT8>>, _ left : INT32, _ top : INT32, _ width : INT32, _ height : INT32) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetPixelBytesWithSubrectangle(pThis, valueElementsLength, valueElements, left, top, width, height))
        }
    }
    public func SetPixelBytesWithSubrectangle(valueElementsLength : UINT32, valueElements : Optional<UnsafeMutablePointer<UINT8>>, left : Swift.Int32, top : Swift.Int32, width : Swift.Int32, height : Swift.Int32) throws -> Void {
        try self._n_SetPixelBytesWithSubrectangle(valueElementsLength, valueElements, left, top, width, height);
    }
    // void SetPixelBytes(Windows.Storage.Streams.IBuffer)
    private func _n_SetPixelBytesWithBuffer(_ buffer : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetPixelBytesWithBuffer(pThis, buffer))
        }
    }
    public func SetPixelBytesWithBuffer(buffer : Optional<Windows.Storage.Streams.IBuffer>) throws -> Void {
        try self._n_SetPixelBytesWithBuffer(RawPointer(buffer));
    }
    // void SetPixelBytes(Windows.Storage.Streams.IBuffer, System.Int32, System.Int32, System.Int32, System.Int32)
    private func _n_SetPixelBytesWithBufferAndSubrectangle(_ buffer : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ left : INT32, _ top : INT32, _ width : INT32, _ height : INT32) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetPixelBytesWithBufferAndSubrectangle(pThis, buffer, left, top, width, height))
        }
    }
    public func SetPixelBytesWithBufferAndSubrectangle(buffer : Optional<Windows.Storage.Streams.IBuffer>, left : Swift.Int32, top : Swift.Int32, width : Swift.Int32, height : Swift.Int32) throws -> Void {
        try self._n_SetPixelBytesWithBufferAndSubrectangle(RawPointer(buffer), left, top, width, height);
    }
    // void SetPixelColors(Windows.UI.Color[])
    private func _n_SetPixelColors(_ valueElementsLength : UINT32, _ valueElements : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetPixelColors(pThis, valueElementsLength, valueElements))
        }
    }
    public func SetPixelColors(valueElementsLength : UINT32, valueElements : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>) throws -> Void {
        try self._n_SetPixelColors(valueElementsLength, valueElements);
    }
    // void SetPixelColors(Windows.UI.Color[], System.Int32, System.Int32, System.Int32, System.Int32)
    private func _n_SetPixelColorsWithSubrectangle(_ valueElementsLength : UINT32, _ valueElements : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>, _ left : INT32, _ top : INT32, _ width : INT32, _ height : INT32) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetPixelColorsWithSubrectangle(pThis, valueElementsLength, valueElements, left, top, width, height))
        }
    }
    public func SetPixelColorsWithSubrectangle(valueElementsLength : UINT32, valueElements : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>, left : Swift.Int32, top : Swift.Int32, width : Swift.Int32, height : Swift.Int32) throws -> Void {
        try self._n_SetPixelColorsWithSubrectangle(valueElementsLength, valueElements, left, top, width, height);
    }
    // void CopyPixelsFromBitmap(Microsoft.Graphics.Canvas.CanvasBitmap)
    private func _n_CopyPixelsFromBitmap(_ otherBitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CopyPixelsFromBitmap(pThis, otherBitmap))
        }
    }
    public func CopyPixelsFromBitmap(otherBitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>) throws -> Void {
        try self._n_CopyPixelsFromBitmap(RawPointer(otherBitmap));
    }
    // void CopyPixelsFromBitmap(Microsoft.Graphics.Canvas.CanvasBitmap, System.Int32, System.Int32)
    private func _n_CopyPixelsFromBitmapWithDestPoint(_ otherBitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ destX : INT32, _ destY : INT32) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CopyPixelsFromBitmapWithDestPoint(pThis, otherBitmap, destX, destY))
        }
    }
    public func CopyPixelsFromBitmapWithDestPoint(otherBitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, destX : Swift.Int32, destY : Swift.Int32) throws -> Void {
        try self._n_CopyPixelsFromBitmapWithDestPoint(RawPointer(otherBitmap), destX, destY);
    }
    // void CopyPixelsFromBitmap(Microsoft.Graphics.Canvas.CanvasBitmap, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32, System.Int32)
    private func _n_CopyPixelsFromBitmapWithDestPointAndSourceRect(_ otherBitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ destX : INT32, _ destY : INT32, _ sourceRectLeft : INT32, _ sourceRectTop : INT32, _ sourceRectWidth : INT32, _ sourceRectHeight : INT32) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CopyPixelsFromBitmapWithDestPointAndSourceRect(pThis, otherBitmap, destX, destY, sourceRectLeft, sourceRectTop, sourceRectWidth, sourceRectHeight))
        }
    }
    public func CopyPixelsFromBitmapWithDestPointAndSourceRect(otherBitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, destX : Swift.Int32, destY : Swift.Int32, sourceRectLeft : Swift.Int32, sourceRectTop : Swift.Int32, sourceRectWidth : Swift.Int32, sourceRectHeight : Swift.Int32) throws -> Void {
        try self._n_CopyPixelsFromBitmapWithDestPointAndSourceRect(RawPointer(otherBitmap), destX, destY, sourceRectLeft, sourceRectTop, sourceRectWidth, sourceRectHeight);
    }
    public var AlphaMode : Microsoft.Graphics.Canvas.CanvasAlphaMode {
        get throws {
            return try get_AlphaMode();
        }
    }
    public var Bounds : Windows.Foundation.Rect {
        get throws {
            return try get_Bounds();
        }
    }
    public var Format : Windows.Graphics.DirectX.DirectXPixelFormat {
        get throws {
            return try get_Format();
        }
    }
    public var Size : Windows.Foundation.Size {
        get throws {
            return try get_Size();
        }
    }
    public var SizeInPixels : Windows.Graphics.Imaging.BitmapSize {
        get throws {
            return try get_SizeInPixels();
        }
    }
} // ICanvasBitmap


// type: Microsoft.Graphics.Canvas.ICanvasBitmapStatics
// interface type
open class ICanvasBitmapStatics
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xc8948dea, Data2: 0xa41d, Data3 : 0x4cc2, Data4 : (0xaf, 0x9a, 0xfd, 0xde, 0x01, 0xb6, 0x06, 0xdc)) }
    // Microsoft.Graphics.Canvas.CanvasBitmap CreateFromDirect3D11Surface(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface)
    private func _n_CreateFromDirect3D11Surface(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ surface : Optional<UnsafeMutablePointer<_q_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DSurface>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromDirect3D11Surface(pThis, resourceCreator, surface, __presult))
        }
    }
    public func CreateFromDirect3D11Surface(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, surface : Optional<Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface>) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>> = nil;
        try self._n_CreateFromDirect3D11Surface(RawPointer(resourceCreator), RawPointer(surface), &__result);
        return Microsoft.Graphics.Canvas.ICanvasBitmap(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasBitmap CreateFromDirect3D11Surface(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface, System.Single)
    private func _n_CreateFromDirect3D11SurfaceWithDpi(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ surface : Optional<UnsafeMutablePointer<_q_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DSurface>>, _ dpi : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromDirect3D11SurfaceWithDpi(pThis, resourceCreator, surface, dpi, __presult))
        }
    }
    public func CreateFromDirect3D11SurfaceWithDpi(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, surface : Optional<Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface>, dpi : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>> = nil;
        try self._n_CreateFromDirect3D11SurfaceWithDpi(RawPointer(resourceCreator), RawPointer(surface), dpi, &__result);
        return Microsoft.Graphics.Canvas.ICanvasBitmap(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasBitmap CreateFromDirect3D11Surface(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface, System.Single, Microsoft.Graphics.Canvas.CanvasAlphaMode)
    private func _n_CreateFromDirect3D11SurfaceWithDpiAndAlpha(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ surface : Optional<UnsafeMutablePointer<_q_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DSurface>>, _ dpi : FLOAT, _ alpha : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromDirect3D11SurfaceWithDpiAndAlpha(pThis, resourceCreator, surface, dpi, alpha, __presult))
        }
    }
    public func CreateFromDirect3D11SurfaceWithDpiAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, surface : Optional<Windows.Graphics.DirectX.Direct3D11.IDirect3DSurface>, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>> = nil;
        try self._n_CreateFromDirect3D11SurfaceWithDpiAndAlpha(RawPointer(resourceCreator), RawPointer(surface), dpi, alpha, &__result);
        return Microsoft.Graphics.Canvas.ICanvasBitmap(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasBitmap CreateFromBytes(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.Byte[], System.Int32, System.Int32, Windows.Graphics.DirectX.DirectXPixelFormat)
    private func _n_CreateFromBytes(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ bytesLength : UINT32, _ bytes : Optional<UnsafeMutablePointer<UINT8>>, _ widthInPixels : INT32, _ heightInPixels : INT32, _ format : _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromBytes(pThis, resourceCreator, bytesLength, bytes, widthInPixels, heightInPixels, format, __presult))
        }
    }
    public func CreateFromBytes(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, bytesLength : UINT32, bytes : Optional<UnsafeMutablePointer<UINT8>>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, format : Windows.Graphics.DirectX.DirectXPixelFormat) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>> = nil;
        try self._n_CreateFromBytes(RawPointer(resourceCreator), bytesLength, bytes, widthInPixels, heightInPixels, format, &__result);
        return Microsoft.Graphics.Canvas.ICanvasBitmap(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasBitmap CreateFromBytes(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.Byte[], System.Int32, System.Int32, Windows.Graphics.DirectX.DirectXPixelFormat, System.Single)
    private func _n_CreateFromBytesWithDpi(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ bytesLength : UINT32, _ bytes : Optional<UnsafeMutablePointer<UINT8>>, _ widthInPixels : INT32, _ heightInPixels : INT32, _ format : _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat, _ dpi : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromBytesWithDpi(pThis, resourceCreator, bytesLength, bytes, widthInPixels, heightInPixels, format, dpi, __presult))
        }
    }
    public func CreateFromBytesWithDpi(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, bytesLength : UINT32, bytes : Optional<UnsafeMutablePointer<UINT8>>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, format : Windows.Graphics.DirectX.DirectXPixelFormat, dpi : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>> = nil;
        try self._n_CreateFromBytesWithDpi(RawPointer(resourceCreator), bytesLength, bytes, widthInPixels, heightInPixels, format, dpi, &__result);
        return Microsoft.Graphics.Canvas.ICanvasBitmap(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasBitmap CreateFromBytes(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.Byte[], System.Int32, System.Int32, Windows.Graphics.DirectX.DirectXPixelFormat, System.Single, Microsoft.Graphics.Canvas.CanvasAlphaMode)
    private func _n_CreateFromBytesWithDpiAndAlpha(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ bytesLength : UINT32, _ bytes : Optional<UnsafeMutablePointer<UINT8>>, _ widthInPixels : INT32, _ heightInPixels : INT32, _ format : _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat, _ dpi : FLOAT, _ alpha : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromBytesWithDpiAndAlpha(pThis, resourceCreator, bytesLength, bytes, widthInPixels, heightInPixels, format, dpi, alpha, __presult))
        }
    }
    public func CreateFromBytesWithDpiAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, bytesLength : UINT32, bytes : Optional<UnsafeMutablePointer<UINT8>>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, format : Windows.Graphics.DirectX.DirectXPixelFormat, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>> = nil;
        try self._n_CreateFromBytesWithDpiAndAlpha(RawPointer(resourceCreator), bytesLength, bytes, widthInPixels, heightInPixels, format, dpi, alpha, &__result);
        return Microsoft.Graphics.Canvas.ICanvasBitmap(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasBitmap CreateFromBytes(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Storage.Streams.IBuffer, System.Int32, System.Int32, Windows.Graphics.DirectX.DirectXPixelFormat)
    private func _n_CreateFromBytesWithBuffer(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ buffer : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ widthInPixels : INT32, _ heightInPixels : INT32, _ format : _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromBytesWithBuffer(pThis, resourceCreator, buffer, widthInPixels, heightInPixels, format, __presult))
        }
    }
    public func CreateFromBytesWithBuffer(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, buffer : Optional<Windows.Storage.Streams.IBuffer>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, format : Windows.Graphics.DirectX.DirectXPixelFormat) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>> = nil;
        try self._n_CreateFromBytesWithBuffer(RawPointer(resourceCreator), RawPointer(buffer), widthInPixels, heightInPixels, format, &__result);
        return Microsoft.Graphics.Canvas.ICanvasBitmap(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasBitmap CreateFromBytes(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Storage.Streams.IBuffer, System.Int32, System.Int32, Windows.Graphics.DirectX.DirectXPixelFormat, System.Single)
    private func _n_CreateFromBytesWithBufferAndDpi(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ buffer : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ widthInPixels : INT32, _ heightInPixels : INT32, _ format : _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat, _ dpi : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromBytesWithBufferAndDpi(pThis, resourceCreator, buffer, widthInPixels, heightInPixels, format, dpi, __presult))
        }
    }
    public func CreateFromBytesWithBufferAndDpi(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, buffer : Optional<Windows.Storage.Streams.IBuffer>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, format : Windows.Graphics.DirectX.DirectXPixelFormat, dpi : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>> = nil;
        try self._n_CreateFromBytesWithBufferAndDpi(RawPointer(resourceCreator), RawPointer(buffer), widthInPixels, heightInPixels, format, dpi, &__result);
        return Microsoft.Graphics.Canvas.ICanvasBitmap(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasBitmap CreateFromBytes(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Storage.Streams.IBuffer, System.Int32, System.Int32, Windows.Graphics.DirectX.DirectXPixelFormat, System.Single, Microsoft.Graphics.Canvas.CanvasAlphaMode)
    private func _n_CreateFromBytesWithBufferAndDpiAndAlpha(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ buffer : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ widthInPixels : INT32, _ heightInPixels : INT32, _ format : _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat, _ dpi : FLOAT, _ alpha : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromBytesWithBufferAndDpiAndAlpha(pThis, resourceCreator, buffer, widthInPixels, heightInPixels, format, dpi, alpha, __presult))
        }
    }
    public func CreateFromBytesWithBufferAndDpiAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, buffer : Optional<Windows.Storage.Streams.IBuffer>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, format : Windows.Graphics.DirectX.DirectXPixelFormat, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>> = nil;
        try self._n_CreateFromBytesWithBufferAndDpiAndAlpha(RawPointer(resourceCreator), RawPointer(buffer), widthInPixels, heightInPixels, format, dpi, alpha, &__result);
        return Microsoft.Graphics.Canvas.ICanvasBitmap(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasBitmap CreateFromColors(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.UI.Color[], System.Int32, System.Int32)
    private func _n_CreateFromColors(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ colorsLength : UINT32, _ colors : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>, _ widthInPixels : INT32, _ heightInPixels : INT32, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromColors(pThis, resourceCreator, colorsLength, colors, widthInPixels, heightInPixels, __presult))
        }
    }
    public func CreateFromColors(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, colorsLength : UINT32, colors : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>> = nil;
        try self._n_CreateFromColors(RawPointer(resourceCreator), colorsLength, colors, widthInPixels, heightInPixels, &__result);
        return Microsoft.Graphics.Canvas.ICanvasBitmap(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasBitmap CreateFromColors(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.UI.Color[], System.Int32, System.Int32, System.Single)
    private func _n_CreateFromColorsWithDpi(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ colorsLength : UINT32, _ colors : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>, _ widthInPixels : INT32, _ heightInPixels : INT32, _ dpi : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromColorsWithDpi(pThis, resourceCreator, colorsLength, colors, widthInPixels, heightInPixels, dpi, __presult))
        }
    }
    public func CreateFromColorsWithDpi(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, colorsLength : UINT32, colors : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, dpi : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>> = nil;
        try self._n_CreateFromColorsWithDpi(RawPointer(resourceCreator), colorsLength, colors, widthInPixels, heightInPixels, dpi, &__result);
        return Microsoft.Graphics.Canvas.ICanvasBitmap(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasBitmap CreateFromColors(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.UI.Color[], System.Int32, System.Int32, System.Single, Microsoft.Graphics.Canvas.CanvasAlphaMode)
    private func _n_CreateFromColorsWithDpiAndAlpha(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ colorsLength : UINT32, _ colors : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>, _ widthInPixels : INT32, _ heightInPixels : INT32, _ dpi : FLOAT, _ alpha : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromColorsWithDpiAndAlpha(pThis, resourceCreator, colorsLength, colors, widthInPixels, heightInPixels, dpi, alpha, __presult))
        }
    }
    public func CreateFromColorsWithDpiAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, colorsLength : UINT32, colors : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CColor>>, widthInPixels : Swift.Int32, heightInPixels : Swift.Int32, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>> = nil;
        try self._n_CreateFromColorsWithDpiAndAlpha(RawPointer(resourceCreator), colorsLength, colors, widthInPixels, heightInPixels, dpi, alpha, &__result);
        return Microsoft.Graphics.Canvas.ICanvasBitmap(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasBitmap CreateFromSoftwareBitmap(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Graphics.Imaging.SoftwareBitmap)
    private func _n_CreateFromSoftwareBitmap(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ sourceBitmap : Optional<UnsafeMutablePointer<_q_CWindows_CGraphics_CImaging_CISoftwareBitmap>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromSoftwareBitmap(pThis, resourceCreator, sourceBitmap, __presult))
        }
    }
    public func CreateFromSoftwareBitmap(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, sourceBitmap : Optional<Windows.Graphics.Imaging.ISoftwareBitmap>) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>> = nil;
        try self._n_CreateFromSoftwareBitmap(RawPointer(resourceCreator), RawPointer(sourceBitmap), &__result);
        return Microsoft.Graphics.Canvas.ICanvasBitmap(consuming: __result);
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.String)
    private func _n_LoadAsyncFromHstring(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ fileName : Optional<HSTRING>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromHstring(pThis, resourceCreator, fileName, __presult))
        }
    }
    public func LoadAsyncFromHstring(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Optional<Swift.String>) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        let __hstr_fileName = try HString(fileName!);
        return try withExtendedLifetime(__hstr_fileName) {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>> = nil;
        try self._n_LoadAsyncFromHstring(RawPointer(resourceCreator), __hstr_fileName.Raw(), &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap(consuming: __result);
        }
    }
    public func LoadAsyncFromHstring(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Optional<Swift.String>) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromHstring(resourceCreator: resourceCreator, fileName: fileName)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.String, System.Single)
    private func _n_LoadAsyncFromHstringWithDpi(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ fileName : Optional<HSTRING>, _ dpi : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromHstringWithDpi(pThis, resourceCreator, fileName, dpi, __presult))
        }
    }
    public func LoadAsyncFromHstringWithDpi(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Optional<Swift.String>, dpi : Swift.Float) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        let __hstr_fileName = try HString(fileName!);
        return try withExtendedLifetime(__hstr_fileName) {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>> = nil;
        try self._n_LoadAsyncFromHstringWithDpi(RawPointer(resourceCreator), __hstr_fileName.Raw(), dpi, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap(consuming: __result);
        }
    }
    public func LoadAsyncFromHstringWithDpi(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Optional<Swift.String>, dpi : Swift.Float) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromHstringWithDpi(resourceCreator: resourceCreator, fileName: fileName, dpi: dpi)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.String, System.Single, Microsoft.Graphics.Canvas.CanvasAlphaMode)
    private func _n_LoadAsyncFromHstringWithDpiAndAlpha(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ fileName : Optional<HSTRING>, _ dpi : FLOAT, _ alpha : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromHstringWithDpiAndAlpha(pThis, resourceCreator, fileName, dpi, alpha, __presult))
        }
    }
    public func LoadAsyncFromHstringWithDpiAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Optional<Swift.String>, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        let __hstr_fileName = try HString(fileName!);
        return try withExtendedLifetime(__hstr_fileName) {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>> = nil;
        try self._n_LoadAsyncFromHstringWithDpiAndAlpha(RawPointer(resourceCreator), __hstr_fileName.Raw(), dpi, alpha, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap(consuming: __result);
        }
    }
    public func LoadAsyncFromHstringWithDpiAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Optional<Swift.String>, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromHstringWithDpiAndAlpha(resourceCreator: resourceCreator, fileName: fileName, dpi: dpi, alpha: alpha)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Uri)
    private func _n_LoadAsyncFromUri(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ uri : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIUriRuntimeClass>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromUri(pThis, resourceCreator, uri, __presult))
        }
    }
    public func LoadAsyncFromUri(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.IUriRuntimeClass>) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>> = nil;
        try self._n_LoadAsyncFromUri(RawPointer(resourceCreator), RawPointer(uri), &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap(consuming: __result);
    }
    public func LoadAsyncFromUri(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.IUriRuntimeClass>) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromUri(resourceCreator: resourceCreator, uri: uri)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Uri, System.Single)
    private func _n_LoadAsyncFromUriWithDpi(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ uri : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIUriRuntimeClass>>, _ dpi : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromUriWithDpi(pThis, resourceCreator, uri, dpi, __presult))
        }
    }
    public func LoadAsyncFromUriWithDpi(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.IUriRuntimeClass>, dpi : Swift.Float) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>> = nil;
        try self._n_LoadAsyncFromUriWithDpi(RawPointer(resourceCreator), RawPointer(uri), dpi, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap(consuming: __result);
    }
    public func LoadAsyncFromUriWithDpi(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.IUriRuntimeClass>, dpi : Swift.Float) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromUriWithDpi(resourceCreator: resourceCreator, uri: uri, dpi: dpi)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Uri, System.Single, Microsoft.Graphics.Canvas.CanvasAlphaMode)
    private func _n_LoadAsyncFromUriWithDpiAndAlpha(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ uri : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIUriRuntimeClass>>, _ dpi : FLOAT, _ alpha : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromUriWithDpiAndAlpha(pThis, resourceCreator, uri, dpi, alpha, __presult))
        }
    }
    public func LoadAsyncFromUriWithDpiAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.IUriRuntimeClass>, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>> = nil;
        try self._n_LoadAsyncFromUriWithDpiAndAlpha(RawPointer(resourceCreator), RawPointer(uri), dpi, alpha, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap(consuming: __result);
    }
    public func LoadAsyncFromUriWithDpiAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.IUriRuntimeClass>, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromUriWithDpiAndAlpha(resourceCreator: resourceCreator, uri: uri, dpi: dpi, alpha: alpha)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Storage.Streams.IRandomAccessStream)
    private func _n_LoadAsyncFromStream(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ stream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIRandomAccessStream>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromStream(pThis, resourceCreator, stream, __presult))
        }
    }
    public func LoadAsyncFromStream(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>> = nil;
        try self._n_LoadAsyncFromStream(RawPointer(resourceCreator), RawPointer(stream), &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap(consuming: __result);
    }
    public func LoadAsyncFromStream(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromStream(resourceCreator: resourceCreator, stream: stream)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Storage.Streams.IRandomAccessStream, System.Single)
    private func _n_LoadAsyncFromStreamWithDpi(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ stream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIRandomAccessStream>>, _ dpi : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromStreamWithDpi(pThis, resourceCreator, stream, dpi, __presult))
        }
    }
    public func LoadAsyncFromStreamWithDpi(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, dpi : Swift.Float) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>> = nil;
        try self._n_LoadAsyncFromStreamWithDpi(RawPointer(resourceCreator), RawPointer(stream), dpi, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap(consuming: __result);
    }
    public func LoadAsyncFromStreamWithDpi(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, dpi : Swift.Float) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromStreamWithDpi(resourceCreator: resourceCreator, stream: stream, dpi: dpi)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Storage.Streams.IRandomAccessStream, System.Single, Microsoft.Graphics.Canvas.CanvasAlphaMode)
    private func _n_LoadAsyncFromStreamWithDpiAndAlpha(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ stream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIRandomAccessStream>>, _ dpi : FLOAT, _ alpha : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromStreamWithDpiAndAlpha(pThis, resourceCreator, stream, dpi, alpha, __presult))
        }
    }
    public func LoadAsyncFromStreamWithDpiAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap>> = nil;
        try self._n_LoadAsyncFromStreamWithDpiAndAlpha(RawPointer(resourceCreator), RawPointer(stream), dpi, alpha, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmap(consuming: __result);
    }
    public func LoadAsyncFromStreamWithDpiAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, dpi : Swift.Float, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromStreamWithDpiAndAlpha(resourceCreator: resourceCreator, stream: stream, dpi: dpi, alpha: alpha)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
} // ICanvasBitmapStatics


// type: Microsoft.Graphics.Canvas.ICanvasCommandList
// interface type
open class ICanvasCommandList
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xb71e73cf, Data2: 0x2fe7, Data3 : 0x4d3a, Data4 : (0xbb, 0xb8, 0x19, 0xf0, 0x16, 0xf5, 0xbe, 0x1b)) }
    // Microsoft.Graphics.Canvas.CanvasDrawingSession CreateDrawingSession()
    private func _n_CreateDrawingSession(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasCommandList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateDrawingSession(pThis, __presult))
        }
    }
    public func CreateDrawingSession() throws -> Optional<Microsoft.Graphics.Canvas.ICanvasDrawingSession> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession>> = nil;
        try self._n_CreateDrawingSession(&__result);
        return Microsoft.Graphics.Canvas.ICanvasDrawingSession(consuming: __result);
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.CanvasDevice get_Device()
    private func _n_get_Device(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasCommandList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Device(pThis, __presult))
        }
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>> = nil;
        try self._n_get_Device(&__result);
        return Microsoft.Graphics.Canvas.ICanvasDevice(consuming: __result);
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        get throws {
            return try get_Device();
        }
    }
} // ICanvasCommandList


// type: Microsoft.Graphics.Canvas.ICanvasCommandListFactory
// interface type
// ACTIVATION INTERFACE
open class ICanvasCommandListFactory
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xb3d44e68, Data2: 0xd931, Data3 : 0x4b5b, Data4 : (0xb9, 0x57, 0x08, 0x88, 0x98, 0x0a, 0x7d, 0x50)) }
    // Microsoft.Graphics.Canvas.CanvasCommandList Create(Microsoft.Graphics.Canvas.ICanvasResourceCreator)
    private func _n_Create(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasCommandList>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasCommandListFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Create(pThis, resourceCreator, __presult))
        }
    }
    public func Create(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasCommandList> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasCommandList>> = nil;
        try self._n_Create(RawPointer(resourceCreator), &__result);
        return Microsoft.Graphics.Canvas.ICanvasCommandList(consuming: __result);
    }
} // ICanvasCommandListFactory


// type: Microsoft.Graphics.Canvas.ICanvasDevice
// interface type
open class ICanvasDevice
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xa27f0b5d, Data2: 0xec2c, Data3 : 0x4d4f, Data4 : (0x94, 0x8f, 0x0a, 0xa1, 0xe9, 0x5e, 0x33, 0xe6)) }
    // [IsSpecialName] bool get_ForceSoftwareRenderer()
    private func _n_get_ForceSoftwareRenderer(_ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_ForceSoftwareRenderer(pThis, __presult))
        }
    }
    public func get_ForceSoftwareRenderer() throws -> boolean {
        var __result : boolean = 0;
        try self._n_get_ForceSoftwareRenderer(&__result);
        return __result;
    }
    // [IsSpecialName] System.Int32 get_MaximumBitmapSizeInPixels()
    private func _n_get_MaximumBitmapSizeInPixels(_ __presult: UnsafeMutablePointer<INT32>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_MaximumBitmapSizeInPixels(pThis, __presult))
        }
    }
    public func get_MaximumBitmapSizeInPixels() throws -> Swift.Int32 {
        var __result : INT32 = 0;
        try self._n_get_MaximumBitmapSizeInPixels(&__result);
        return __result;
    }
    // bool IsPixelFormatSupported(Windows.Graphics.DirectX.DirectXPixelFormat)
    private func _n_IsPixelFormatSupported(_ pixelFormat : _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat, _ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IsPixelFormatSupported(pThis, pixelFormat, __presult))
        }
    }
    public func IsPixelFormatSupported(pixelFormat : Windows.Graphics.DirectX.DirectXPixelFormat) throws -> boolean {
        var __result : boolean = 0;
        try self._n_IsPixelFormatSupported(pixelFormat, &__result);
        return __result;
    }
    // bool IsBufferPrecisionSupported(Microsoft.Graphics.Canvas.CanvasBufferPrecision)
    private func _n_IsBufferPrecisionSupported(_ bufferPrecision : _q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision, _ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IsBufferPrecisionSupported(pThis, bufferPrecision, __presult))
        }
    }
    public func IsBufferPrecisionSupported(bufferPrecision : Microsoft.Graphics.Canvas.CanvasBufferPrecision) throws -> boolean {
        var __result : boolean = 0;
        try self._n_IsBufferPrecisionSupported(bufferPrecision, &__result);
        return __result;
    }
    // [IsSpecialName] System.UInt64 get_MaximumCacheSize()
    private func _n_get_MaximumCacheSize(_ __presult: UnsafeMutablePointer<UINT64>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_MaximumCacheSize(pThis, __presult))
        }
    }
    public func get_MaximumCacheSize() throws -> Swift.UInt64 {
        var __result : UINT64 = 0;
        try self._n_get_MaximumCacheSize(&__result);
        return __result;
    }
    // [IsSpecialName] void put_MaximumCacheSize(System.UInt64)
    private func _n_put_MaximumCacheSize(_ value : UINT64) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_MaximumCacheSize(pThis, value))
        }
    }
    public func put_MaximumCacheSize(value : Swift.UInt64) throws -> Void {
        try self._n_put_MaximumCacheSize(value);
    }
    // [IsSpecialName] bool get_LowPriority()
    private func _n_get_LowPriority(_ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_LowPriority(pThis, __presult))
        }
    }
    public func get_LowPriority() throws -> boolean {
        var __result : boolean = 0;
        try self._n_get_LowPriority(&__result);
        return __result;
    }
    // [IsSpecialName] void put_LowPriority(bool)
    private func _n_put_LowPriority(_ value : boolean) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_LowPriority(pThis, value))
        }
    }
    public func put_LowPriority(value : boolean) throws -> Void {
        try self._n_put_LowPriority(value);
    }
    // [IsSpecialName] Windows.Foundation.EventRegistrationToken add_DeviceLost(Windows.Foundation.TypedEventHandler<Microsoft.Graphics.Canvas.CanvasDevice,System.Object>)
    private func _n_add_DeviceLost(_ value : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_ITypedEventHandler_2__q_CMicrosoft_CGraphics_CCanvas_CCanvasDevice_IInspectable>>, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CEventRegistrationToken>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.add_DeviceLost(pThis, value, __presult))
        }
    }
    public func add_DeviceLost(value : Optional<ClosedGenerics.ITypedEventHandler_2__q_CMicrosoft_CGraphics_CCanvas_CCanvasDevice_IInspectable>) throws -> Windows.Foundation.EventRegistrationToken {
        var __result : _q_CWindows_CFoundation_CEventRegistrationToken = _q_CWindows_CFoundation_CEventRegistrationToken(Value: 0);
        try self._n_add_DeviceLost(RawPointer(value), &__result);
        return __result;
    }
    // [IsSpecialName] void remove_DeviceLost(Windows.Foundation.EventRegistrationToken)
    private func _n_remove_DeviceLost(_ token : _q_CWindows_CFoundation_CEventRegistrationToken) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.remove_DeviceLost(pThis, token))
        }
    }
    public func remove_DeviceLost(token : Windows.Foundation.EventRegistrationToken) throws -> Void {
        try self._n_remove_DeviceLost(token);
    }
    // bool IsDeviceLost(System.Int32)
    private func _n_IsDeviceLost(_ hresult : INT32, _ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IsDeviceLost(pThis, hresult, __presult))
        }
    }
    public func IsDeviceLost(hresult : Swift.Int32) throws -> boolean {
        var __result : boolean = 0;
        try self._n_IsDeviceLost(hresult, &__result);
        return __result;
    }
    // void RaiseDeviceLost()
    private func _n_RaiseDeviceLost() throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.RaiseDeviceLost(pThis))
        }
    }
    public func RaiseDeviceLost() throws -> Void {
        try self._n_RaiseDeviceLost();
    }
    // Microsoft.Graphics.Canvas.CanvasLock Lock()
    private func _n_Lock(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasLock>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Lock(pThis, __presult))
        }
    }
    public func Lock() throws -> Optional<Microsoft.Graphics.Canvas.ICanvasLock> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasLock>> = nil;
        try self._n_Lock(&__result);
        return Microsoft.Graphics.Canvas.ICanvasLock(consuming: __result);
    }
    public var ForceSoftwareRenderer : boolean {
        get throws {
            return try get_ForceSoftwareRenderer();
        }
    }
    public var LowPriority : boolean {
        get throws {
            return try get_LowPriority();
        }
    }
    public var MaximumBitmapSizeInPixels : Swift.Int32 {
        get throws {
            return try get_MaximumBitmapSizeInPixels();
        }
    }
    public var MaximumCacheSize : Swift.UInt64 {
        get throws {
            return try get_MaximumCacheSize();
        }
    }
} // ICanvasDevice


// type: Microsoft.Graphics.Canvas.ICanvasDeviceFactory
// interface type
// ACTIVATION INTERFACE
open class ICanvasDeviceFactory
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xe2c2bf21, Data2: 0x5418, Data3 : 0x43b9, Data4 : (0xa2, 0xda, 0x53, 0x9e, 0x28, 0x7c, 0x79, 0x0f)) }
    // Microsoft.Graphics.Canvas.CanvasDevice CreateWithForceSoftwareRendererOption(bool)
    private func _n_CreateWithForceSoftwareRendererOption(_ forceSoftwareRenderer : boolean, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDeviceFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateWithForceSoftwareRendererOption(pThis, forceSoftwareRenderer, __presult))
        }
    }
    public func CreateWithForceSoftwareRendererOption(forceSoftwareRenderer : boolean) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>> = nil;
        try self._n_CreateWithForceSoftwareRendererOption(forceSoftwareRenderer, &__result);
        return Microsoft.Graphics.Canvas.ICanvasDevice(consuming: __result);
    }
} // ICanvasDeviceFactory


// type: Microsoft.Graphics.Canvas.ICanvasDeviceStatics
// interface type
open class ICanvasDeviceStatics
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x9b6e2b27, Data2: 0xcd07, Data3 : 0x421a, Data4 : (0x8f, 0x69, 0x0a, 0xe8, 0xa7, 0x87, 0xfe, 0x8c)) }
    // Microsoft.Graphics.Canvas.CanvasDevice CreateFromDirect3D11Device(Windows.Graphics.DirectX.Direct3D11.IDirect3DDevice)
    private func _n_CreateFromDirect3D11Device(_ direct3DDevice : Optional<UnsafeMutablePointer<_q_CWindows_CGraphics_CDirectX_CDirect3D11_CIDirect3DDevice>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDeviceStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromDirect3D11Device(pThis, direct3DDevice, __presult))
        }
    }
    public func CreateFromDirect3D11Device(direct3DDevice : Optional<Windows.Graphics.DirectX.Direct3D11.IDirect3DDevice>) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>> = nil;
        try self._n_CreateFromDirect3D11Device(RawPointer(direct3DDevice), &__result);
        return Microsoft.Graphics.Canvas.ICanvasDevice(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasDevice GetSharedDevice()
    private func _n_GetSharedDevice(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDeviceStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetSharedDevice(pThis, __presult))
        }
    }
    public func GetSharedDevice() throws -> Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>> = nil;
        try self._n_GetSharedDevice(&__result);
        return Microsoft.Graphics.Canvas.ICanvasDevice(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasDevice GetSharedDevice(bool)
    private func _n_GetSharedDeviceWithForceSoftwareRenderer(_ forceSoftwareRenderer : boolean, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDeviceStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetSharedDeviceWithForceSoftwareRenderer(pThis, forceSoftwareRenderer, __presult))
        }
    }
    public func GetSharedDeviceWithForceSoftwareRenderer(forceSoftwareRenderer : boolean) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>> = nil;
        try self._n_GetSharedDeviceWithForceSoftwareRenderer(forceSoftwareRenderer, &__result);
        return Microsoft.Graphics.Canvas.ICanvasDevice(consuming: __result);
    }
    // [IsSpecialName] void put_DebugLevel(Microsoft.Graphics.Canvas.CanvasDebugLevel)
    private func _n_put_DebugLevel(_ value : _q_CMicrosoft_CGraphics_CCanvas_CCanvasDebugLevel) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDeviceStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_DebugLevel(pThis, value))
        }
    }
    public func put_DebugLevel(value : Microsoft.Graphics.Canvas.CanvasDebugLevel) throws -> Void {
        try self._n_put_DebugLevel(value);
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.CanvasDebugLevel get_DebugLevel()
    private func _n_get_DebugLevel(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CCanvasDebugLevel>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDeviceStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_DebugLevel(pThis, __presult))
        }
    }
    public func get_DebugLevel() throws -> Microsoft.Graphics.Canvas.CanvasDebugLevel {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CCanvasDebugLevel = _q_CMicrosoft_CGraphics_CCanvas_CCanvasDebugLevel_None;
        try self._n_get_DebugLevel(&__result);
        return __result;
    }
    public var DebugLevel : Microsoft.Graphics.Canvas.CanvasDebugLevel {
        get throws {
            return try get_DebugLevel();
        }
    }
} // ICanvasDeviceStatics


// type: Microsoft.Graphics.Canvas.ICanvasDrawingSession
// interface type
open class ICanvasDrawingSession
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xf60afd09, Data2: 0xe623, Data3 : 0x4be0, Data4 : (0xb7, 0x50, 0x57, 0x8a, 0xa9, 0x20, 0xb1, 0xdb)) }
    // void Clear(Windows.UI.Color)
    private func _n_Clear(_ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis, color))
        }
    }
    public func Clear(color : Windows.UI.Color) throws -> Void {
        try self._n_Clear(color);
    }
    // void Clear(Windows.Foundation.Numerics.Vector4)
    private func _n_ClearHdr(_ color : _q_CWindows_CFoundation_CNumerics_CVector4) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ClearHdr(pThis, color))
        }
    }
    public func ClearHdr(color : Windows.Foundation.Numerics.Vector4) throws -> Void {
        try self._n_ClearHdr(color);
    }
    // void Flush()
    private func _n_Flush() throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Flush(pThis))
        }
    }
    public func Flush() throws -> Void {
        try self._n_Flush();
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage)
    private func _n_DrawImageAtOrigin(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageAtOrigin(pThis, image))
        }
    }
    public func DrawImageAtOrigin(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>) throws -> Void {
        try self._n_DrawImageAtOrigin(RawPointer(image));
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, Windows.Foundation.Numerics.Vector2)
    private func _n_DrawImageAtOffset(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageAtOffset(pThis, image, offset))
        }
    }
    public func DrawImageAtOffset(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, offset : Windows.Foundation.Numerics.Vector2) throws -> Void {
        try self._n_DrawImageAtOffset(RawPointer(image), offset);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, System.Single, System.Single)
    private func _n_DrawImageAtCoords(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ x : FLOAT, _ y : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageAtCoords(pThis, image, x, y))
        }
    }
    public func DrawImageAtCoords(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, x : Swift.Float, y : Swift.Float) throws -> Void {
        try self._n_DrawImageAtCoords(RawPointer(image), x, y);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Rect)
    private func _n_DrawImageToRect(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ destinationRectangle : _q_CWindows_CFoundation_CRect) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageToRect(pThis, bitmap, destinationRectangle))
        }
    }
    public func DrawImageToRect(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, destinationRectangle : Windows.Foundation.Rect) throws -> Void {
        try self._n_DrawImageToRect(RawPointer(bitmap), destinationRectangle);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, Windows.Foundation.Numerics.Vector2, Windows.Foundation.Rect)
    private func _n_DrawImageAtOffsetWithSourceRect(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ sourceRectangle : _q_CWindows_CFoundation_CRect) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageAtOffsetWithSourceRect(pThis, image, offset, sourceRectangle))
        }
    }
    public func DrawImageAtOffsetWithSourceRect(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, offset : Windows.Foundation.Numerics.Vector2, sourceRectangle : Windows.Foundation.Rect) throws -> Void {
        try self._n_DrawImageAtOffsetWithSourceRect(RawPointer(image), offset, sourceRectangle);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, System.Single, System.Single, Windows.Foundation.Rect)
    private func _n_DrawImageAtCoordsWithSourceRect(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ x : FLOAT, _ y : FLOAT, _ sourceRectangle : _q_CWindows_CFoundation_CRect) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageAtCoordsWithSourceRect(pThis, image, x, y, sourceRectangle))
        }
    }
    public func DrawImageAtCoordsWithSourceRect(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, x : Swift.Float, y : Swift.Float, sourceRectangle : Windows.Foundation.Rect) throws -> Void {
        try self._n_DrawImageAtCoordsWithSourceRect(RawPointer(image), x, y, sourceRectangle);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, Windows.Foundation.Rect, Windows.Foundation.Rect)
    private func _n_DrawImageToRectWithSourceRect(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ destinationRectangle : _q_CWindows_CFoundation_CRect, _ sourceRectangle : _q_CWindows_CFoundation_CRect) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageToRectWithSourceRect(pThis, image, destinationRectangle, sourceRectangle))
        }
    }
    public func DrawImageToRectWithSourceRect(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, destinationRectangle : Windows.Foundation.Rect, sourceRectangle : Windows.Foundation.Rect) throws -> Void {
        try self._n_DrawImageToRectWithSourceRect(RawPointer(image), destinationRectangle, sourceRectangle);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, Windows.Foundation.Numerics.Vector2, Windows.Foundation.Rect, System.Single)
    private func _n_DrawImageAtOffsetWithSourceRectAndOpacity(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ opacity : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageAtOffsetWithSourceRectAndOpacity(pThis, image, offset, sourceRectangle, opacity))
        }
    }
    public func DrawImageAtOffsetWithSourceRectAndOpacity(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, offset : Windows.Foundation.Numerics.Vector2, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float) throws -> Void {
        try self._n_DrawImageAtOffsetWithSourceRectAndOpacity(RawPointer(image), offset, sourceRectangle, opacity);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, System.Single, System.Single, Windows.Foundation.Rect, System.Single)
    private func _n_DrawImageAtCoordsWithSourceRectAndOpacity(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ x : FLOAT, _ y : FLOAT, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ opacity : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageAtCoordsWithSourceRectAndOpacity(pThis, image, x, y, sourceRectangle, opacity))
        }
    }
    public func DrawImageAtCoordsWithSourceRectAndOpacity(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, x : Swift.Float, y : Swift.Float, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float) throws -> Void {
        try self._n_DrawImageAtCoordsWithSourceRectAndOpacity(RawPointer(image), x, y, sourceRectangle, opacity);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, Windows.Foundation.Rect, Windows.Foundation.Rect, System.Single)
    private func _n_DrawImageToRectWithSourceRectAndOpacity(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ destinationRectangle : _q_CWindows_CFoundation_CRect, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ opacity : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageToRectWithSourceRectAndOpacity(pThis, image, destinationRectangle, sourceRectangle, opacity))
        }
    }
    public func DrawImageToRectWithSourceRectAndOpacity(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, destinationRectangle : Windows.Foundation.Rect, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float) throws -> Void {
        try self._n_DrawImageToRectWithSourceRectAndOpacity(RawPointer(image), destinationRectangle, sourceRectangle, opacity);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, Windows.Foundation.Numerics.Vector2, Windows.Foundation.Rect, System.Single, Microsoft.Graphics.Canvas.CanvasImageInterpolation)
    private func _n_DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolation(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ opacity : FLOAT, _ interpolation : _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolation(pThis, image, offset, sourceRectangle, opacity, interpolation))
        }
    }
    public func DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolation(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, offset : Windows.Foundation.Numerics.Vector2, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation) throws -> Void {
        try self._n_DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolation(RawPointer(image), offset, sourceRectangle, opacity, interpolation);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, System.Single, System.Single, Windows.Foundation.Rect, System.Single, Microsoft.Graphics.Canvas.CanvasImageInterpolation)
    private func _n_DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolation(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ x : FLOAT, _ y : FLOAT, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ opacity : FLOAT, _ interpolation : _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolation(pThis, image, x, y, sourceRectangle, opacity, interpolation))
        }
    }
    public func DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolation(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, x : Swift.Float, y : Swift.Float, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation) throws -> Void {
        try self._n_DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolation(RawPointer(image), x, y, sourceRectangle, opacity, interpolation);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, Windows.Foundation.Rect, Windows.Foundation.Rect, System.Single, Microsoft.Graphics.Canvas.CanvasImageInterpolation)
    private func _n_DrawImageToRectWithSourceRectAndOpacityAndInterpolation(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ destinationRectangle : _q_CWindows_CFoundation_CRect, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ opacity : FLOAT, _ interpolation : _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageToRectWithSourceRectAndOpacityAndInterpolation(pThis, image, destinationRectangle, sourceRectangle, opacity, interpolation))
        }
    }
    public func DrawImageToRectWithSourceRectAndOpacityAndInterpolation(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, destinationRectangle : Windows.Foundation.Rect, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation) throws -> Void {
        try self._n_DrawImageToRectWithSourceRectAndOpacityAndInterpolation(RawPointer(image), destinationRectangle, sourceRectangle, opacity, interpolation);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, Windows.Foundation.Numerics.Vector2, Windows.Foundation.Rect, System.Single, Microsoft.Graphics.Canvas.CanvasImageInterpolation, Microsoft.Graphics.Canvas.CanvasComposite)
    private func _n_DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndComposite(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ opacity : FLOAT, _ interpolation : _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation, _ composite : _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndComposite(pThis, image, offset, sourceRectangle, opacity, interpolation, composite))
        }
    }
    public func DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndComposite(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, offset : Windows.Foundation.Numerics.Vector2, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, composite : Microsoft.Graphics.Canvas.CanvasComposite) throws -> Void {
        try self._n_DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndComposite(RawPointer(image), offset, sourceRectangle, opacity, interpolation, composite);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, System.Single, System.Single, Windows.Foundation.Rect, System.Single, Microsoft.Graphics.Canvas.CanvasImageInterpolation, Microsoft.Graphics.Canvas.CanvasComposite)
    private func _n_DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndComposite(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ x : FLOAT, _ y : FLOAT, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ opacity : FLOAT, _ interpolation : _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation, _ composite : _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndComposite(pThis, image, x, y, sourceRectangle, opacity, interpolation, composite))
        }
    }
    public func DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndComposite(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, x : Swift.Float, y : Swift.Float, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, composite : Microsoft.Graphics.Canvas.CanvasComposite) throws -> Void {
        try self._n_DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndComposite(RawPointer(image), x, y, sourceRectangle, opacity, interpolation, composite);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.ICanvasImage, Windows.Foundation.Rect, Windows.Foundation.Rect, System.Single, Microsoft.Graphics.Canvas.CanvasImageInterpolation, Microsoft.Graphics.Canvas.CanvasComposite)
    private func _n_DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndComposite(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ destinationRectangle : _q_CWindows_CFoundation_CRect, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ opacity : FLOAT, _ interpolation : _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation, _ composite : _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndComposite(pThis, image, destinationRectangle, sourceRectangle, opacity, interpolation, composite))
        }
    }
    public func DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndComposite(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, destinationRectangle : Windows.Foundation.Rect, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, composite : Microsoft.Graphics.Canvas.CanvasComposite) throws -> Void {
        try self._n_DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndComposite(RawPointer(image), destinationRectangle, sourceRectangle, opacity, interpolation, composite);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Numerics.Vector2, Windows.Foundation.Rect, System.Single, Microsoft.Graphics.Canvas.CanvasImageInterpolation, Windows.Foundation.Numerics.Matrix4x4)
    private func _n_DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndPerspective(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ opacity : FLOAT, _ interpolation : _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation, _ perspective : _q_CWindows_CFoundation_CNumerics_CMatrix4x4) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndPerspective(pThis, bitmap, offset, sourceRectangle, opacity, interpolation, perspective))
        }
    }
    public func DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndPerspective(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, perspective : Windows.Foundation.Numerics.Matrix4x4) throws -> Void {
        try self._n_DrawImageAtOffsetWithSourceRectAndOpacityAndInterpolationAndPerspective(RawPointer(bitmap), offset, sourceRectangle, opacity, interpolation, perspective);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.CanvasBitmap, System.Single, System.Single, Windows.Foundation.Rect, System.Single, Microsoft.Graphics.Canvas.CanvasImageInterpolation, Windows.Foundation.Numerics.Matrix4x4)
    private func _n_DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndPerspective(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ x : FLOAT, _ y : FLOAT, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ opacity : FLOAT, _ interpolation : _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation, _ perspective : _q_CWindows_CFoundation_CNumerics_CMatrix4x4) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndPerspective(pThis, bitmap, x, y, sourceRectangle, opacity, interpolation, perspective))
        }
    }
    public func DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndPerspective(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, x : Swift.Float, y : Swift.Float, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, perspective : Windows.Foundation.Numerics.Matrix4x4) throws -> Void {
        try self._n_DrawImageAtCoordsWithSourceRectAndOpacityAndInterpolationAndPerspective(RawPointer(bitmap), x, y, sourceRectangle, opacity, interpolation, perspective);
    }
    // void DrawImage(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Rect, Windows.Foundation.Rect, System.Single, Microsoft.Graphics.Canvas.CanvasImageInterpolation, Windows.Foundation.Numerics.Matrix4x4)
    private func _n_DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndPerspective(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ destinationRectangle : _q_CWindows_CFoundation_CRect, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ opacity : FLOAT, _ interpolation : _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation, _ perspective : _q_CWindows_CFoundation_CNumerics_CMatrix4x4) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndPerspective(pThis, bitmap, destinationRectangle, sourceRectangle, opacity, interpolation, perspective))
        }
    }
    public func DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndPerspective(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, destinationRectangle : Windows.Foundation.Rect, sourceRectangle : Windows.Foundation.Rect, opacity : Swift.Float, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, perspective : Windows.Foundation.Numerics.Matrix4x4) throws -> Void {
        try self._n_DrawImageToRectWithSourceRectAndOpacityAndInterpolationAndPerspective(RawPointer(bitmap), destinationRectangle, sourceRectangle, opacity, interpolation, perspective);
    }
    // void DrawLine(Windows.Foundation.Numerics.Vector2, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawLineWithBrush(_ point0 : _q_CWindows_CFoundation_CNumerics_CVector2, _ point1 : _q_CWindows_CFoundation_CNumerics_CVector2, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawLineWithBrush(pThis, point0, point1, brush))
        }
    }
    public func DrawLineWithBrush(point0 : Windows.Foundation.Numerics.Vector2, point1 : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawLineWithBrush(point0, point1, RawPointer(brush));
    }
    // void DrawLine(System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawLineAtCoordsWithBrush(_ x0 : FLOAT, _ y0 : FLOAT, _ x1 : FLOAT, _ y1 : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawLineAtCoordsWithBrush(pThis, x0, y0, x1, y1, brush))
        }
    }
    public func DrawLineAtCoordsWithBrush(x0 : Swift.Float, y0 : Swift.Float, x1 : Swift.Float, y1 : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawLineAtCoordsWithBrush(x0, y0, x1, y1, RawPointer(brush));
    }
    // void DrawLine(Windows.Foundation.Numerics.Vector2, Windows.Foundation.Numerics.Vector2, Windows.UI.Color)
    private func _n_DrawLineWithColor(_ point0 : _q_CWindows_CFoundation_CNumerics_CVector2, _ point1 : _q_CWindows_CFoundation_CNumerics_CVector2, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawLineWithColor(pThis, point0, point1, color))
        }
    }
    public func DrawLineWithColor(point0 : Windows.Foundation.Numerics.Vector2, point1 : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawLineWithColor(point0, point1, color);
    }
    // void DrawLine(System.Single, System.Single, System.Single, System.Single, Windows.UI.Color)
    private func _n_DrawLineAtCoordsWithColor(_ x0 : FLOAT, _ y0 : FLOAT, _ x1 : FLOAT, _ y1 : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawLineAtCoordsWithColor(pThis, x0, y0, x1, y1, color))
        }
    }
    public func DrawLineAtCoordsWithColor(x0 : Swift.Float, y0 : Swift.Float, x1 : Swift.Float, y1 : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawLineAtCoordsWithColor(x0, y0, x1, y1, color);
    }
    // void DrawLine(Windows.Foundation.Numerics.Vector2, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single)
    private func _n_DrawLineWithBrushAndStrokeWidth(_ point0 : _q_CWindows_CFoundation_CNumerics_CVector2, _ point1 : _q_CWindows_CFoundation_CNumerics_CVector2, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawLineWithBrushAndStrokeWidth(pThis, point0, point1, brush, strokeWidth))
        }
    }
    public func DrawLineWithBrushAndStrokeWidth(point0 : Windows.Foundation.Numerics.Vector2, point1 : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawLineWithBrushAndStrokeWidth(point0, point1, RawPointer(brush), strokeWidth);
    }
    // void DrawLine(System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single)
    private func _n_DrawLineAtCoordsWithBrushAndStrokeWidth(_ x0 : FLOAT, _ y0 : FLOAT, _ x1 : FLOAT, _ y1 : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawLineAtCoordsWithBrushAndStrokeWidth(pThis, x0, y0, x1, y1, brush, strokeWidth))
        }
    }
    public func DrawLineAtCoordsWithBrushAndStrokeWidth(x0 : Swift.Float, y0 : Swift.Float, x1 : Swift.Float, y1 : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawLineAtCoordsWithBrushAndStrokeWidth(x0, y0, x1, y1, RawPointer(brush), strokeWidth);
    }
    // void DrawLine(Windows.Foundation.Numerics.Vector2, Windows.Foundation.Numerics.Vector2, Windows.UI.Color, System.Single)
    private func _n_DrawLineWithColorAndStrokeWidth(_ point0 : _q_CWindows_CFoundation_CNumerics_CVector2, _ point1 : _q_CWindows_CFoundation_CNumerics_CVector2, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawLineWithColorAndStrokeWidth(pThis, point0, point1, color, strokeWidth))
        }
    }
    public func DrawLineWithColorAndStrokeWidth(point0 : Windows.Foundation.Numerics.Vector2, point1 : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawLineWithColorAndStrokeWidth(point0, point1, color, strokeWidth);
    }
    // void DrawLine(System.Single, System.Single, System.Single, System.Single, Windows.UI.Color, System.Single)
    private func _n_DrawLineAtCoordsWithColorAndStrokeWidth(_ x0 : FLOAT, _ y0 : FLOAT, _ x1 : FLOAT, _ y1 : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawLineAtCoordsWithColorAndStrokeWidth(pThis, x0, y0, x1, y1, color, strokeWidth))
        }
    }
    public func DrawLineAtCoordsWithColorAndStrokeWidth(x0 : Swift.Float, y0 : Swift.Float, x1 : Swift.Float, y1 : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawLineAtCoordsWithColorAndStrokeWidth(x0, y0, x1, y1, color, strokeWidth);
    }
    // void DrawLine(Windows.Foundation.Numerics.Vector2, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawLineWithBrushAndStrokeWidthAndStrokeStyle(_ point0 : _q_CWindows_CFoundation_CNumerics_CVector2, _ point1 : _q_CWindows_CFoundation_CNumerics_CVector2, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawLineWithBrushAndStrokeWidthAndStrokeStyle(pThis, point0, point1, brush, strokeWidth, strokeStyle))
        }
    }
    public func DrawLineWithBrushAndStrokeWidthAndStrokeStyle(point0 : Windows.Foundation.Numerics.Vector2, point1 : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawLineWithBrushAndStrokeWidthAndStrokeStyle(point0, point1, RawPointer(brush), strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawLine(System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawLineAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(_ x0 : FLOAT, _ y0 : FLOAT, _ x1 : FLOAT, _ y1 : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawLineAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(pThis, x0, y0, x1, y1, brush, strokeWidth, strokeStyle))
        }
    }
    public func DrawLineAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x0 : Swift.Float, y0 : Swift.Float, x1 : Swift.Float, y1 : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawLineAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x0, y0, x1, y1, RawPointer(brush), strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawLine(Windows.Foundation.Numerics.Vector2, Windows.Foundation.Numerics.Vector2, Windows.UI.Color, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawLineWithColorAndStrokeWidthAndStrokeStyle(_ point0 : _q_CWindows_CFoundation_CNumerics_CVector2, _ point1 : _q_CWindows_CFoundation_CNumerics_CVector2, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawLineWithColorAndStrokeWidthAndStrokeStyle(pThis, point0, point1, color, strokeWidth, strokeStyle))
        }
    }
    public func DrawLineWithColorAndStrokeWidthAndStrokeStyle(point0 : Windows.Foundation.Numerics.Vector2, point1 : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawLineWithColorAndStrokeWidthAndStrokeStyle(point0, point1, color, strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawLine(System.Single, System.Single, System.Single, System.Single, Windows.UI.Color, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawLineAtCoordsWithColorAndStrokeWidthAndStrokeStyle(_ x0 : FLOAT, _ y0 : FLOAT, _ x1 : FLOAT, _ y1 : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawLineAtCoordsWithColorAndStrokeWidthAndStrokeStyle(pThis, x0, y0, x1, y1, color, strokeWidth, strokeStyle))
        }
    }
    public func DrawLineAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x0 : Swift.Float, y0 : Swift.Float, x1 : Swift.Float, y1 : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawLineAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x0, y0, x1, y1, color, strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawRectangle(Windows.Foundation.Rect, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawRectangleWithBrush(_ rect : _q_CWindows_CFoundation_CRect, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRectangleWithBrush(pThis, rect, brush))
        }
    }
    public func DrawRectangleWithBrush(rect : Windows.Foundation.Rect, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawRectangleWithBrush(rect, RawPointer(brush));
    }
    // void DrawRectangle(System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawRectangleAtCoordsWithBrush(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRectangleAtCoordsWithBrush(pThis, x, y, w, h, brush))
        }
    }
    public func DrawRectangleAtCoordsWithBrush(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawRectangleAtCoordsWithBrush(x, y, w, h, RawPointer(brush));
    }
    // void DrawRectangle(Windows.Foundation.Rect, Windows.UI.Color)
    private func _n_DrawRectangleWithColor(_ rect : _q_CWindows_CFoundation_CRect, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRectangleWithColor(pThis, rect, color))
        }
    }
    public func DrawRectangleWithColor(rect : Windows.Foundation.Rect, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawRectangleWithColor(rect, color);
    }
    // void DrawRectangle(System.Single, System.Single, System.Single, System.Single, Windows.UI.Color)
    private func _n_DrawRectangleAtCoordsWithColor(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRectangleAtCoordsWithColor(pThis, x, y, w, h, color))
        }
    }
    public func DrawRectangleAtCoordsWithColor(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawRectangleAtCoordsWithColor(x, y, w, h, color);
    }
    // void DrawRectangle(Windows.Foundation.Rect, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single)
    private func _n_DrawRectangleWithBrushAndStrokeWidth(_ rect : _q_CWindows_CFoundation_CRect, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRectangleWithBrushAndStrokeWidth(pThis, rect, brush, strokeWidth))
        }
    }
    public func DrawRectangleWithBrushAndStrokeWidth(rect : Windows.Foundation.Rect, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawRectangleWithBrushAndStrokeWidth(rect, RawPointer(brush), strokeWidth);
    }
    // void DrawRectangle(System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single)
    private func _n_DrawRectangleAtCoordsWithBrushAndStrokeWidth(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRectangleAtCoordsWithBrushAndStrokeWidth(pThis, x, y, w, h, brush, strokeWidth))
        }
    }
    public func DrawRectangleAtCoordsWithBrushAndStrokeWidth(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawRectangleAtCoordsWithBrushAndStrokeWidth(x, y, w, h, RawPointer(brush), strokeWidth);
    }
    // void DrawRectangle(Windows.Foundation.Rect, Windows.UI.Color, System.Single)
    private func _n_DrawRectangleWithColorAndStrokeWidth(_ rect : _q_CWindows_CFoundation_CRect, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRectangleWithColorAndStrokeWidth(pThis, rect, color, strokeWidth))
        }
    }
    public func DrawRectangleWithColorAndStrokeWidth(rect : Windows.Foundation.Rect, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawRectangleWithColorAndStrokeWidth(rect, color, strokeWidth);
    }
    // void DrawRectangle(System.Single, System.Single, System.Single, System.Single, Windows.UI.Color, System.Single)
    private func _n_DrawRectangleAtCoordsWithColorAndStrokeWidth(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRectangleAtCoordsWithColorAndStrokeWidth(pThis, x, y, w, h, color, strokeWidth))
        }
    }
    public func DrawRectangleAtCoordsWithColorAndStrokeWidth(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawRectangleAtCoordsWithColorAndStrokeWidth(x, y, w, h, color, strokeWidth);
    }
    // void DrawRectangle(Windows.Foundation.Rect, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawRectangleWithBrushAndStrokeWidthAndStrokeStyle(_ rect : _q_CWindows_CFoundation_CRect, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRectangleWithBrushAndStrokeWidthAndStrokeStyle(pThis, rect, brush, strokeWidth, strokeStyle))
        }
    }
    public func DrawRectangleWithBrushAndStrokeWidthAndStrokeStyle(rect : Windows.Foundation.Rect, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawRectangleWithBrushAndStrokeWidthAndStrokeStyle(rect, RawPointer(brush), strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawRectangle(System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(pThis, x, y, w, h, brush, strokeWidth, strokeStyle))
        }
    }
    public func DrawRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x, y, w, h, RawPointer(brush), strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawRectangle(Windows.Foundation.Rect, Windows.UI.Color, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawRectangleWithColorAndStrokeWidthAndStrokeStyle(_ rect : _q_CWindows_CFoundation_CRect, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRectangleWithColorAndStrokeWidthAndStrokeStyle(pThis, rect, color, strokeWidth, strokeStyle))
        }
    }
    public func DrawRectangleWithColorAndStrokeWidthAndStrokeStyle(rect : Windows.Foundation.Rect, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawRectangleWithColorAndStrokeWidthAndStrokeStyle(rect, color, strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawRectangle(System.Single, System.Single, System.Single, System.Single, Windows.UI.Color, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(pThis, x, y, w, h, color, strokeWidth, strokeStyle))
        }
    }
    public func DrawRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x, y, w, h, color, strokeWidth, RawPointer(strokeStyle));
    }
    // void FillRectangle(Windows.Foundation.Rect, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillRectangleWithBrush(_ rect : _q_CWindows_CFoundation_CRect, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillRectangleWithBrush(pThis, rect, brush))
        }
    }
    public func FillRectangleWithBrush(rect : Windows.Foundation.Rect, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillRectangleWithBrush(rect, RawPointer(brush));
    }
    // void FillRectangle(System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillRectangleAtCoordsWithBrush(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillRectangleAtCoordsWithBrush(pThis, x, y, w, h, brush))
        }
    }
    public func FillRectangleAtCoordsWithBrush(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillRectangleAtCoordsWithBrush(x, y, w, h, RawPointer(brush));
    }
    // void FillRectangle(Windows.Foundation.Rect, Windows.UI.Color)
    private func _n_FillRectangleWithColor(_ rect : _q_CWindows_CFoundation_CRect, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillRectangleWithColor(pThis, rect, color))
        }
    }
    public func FillRectangleWithColor(rect : Windows.Foundation.Rect, color : Windows.UI.Color) throws -> Void {
        try self._n_FillRectangleWithColor(rect, color);
    }
    // void FillRectangle(System.Single, System.Single, System.Single, System.Single, Windows.UI.Color)
    private func _n_FillRectangleAtCoordsWithColor(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillRectangleAtCoordsWithColor(pThis, x, y, w, h, color))
        }
    }
    public func FillRectangleAtCoordsWithColor(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_FillRectangleAtCoordsWithColor(x, y, w, h, color);
    }
    // void FillRectangle(Windows.Foundation.Rect, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillRectangleWithBrushAndOpacityBrush(_ rect : _q_CWindows_CFoundation_CRect, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ opacityBrush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillRectangleWithBrushAndOpacityBrush(pThis, rect, brush, opacityBrush))
        }
    }
    public func FillRectangleWithBrushAndOpacityBrush(rect : Windows.Foundation.Rect, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillRectangleWithBrushAndOpacityBrush(rect, RawPointer(brush), RawPointer(opacityBrush));
    }
    // void FillRectangle(System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillRectangleAtCoordsWithBrushAndOpacityBrush(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ opacityBrush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillRectangleAtCoordsWithBrushAndOpacityBrush(pThis, x, y, w, h, brush, opacityBrush))
        }
    }
    public func FillRectangleAtCoordsWithBrushAndOpacityBrush(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillRectangleAtCoordsWithBrushAndOpacityBrush(x, y, w, h, RawPointer(brush), RawPointer(opacityBrush));
    }
    // void DrawRoundedRectangle(Windows.Foundation.Rect, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawRoundedRectangleWithBrush(_ rect : _q_CWindows_CFoundation_CRect, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRoundedRectangleWithBrush(pThis, rect, radiusX, radiusY, brush))
        }
    }
    public func DrawRoundedRectangleWithBrush(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawRoundedRectangleWithBrush(rect, radiusX, radiusY, RawPointer(brush));
    }
    // void DrawRoundedRectangle(System.Single, System.Single, System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawRoundedRectangleAtCoordsWithBrush(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRoundedRectangleAtCoordsWithBrush(pThis, x, y, w, h, radiusX, radiusY, brush))
        }
    }
    public func DrawRoundedRectangleAtCoordsWithBrush(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawRoundedRectangleAtCoordsWithBrush(x, y, w, h, radiusX, radiusY, RawPointer(brush));
    }
    // void DrawRoundedRectangle(Windows.Foundation.Rect, System.Single, System.Single, Windows.UI.Color)
    private func _n_DrawRoundedRectangleWithColor(_ rect : _q_CWindows_CFoundation_CRect, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRoundedRectangleWithColor(pThis, rect, radiusX, radiusY, color))
        }
    }
    public func DrawRoundedRectangleWithColor(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawRoundedRectangleWithColor(rect, radiusX, radiusY, color);
    }
    // void DrawRoundedRectangle(System.Single, System.Single, System.Single, System.Single, System.Single, System.Single, Windows.UI.Color)
    private func _n_DrawRoundedRectangleAtCoordsWithColor(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRoundedRectangleAtCoordsWithColor(pThis, x, y, w, h, radiusX, radiusY, color))
        }
    }
    public func DrawRoundedRectangleAtCoordsWithColor(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawRoundedRectangleAtCoordsWithColor(x, y, w, h, radiusX, radiusY, color);
    }
    // void DrawRoundedRectangle(Windows.Foundation.Rect, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single)
    private func _n_DrawRoundedRectangleWithBrushAndStrokeWidth(_ rect : _q_CWindows_CFoundation_CRect, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRoundedRectangleWithBrushAndStrokeWidth(pThis, rect, radiusX, radiusY, brush, strokeWidth))
        }
    }
    public func DrawRoundedRectangleWithBrushAndStrokeWidth(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawRoundedRectangleWithBrushAndStrokeWidth(rect, radiusX, radiusY, RawPointer(brush), strokeWidth);
    }
    // void DrawRoundedRectangle(System.Single, System.Single, System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single)
    private func _n_DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidth(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidth(pThis, x, y, w, h, radiusX, radiusY, brush, strokeWidth))
        }
    }
    public func DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidth(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidth(x, y, w, h, radiusX, radiusY, RawPointer(brush), strokeWidth);
    }
    // void DrawRoundedRectangle(Windows.Foundation.Rect, System.Single, System.Single, Windows.UI.Color, System.Single)
    private func _n_DrawRoundedRectangleWithColorAndStrokeWidth(_ rect : _q_CWindows_CFoundation_CRect, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRoundedRectangleWithColorAndStrokeWidth(pThis, rect, radiusX, radiusY, color, strokeWidth))
        }
    }
    public func DrawRoundedRectangleWithColorAndStrokeWidth(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawRoundedRectangleWithColorAndStrokeWidth(rect, radiusX, radiusY, color, strokeWidth);
    }
    // void DrawRoundedRectangle(System.Single, System.Single, System.Single, System.Single, System.Single, System.Single, Windows.UI.Color, System.Single)
    private func _n_DrawRoundedRectangleAtCoordsWithColorAndStrokeWidth(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRoundedRectangleAtCoordsWithColorAndStrokeWidth(pThis, x, y, w, h, radiusX, radiusY, color, strokeWidth))
        }
    }
    public func DrawRoundedRectangleAtCoordsWithColorAndStrokeWidth(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawRoundedRectangleAtCoordsWithColorAndStrokeWidth(x, y, w, h, radiusX, radiusY, color, strokeWidth);
    }
    // void DrawRoundedRectangle(Windows.Foundation.Rect, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawRoundedRectangleWithBrushAndStrokeWidthAndStrokeStyle(_ rect : _q_CWindows_CFoundation_CRect, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRoundedRectangleWithBrushAndStrokeWidthAndStrokeStyle(pThis, rect, radiusX, radiusY, brush, strokeWidth, strokeStyle))
        }
    }
    public func DrawRoundedRectangleWithBrushAndStrokeWidthAndStrokeStyle(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawRoundedRectangleWithBrushAndStrokeWidthAndStrokeStyle(rect, radiusX, radiusY, RawPointer(brush), strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawRoundedRectangle(System.Single, System.Single, System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(pThis, x, y, w, h, radiusX, radiusY, brush, strokeWidth, strokeStyle))
        }
    }
    public func DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawRoundedRectangleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x, y, w, h, radiusX, radiusY, RawPointer(brush), strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawRoundedRectangle(Windows.Foundation.Rect, System.Single, System.Single, Windows.UI.Color, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawRoundedRectangleWithColorAndStrokeWidthAndStrokeStyle(_ rect : _q_CWindows_CFoundation_CRect, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRoundedRectangleWithColorAndStrokeWidthAndStrokeStyle(pThis, rect, radiusX, radiusY, color, strokeWidth, strokeStyle))
        }
    }
    public func DrawRoundedRectangleWithColorAndStrokeWidthAndStrokeStyle(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawRoundedRectangleWithColorAndStrokeWidthAndStrokeStyle(rect, radiusX, radiusY, color, strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawRoundedRectangle(System.Single, System.Single, System.Single, System.Single, System.Single, System.Single, Windows.UI.Color, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawRoundedRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawRoundedRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(pThis, x, y, w, h, radiusX, radiusY, color, strokeWidth, strokeStyle))
        }
    }
    public func DrawRoundedRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawRoundedRectangleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x, y, w, h, radiusX, radiusY, color, strokeWidth, RawPointer(strokeStyle));
    }
    // void FillRoundedRectangle(Windows.Foundation.Rect, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillRoundedRectangleWithBrush(_ rect : _q_CWindows_CFoundation_CRect, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillRoundedRectangleWithBrush(pThis, rect, radiusX, radiusY, brush))
        }
    }
    public func FillRoundedRectangleWithBrush(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillRoundedRectangleWithBrush(rect, radiusX, radiusY, RawPointer(brush));
    }
    // void FillRoundedRectangle(System.Single, System.Single, System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillRoundedRectangleAtCoordsWithBrush(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillRoundedRectangleAtCoordsWithBrush(pThis, x, y, w, h, radiusX, radiusY, brush))
        }
    }
    public func FillRoundedRectangleAtCoordsWithBrush(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillRoundedRectangleAtCoordsWithBrush(x, y, w, h, radiusX, radiusY, RawPointer(brush));
    }
    // void FillRoundedRectangle(Windows.Foundation.Rect, System.Single, System.Single, Windows.UI.Color)
    private func _n_FillRoundedRectangleWithColor(_ rect : _q_CWindows_CFoundation_CRect, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillRoundedRectangleWithColor(pThis, rect, radiusX, radiusY, color))
        }
    }
    public func FillRoundedRectangleWithColor(rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_FillRoundedRectangleWithColor(rect, radiusX, radiusY, color);
    }
    // void FillRoundedRectangle(System.Single, System.Single, System.Single, System.Single, System.Single, System.Single, Windows.UI.Color)
    private func _n_FillRoundedRectangleAtCoordsWithColor(_ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillRoundedRectangleAtCoordsWithColor(pThis, x, y, w, h, radiusX, radiusY, color))
        }
    }
    public func FillRoundedRectangleAtCoordsWithColor(x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_FillRoundedRectangleAtCoordsWithColor(x, y, w, h, radiusX, radiusY, color);
    }
    // void DrawEllipse(Windows.Foundation.Numerics.Vector2, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawEllipseWithBrush(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawEllipseWithBrush(pThis, centerPoint, radiusX, radiusY, brush))
        }
    }
    public func DrawEllipseWithBrush(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawEllipseWithBrush(centerPoint, radiusX, radiusY, RawPointer(brush));
    }
    // void DrawEllipse(System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawEllipseAtCoordsWithBrush(_ x : FLOAT, _ y : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawEllipseAtCoordsWithBrush(pThis, x, y, radiusX, radiusY, brush))
        }
    }
    public func DrawEllipseAtCoordsWithBrush(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawEllipseAtCoordsWithBrush(x, y, radiusX, radiusY, RawPointer(brush));
    }
    // void DrawEllipse(Windows.Foundation.Numerics.Vector2, System.Single, System.Single, Windows.UI.Color)
    private func _n_DrawEllipseWithColor(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawEllipseWithColor(pThis, centerPoint, radiusX, radiusY, color))
        }
    }
    public func DrawEllipseWithColor(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawEllipseWithColor(centerPoint, radiusX, radiusY, color);
    }
    // void DrawEllipse(System.Single, System.Single, System.Single, System.Single, Windows.UI.Color)
    private func _n_DrawEllipseAtCoordsWithColor(_ x : FLOAT, _ y : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawEllipseAtCoordsWithColor(pThis, x, y, radiusX, radiusY, color))
        }
    }
    public func DrawEllipseAtCoordsWithColor(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawEllipseAtCoordsWithColor(x, y, radiusX, radiusY, color);
    }
    // void DrawEllipse(Windows.Foundation.Numerics.Vector2, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single)
    private func _n_DrawEllipseWithBrushAndStrokeWidth(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawEllipseWithBrushAndStrokeWidth(pThis, centerPoint, radiusX, radiusY, brush, strokeWidth))
        }
    }
    public func DrawEllipseWithBrushAndStrokeWidth(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawEllipseWithBrushAndStrokeWidth(centerPoint, radiusX, radiusY, RawPointer(brush), strokeWidth);
    }
    // void DrawEllipse(System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single)
    private func _n_DrawEllipseAtCoordsWithBrushAndStrokeWidth(_ x : FLOAT, _ y : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawEllipseAtCoordsWithBrushAndStrokeWidth(pThis, x, y, radiusX, radiusY, brush, strokeWidth))
        }
    }
    public func DrawEllipseAtCoordsWithBrushAndStrokeWidth(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawEllipseAtCoordsWithBrushAndStrokeWidth(x, y, radiusX, radiusY, RawPointer(brush), strokeWidth);
    }
    // void DrawEllipse(Windows.Foundation.Numerics.Vector2, System.Single, System.Single, Windows.UI.Color, System.Single)
    private func _n_DrawEllipseWithColorAndStrokeWidth(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawEllipseWithColorAndStrokeWidth(pThis, centerPoint, radiusX, radiusY, color, strokeWidth))
        }
    }
    public func DrawEllipseWithColorAndStrokeWidth(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawEllipseWithColorAndStrokeWidth(centerPoint, radiusX, radiusY, color, strokeWidth);
    }
    // void DrawEllipse(System.Single, System.Single, System.Single, System.Single, Windows.UI.Color, System.Single)
    private func _n_DrawEllipseAtCoordsWithColorAndStrokeWidth(_ x : FLOAT, _ y : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawEllipseAtCoordsWithColorAndStrokeWidth(pThis, x, y, radiusX, radiusY, color, strokeWidth))
        }
    }
    public func DrawEllipseAtCoordsWithColorAndStrokeWidth(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawEllipseAtCoordsWithColorAndStrokeWidth(x, y, radiusX, radiusY, color, strokeWidth);
    }
    // void DrawEllipse(Windows.Foundation.Numerics.Vector2, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawEllipseWithBrushAndStrokeWidthAndStrokeStyle(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawEllipseWithBrushAndStrokeWidthAndStrokeStyle(pThis, centerPoint, radiusX, radiusY, brush, strokeWidth, strokeStyle))
        }
    }
    public func DrawEllipseWithBrushAndStrokeWidthAndStrokeStyle(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawEllipseWithBrushAndStrokeWidthAndStrokeStyle(centerPoint, radiusX, radiusY, RawPointer(brush), strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawEllipse(System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawEllipseAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(_ x : FLOAT, _ y : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawEllipseAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(pThis, x, y, radiusX, radiusY, brush, strokeWidth, strokeStyle))
        }
    }
    public func DrawEllipseAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawEllipseAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x, y, radiusX, radiusY, RawPointer(brush), strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawEllipse(Windows.Foundation.Numerics.Vector2, System.Single, System.Single, Windows.UI.Color, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawEllipseWithColorAndStrokeWidthAndStrokeStyle(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawEllipseWithColorAndStrokeWidthAndStrokeStyle(pThis, centerPoint, radiusX, radiusY, color, strokeWidth, strokeStyle))
        }
    }
    public func DrawEllipseWithColorAndStrokeWidthAndStrokeStyle(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawEllipseWithColorAndStrokeWidthAndStrokeStyle(centerPoint, radiusX, radiusY, color, strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawEllipse(System.Single, System.Single, System.Single, System.Single, Windows.UI.Color, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawEllipseAtCoordsWithColorAndStrokeWidthAndStrokeStyle(_ x : FLOAT, _ y : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawEllipseAtCoordsWithColorAndStrokeWidthAndStrokeStyle(pThis, x, y, radiusX, radiusY, color, strokeWidth, strokeStyle))
        }
    }
    public func DrawEllipseAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawEllipseAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x, y, radiusX, radiusY, color, strokeWidth, RawPointer(strokeStyle));
    }
    // void FillEllipse(Windows.Foundation.Numerics.Vector2, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillEllipseWithBrush(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillEllipseWithBrush(pThis, centerPoint, radiusX, radiusY, brush))
        }
    }
    public func FillEllipseWithBrush(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillEllipseWithBrush(centerPoint, radiusX, radiusY, RawPointer(brush));
    }
    // void FillEllipse(System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillEllipseAtCoordsWithBrush(_ x : FLOAT, _ y : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillEllipseAtCoordsWithBrush(pThis, x, y, radiusX, radiusY, brush))
        }
    }
    public func FillEllipseAtCoordsWithBrush(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillEllipseAtCoordsWithBrush(x, y, radiusX, radiusY, RawPointer(brush));
    }
    // void FillEllipse(Windows.Foundation.Numerics.Vector2, System.Single, System.Single, Windows.UI.Color)
    private func _n_FillEllipseWithColor(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillEllipseWithColor(pThis, centerPoint, radiusX, radiusY, color))
        }
    }
    public func FillEllipseWithColor(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_FillEllipseWithColor(centerPoint, radiusX, radiusY, color);
    }
    // void FillEllipse(System.Single, System.Single, System.Single, System.Single, Windows.UI.Color)
    private func _n_FillEllipseAtCoordsWithColor(_ x : FLOAT, _ y : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillEllipseAtCoordsWithColor(pThis, x, y, radiusX, radiusY, color))
        }
    }
    public func FillEllipseAtCoordsWithColor(x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_FillEllipseAtCoordsWithColor(x, y, radiusX, radiusY, color);
    }
    // void DrawCircle(Windows.Foundation.Numerics.Vector2, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawCircleWithBrush(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radius : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCircleWithBrush(pThis, centerPoint, radius, brush))
        }
    }
    public func DrawCircleWithBrush(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawCircleWithBrush(centerPoint, radius, RawPointer(brush));
    }
    // void DrawCircle(System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawCircleAtCoordsWithBrush(_ x : FLOAT, _ y : FLOAT, _ radius : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCircleAtCoordsWithBrush(pThis, x, y, radius, brush))
        }
    }
    public func DrawCircleAtCoordsWithBrush(x : Swift.Float, y : Swift.Float, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawCircleAtCoordsWithBrush(x, y, radius, RawPointer(brush));
    }
    // void DrawCircle(Windows.Foundation.Numerics.Vector2, System.Single, Windows.UI.Color)
    private func _n_DrawCircleWithColor(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radius : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCircleWithColor(pThis, centerPoint, radius, color))
        }
    }
    public func DrawCircleWithColor(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawCircleWithColor(centerPoint, radius, color);
    }
    // void DrawCircle(System.Single, System.Single, System.Single, Windows.UI.Color)
    private func _n_DrawCircleAtCoordsWithColor(_ x : FLOAT, _ y : FLOAT, _ radius : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCircleAtCoordsWithColor(pThis, x, y, radius, color))
        }
    }
    public func DrawCircleAtCoordsWithColor(x : Swift.Float, y : Swift.Float, radius : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawCircleAtCoordsWithColor(x, y, radius, color);
    }
    // void DrawCircle(Windows.Foundation.Numerics.Vector2, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single)
    private func _n_DrawCircleWithBrushAndStrokeWidth(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radius : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCircleWithBrushAndStrokeWidth(pThis, centerPoint, radius, brush, strokeWidth))
        }
    }
    public func DrawCircleWithBrushAndStrokeWidth(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawCircleWithBrushAndStrokeWidth(centerPoint, radius, RawPointer(brush), strokeWidth);
    }
    // void DrawCircle(System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single)
    private func _n_DrawCircleAtCoordsWithBrushAndStrokeWidth(_ x : FLOAT, _ y : FLOAT, _ radius : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCircleAtCoordsWithBrushAndStrokeWidth(pThis, x, y, radius, brush, strokeWidth))
        }
    }
    public func DrawCircleAtCoordsWithBrushAndStrokeWidth(x : Swift.Float, y : Swift.Float, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawCircleAtCoordsWithBrushAndStrokeWidth(x, y, radius, RawPointer(brush), strokeWidth);
    }
    // void DrawCircle(Windows.Foundation.Numerics.Vector2, System.Single, Windows.UI.Color, System.Single)
    private func _n_DrawCircleWithColorAndStrokeWidth(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radius : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCircleWithColorAndStrokeWidth(pThis, centerPoint, radius, color, strokeWidth))
        }
    }
    public func DrawCircleWithColorAndStrokeWidth(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawCircleWithColorAndStrokeWidth(centerPoint, radius, color, strokeWidth);
    }
    // void DrawCircle(System.Single, System.Single, System.Single, Windows.UI.Color, System.Single)
    private func _n_DrawCircleAtCoordsWithColorAndStrokeWidth(_ x : FLOAT, _ y : FLOAT, _ radius : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCircleAtCoordsWithColorAndStrokeWidth(pThis, x, y, radius, color, strokeWidth))
        }
    }
    public func DrawCircleAtCoordsWithColorAndStrokeWidth(x : Swift.Float, y : Swift.Float, radius : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawCircleAtCoordsWithColorAndStrokeWidth(x, y, radius, color, strokeWidth);
    }
    // void DrawCircle(Windows.Foundation.Numerics.Vector2, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawCircleWithBrushAndStrokeWidthAndStrokeStyle(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radius : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCircleWithBrushAndStrokeWidthAndStrokeStyle(pThis, centerPoint, radius, brush, strokeWidth, strokeStyle))
        }
    }
    public func DrawCircleWithBrushAndStrokeWidthAndStrokeStyle(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawCircleWithBrushAndStrokeWidthAndStrokeStyle(centerPoint, radius, RawPointer(brush), strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawCircle(System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawCircleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(_ x : FLOAT, _ y : FLOAT, _ radius : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCircleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(pThis, x, y, radius, brush, strokeWidth, strokeStyle))
        }
    }
    public func DrawCircleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x : Swift.Float, y : Swift.Float, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawCircleAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(x, y, radius, RawPointer(brush), strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawCircle(Windows.Foundation.Numerics.Vector2, System.Single, Windows.UI.Color, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawCircleWithColorAndStrokeWidthAndStrokeStyle(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radius : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCircleWithColorAndStrokeWidthAndStrokeStyle(pThis, centerPoint, radius, color, strokeWidth, strokeStyle))
        }
    }
    public func DrawCircleWithColorAndStrokeWidthAndStrokeStyle(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawCircleWithColorAndStrokeWidthAndStrokeStyle(centerPoint, radius, color, strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawCircle(System.Single, System.Single, System.Single, Windows.UI.Color, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawCircleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(_ x : FLOAT, _ y : FLOAT, _ radius : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCircleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(pThis, x, y, radius, color, strokeWidth, strokeStyle))
        }
    }
    public func DrawCircleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x : Swift.Float, y : Swift.Float, radius : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawCircleAtCoordsWithColorAndStrokeWidthAndStrokeStyle(x, y, radius, color, strokeWidth, RawPointer(strokeStyle));
    }
    // void FillCircle(Windows.Foundation.Numerics.Vector2, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillCircleWithBrush(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radius : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillCircleWithBrush(pThis, centerPoint, radius, brush))
        }
    }
    public func FillCircleWithBrush(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillCircleWithBrush(centerPoint, radius, RawPointer(brush));
    }
    // void FillCircle(System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillCircleAtCoordsWithBrush(_ x : FLOAT, _ y : FLOAT, _ radius : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillCircleAtCoordsWithBrush(pThis, x, y, radius, brush))
        }
    }
    public func FillCircleAtCoordsWithBrush(x : Swift.Float, y : Swift.Float, radius : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillCircleAtCoordsWithBrush(x, y, radius, RawPointer(brush));
    }
    // void FillCircle(Windows.Foundation.Numerics.Vector2, System.Single, Windows.UI.Color)
    private func _n_FillCircleWithColor(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radius : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillCircleWithColor(pThis, centerPoint, radius, color))
        }
    }
    public func FillCircleWithColor(centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_FillCircleWithColor(centerPoint, radius, color);
    }
    // void FillCircle(System.Single, System.Single, System.Single, Windows.UI.Color)
    private func _n_FillCircleAtCoordsWithColor(_ x : FLOAT, _ y : FLOAT, _ radius : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillCircleAtCoordsWithColor(pThis, x, y, radius, color))
        }
    }
    public func FillCircleAtCoordsWithColor(x : Swift.Float, y : Swift.Float, radius : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_FillCircleAtCoordsWithColor(x, y, radius, color);
    }
    // void DrawText(System.String, Windows.Foundation.Numerics.Vector2, Windows.UI.Color)
    private func _n_DrawTextAtPointWithColor(_ text : Optional<HSTRING>, _ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextAtPointWithColor(pThis, text, point, color))
        }
    }
    public func DrawTextAtPointWithColor(text : Optional<Swift.String>, point : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color) throws -> Void {
        let __hstr_text = try HString(text!);
        return try withExtendedLifetime(__hstr_text) {
        try self._n_DrawTextAtPointWithColor(__hstr_text.Raw(), point, color);
        }
    }
    // void DrawText(System.String, System.Single, System.Single, Windows.UI.Color)
    private func _n_DrawTextAtPointCoordsWithColor(_ text : Optional<HSTRING>, _ x : FLOAT, _ y : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextAtPointCoordsWithColor(pThis, text, x, y, color))
        }
    }
    public func DrawTextAtPointCoordsWithColor(text : Optional<Swift.String>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color) throws -> Void {
        let __hstr_text = try HString(text!);
        return try withExtendedLifetime(__hstr_text) {
        try self._n_DrawTextAtPointCoordsWithColor(__hstr_text.Raw(), x, y, color);
        }
    }
    // void DrawText(System.String, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Microsoft.Graphics.Canvas.Text.CanvasTextFormat)
    private func _n_DrawTextAtPointWithBrushAndFormat(_ text : Optional<HSTRING>, _ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ format : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextFormat>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextAtPointWithBrushAndFormat(pThis, text, point, brush, format))
        }
    }
    public func DrawTextAtPointWithBrushAndFormat(text : Optional<Swift.String>, point : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, format : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextFormat>) throws -> Void {
        let __hstr_text = try HString(text!);
        return try withExtendedLifetime(__hstr_text) {
        try self._n_DrawTextAtPointWithBrushAndFormat(__hstr_text.Raw(), point, RawPointer(brush), RawPointer(format));
        }
    }
    // void DrawText(System.String, Windows.Foundation.Rect, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Microsoft.Graphics.Canvas.Text.CanvasTextFormat)
    private func _n_DrawTextAtRectWithBrushAndFormat(_ text : Optional<HSTRING>, _ rectangle : _q_CWindows_CFoundation_CRect, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ format : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextFormat>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextAtRectWithBrushAndFormat(pThis, text, rectangle, brush, format))
        }
    }
    public func DrawTextAtRectWithBrushAndFormat(text : Optional<Swift.String>, rectangle : Windows.Foundation.Rect, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, format : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextFormat>) throws -> Void {
        let __hstr_text = try HString(text!);
        return try withExtendedLifetime(__hstr_text) {
        try self._n_DrawTextAtRectWithBrushAndFormat(__hstr_text.Raw(), rectangle, RawPointer(brush), RawPointer(format));
        }
    }
    // void DrawText(System.String, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Microsoft.Graphics.Canvas.Text.CanvasTextFormat)
    private func _n_DrawTextAtPointCoordsWithBrushAndFormat(_ text : Optional<HSTRING>, _ x : FLOAT, _ y : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ format : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextFormat>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextAtPointCoordsWithBrushAndFormat(pThis, text, x, y, brush, format))
        }
    }
    public func DrawTextAtPointCoordsWithBrushAndFormat(text : Optional<Swift.String>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, format : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextFormat>) throws -> Void {
        let __hstr_text = try HString(text!);
        return try withExtendedLifetime(__hstr_text) {
        try self._n_DrawTextAtPointCoordsWithBrushAndFormat(__hstr_text.Raw(), x, y, RawPointer(brush), RawPointer(format));
        }
    }
    // void DrawText(System.String, System.Single, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Microsoft.Graphics.Canvas.Text.CanvasTextFormat)
    private func _n_DrawTextAtRectCoordsWithBrushAndFormat(_ text : Optional<HSTRING>, _ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ format : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextFormat>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextAtRectCoordsWithBrushAndFormat(pThis, text, x, y, w, h, brush, format))
        }
    }
    public func DrawTextAtRectCoordsWithBrushAndFormat(text : Optional<Swift.String>, x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, format : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextFormat>) throws -> Void {
        let __hstr_text = try HString(text!);
        return try withExtendedLifetime(__hstr_text) {
        try self._n_DrawTextAtRectCoordsWithBrushAndFormat(__hstr_text.Raw(), x, y, w, h, RawPointer(brush), RawPointer(format));
        }
    }
    // void DrawText(System.String, Windows.Foundation.Numerics.Vector2, Windows.UI.Color, Microsoft.Graphics.Canvas.Text.CanvasTextFormat)
    private func _n_DrawTextAtPointWithColorAndFormat(_ text : Optional<HSTRING>, _ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ color : _q_CWindows_CUI_CColor, _ format : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextFormat>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextAtPointWithColorAndFormat(pThis, text, point, color, format))
        }
    }
    public func DrawTextAtPointWithColorAndFormat(text : Optional<Swift.String>, point : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color, format : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextFormat>) throws -> Void {
        let __hstr_text = try HString(text!);
        return try withExtendedLifetime(__hstr_text) {
        try self._n_DrawTextAtPointWithColorAndFormat(__hstr_text.Raw(), point, color, RawPointer(format));
        }
    }
    // void DrawText(System.String, Windows.Foundation.Rect, Windows.UI.Color, Microsoft.Graphics.Canvas.Text.CanvasTextFormat)
    private func _n_DrawTextAtRectWithColorAndFormat(_ text : Optional<HSTRING>, _ rectangle : _q_CWindows_CFoundation_CRect, _ color : _q_CWindows_CUI_CColor, _ format : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextFormat>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextAtRectWithColorAndFormat(pThis, text, rectangle, color, format))
        }
    }
    public func DrawTextAtRectWithColorAndFormat(text : Optional<Swift.String>, rectangle : Windows.Foundation.Rect, color : Windows.UI.Color, format : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextFormat>) throws -> Void {
        let __hstr_text = try HString(text!);
        return try withExtendedLifetime(__hstr_text) {
        try self._n_DrawTextAtRectWithColorAndFormat(__hstr_text.Raw(), rectangle, color, RawPointer(format));
        }
    }
    // void DrawText(System.String, System.Single, System.Single, Windows.UI.Color, Microsoft.Graphics.Canvas.Text.CanvasTextFormat)
    private func _n_DrawTextAtPointCoordsWithColorAndFormat(_ text : Optional<HSTRING>, _ x : FLOAT, _ y : FLOAT, _ color : _q_CWindows_CUI_CColor, _ format : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextFormat>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextAtPointCoordsWithColorAndFormat(pThis, text, x, y, color, format))
        }
    }
    public func DrawTextAtPointCoordsWithColorAndFormat(text : Optional<Swift.String>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color, format : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextFormat>) throws -> Void {
        let __hstr_text = try HString(text!);
        return try withExtendedLifetime(__hstr_text) {
        try self._n_DrawTextAtPointCoordsWithColorAndFormat(__hstr_text.Raw(), x, y, color, RawPointer(format));
        }
    }
    // void DrawText(System.String, System.Single, System.Single, System.Single, System.Single, Windows.UI.Color, Microsoft.Graphics.Canvas.Text.CanvasTextFormat)
    private func _n_DrawTextAtRectCoordsWithColorAndFormat(_ text : Optional<HSTRING>, _ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ color : _q_CWindows_CUI_CColor, _ format : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextFormat>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextAtRectCoordsWithColorAndFormat(pThis, text, x, y, w, h, color, format))
        }
    }
    public func DrawTextAtRectCoordsWithColorAndFormat(text : Optional<Swift.String>, x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, color : Windows.UI.Color, format : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextFormat>) throws -> Void {
        let __hstr_text = try HString(text!);
        return try withExtendedLifetime(__hstr_text) {
        try self._n_DrawTextAtRectCoordsWithColorAndFormat(__hstr_text.Raw(), x, y, w, h, color, RawPointer(format));
        }
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawGeometryWithBrush(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryWithBrush(pThis, geometry, offset, brush))
        }
    }
    public func DrawGeometryWithBrush(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawGeometryWithBrush(RawPointer(geometry), offset, RawPointer(brush));
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Vector2, Windows.UI.Color)
    private func _n_DrawGeometryWithColor(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryWithColor(pThis, geometry, offset, color))
        }
    }
    public func DrawGeometryWithColor(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawGeometryWithColor(RawPointer(geometry), offset, color);
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawGeometryAtCoordsWithBrush(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ x : FLOAT, _ y : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryAtCoordsWithBrush(pThis, geometry, x, y, brush))
        }
    }
    public func DrawGeometryAtCoordsWithBrush(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawGeometryAtCoordsWithBrush(RawPointer(geometry), x, y, RawPointer(brush));
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, System.Single, System.Single, Windows.UI.Color)
    private func _n_DrawGeometryAtCoordsWithColor(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ x : FLOAT, _ y : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryAtCoordsWithColor(pThis, geometry, x, y, color))
        }
    }
    public func DrawGeometryAtCoordsWithColor(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawGeometryAtCoordsWithColor(RawPointer(geometry), x, y, color);
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawGeometryAtOriginWithBrush(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryAtOriginWithBrush(pThis, geometry, brush))
        }
    }
    public func DrawGeometryAtOriginWithBrush(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawGeometryAtOriginWithBrush(RawPointer(geometry), RawPointer(brush));
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.UI.Color)
    private func _n_DrawGeometryAtOriginWithColor(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryAtOriginWithColor(pThis, geometry, color))
        }
    }
    public func DrawGeometryAtOriginWithColor(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawGeometryAtOriginWithColor(RawPointer(geometry), color);
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single)
    private func _n_DrawGeometryWithBrushAndStrokeWidth(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryWithBrushAndStrokeWidth(pThis, geometry, offset, brush, strokeWidth))
        }
    }
    public func DrawGeometryWithBrushAndStrokeWidth(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawGeometryWithBrushAndStrokeWidth(RawPointer(geometry), offset, RawPointer(brush), strokeWidth);
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Vector2, Windows.UI.Color, System.Single)
    private func _n_DrawGeometryWithColorAndStrokeWidth(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryWithColorAndStrokeWidth(pThis, geometry, offset, color, strokeWidth))
        }
    }
    public func DrawGeometryWithColorAndStrokeWidth(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawGeometryWithColorAndStrokeWidth(RawPointer(geometry), offset, color, strokeWidth);
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single)
    private func _n_DrawGeometryAtCoordsWithBrushAndStrokeWidth(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ x : FLOAT, _ y : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryAtCoordsWithBrushAndStrokeWidth(pThis, geometry, x, y, brush, strokeWidth))
        }
    }
    public func DrawGeometryAtCoordsWithBrushAndStrokeWidth(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawGeometryAtCoordsWithBrushAndStrokeWidth(RawPointer(geometry), x, y, RawPointer(brush), strokeWidth);
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, System.Single, System.Single, Windows.UI.Color, System.Single)
    private func _n_DrawGeometryAtCoordsWithColorAndStrokeWidth(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ x : FLOAT, _ y : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryAtCoordsWithColorAndStrokeWidth(pThis, geometry, x, y, color, strokeWidth))
        }
    }
    public func DrawGeometryAtCoordsWithColorAndStrokeWidth(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawGeometryAtCoordsWithColorAndStrokeWidth(RawPointer(geometry), x, y, color, strokeWidth);
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single)
    private func _n_DrawGeometryAtOriginWithBrushAndStrokeWidth(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryAtOriginWithBrushAndStrokeWidth(pThis, geometry, brush, strokeWidth))
        }
    }
    public func DrawGeometryAtOriginWithBrushAndStrokeWidth(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawGeometryAtOriginWithBrushAndStrokeWidth(RawPointer(geometry), RawPointer(brush), strokeWidth);
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.UI.Color, System.Single)
    private func _n_DrawGeometryAtOriginWithColorAndStrokeWidth(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryAtOriginWithColorAndStrokeWidth(pThis, geometry, color, strokeWidth))
        }
    }
    public func DrawGeometryAtOriginWithColorAndStrokeWidth(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, color : Windows.UI.Color, strokeWidth : Swift.Float) throws -> Void {
        try self._n_DrawGeometryAtOriginWithColorAndStrokeWidth(RawPointer(geometry), color, strokeWidth);
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawGeometryWithBrushAndStrokeWidthAndStrokeStyle(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryWithBrushAndStrokeWidthAndStrokeStyle(pThis, geometry, offset, brush, strokeWidth, strokeStyle))
        }
    }
    public func DrawGeometryWithBrushAndStrokeWidthAndStrokeStyle(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawGeometryWithBrushAndStrokeWidthAndStrokeStyle(RawPointer(geometry), offset, RawPointer(brush), strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Vector2, Windows.UI.Color, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawGeometryWithColorAndStrokeWidthAndStrokeStyle(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryWithColorAndStrokeWidthAndStrokeStyle(pThis, geometry, offset, color, strokeWidth, strokeStyle))
        }
    }
    public func DrawGeometryWithColorAndStrokeWidthAndStrokeStyle(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawGeometryWithColorAndStrokeWidthAndStrokeStyle(RawPointer(geometry), offset, color, strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawGeometryAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ x : FLOAT, _ y : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(pThis, geometry, x, y, brush, strokeWidth, strokeStyle))
        }
    }
    public func DrawGeometryAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawGeometryAtCoordsWithBrushAndStrokeWidthAndStrokeStyle(RawPointer(geometry), x, y, RawPointer(brush), strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, System.Single, System.Single, Windows.UI.Color, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawGeometryAtCoordsWithColorAndStrokeWidthAndStrokeStyle(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ x : FLOAT, _ y : FLOAT, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryAtCoordsWithColorAndStrokeWidthAndStrokeStyle(pThis, geometry, x, y, color, strokeWidth, strokeStyle))
        }
    }
    public func DrawGeometryAtCoordsWithColorAndStrokeWidthAndStrokeStyle(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawGeometryAtCoordsWithColorAndStrokeWidthAndStrokeStyle(RawPointer(geometry), x, y, color, strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawGeometryAtOriginWithBrushAndStrokeWidthAndStrokeStyle(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryAtOriginWithBrushAndStrokeWidthAndStrokeStyle(pThis, geometry, brush, strokeWidth, strokeStyle))
        }
    }
    public func DrawGeometryAtOriginWithBrushAndStrokeWidthAndStrokeStyle(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawGeometryAtOriginWithBrushAndStrokeWidthAndStrokeStyle(RawPointer(geometry), RawPointer(brush), strokeWidth, RawPointer(strokeStyle));
    }
    // void DrawGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.UI.Color, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_DrawGeometryAtOriginWithColorAndStrokeWidthAndStrokeStyle(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ color : _q_CWindows_CUI_CColor, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGeometryAtOriginWithColorAndStrokeWidthAndStrokeStyle(pThis, geometry, color, strokeWidth, strokeStyle))
        }
    }
    public func DrawGeometryAtOriginWithColorAndStrokeWidthAndStrokeStyle(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, color : Windows.UI.Color, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Void {
        try self._n_DrawGeometryAtOriginWithColorAndStrokeWidthAndStrokeStyle(RawPointer(geometry), color, strokeWidth, RawPointer(strokeStyle));
    }
    // void FillGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillGeometryWithBrush(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillGeometryWithBrush(pThis, geometry, offset, brush))
        }
    }
    public func FillGeometryWithBrush(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillGeometryWithBrush(RawPointer(geometry), offset, RawPointer(brush));
    }
    // void FillGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillGeometryWithBrushAndOpacityBrush(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ opacityBrush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillGeometryWithBrushAndOpacityBrush(pThis, geometry, offset, brush, opacityBrush))
        }
    }
    public func FillGeometryWithBrushAndOpacityBrush(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillGeometryWithBrushAndOpacityBrush(RawPointer(geometry), offset, RawPointer(brush), RawPointer(opacityBrush));
    }
    // void FillGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Vector2, Windows.UI.Color)
    private func _n_FillGeometryWithColor(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillGeometryWithColor(pThis, geometry, offset, color))
        }
    }
    public func FillGeometryWithColor(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, offset : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color) throws -> Void {
        try self._n_FillGeometryWithColor(RawPointer(geometry), offset, color);
    }
    // void FillGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillGeometryAtCoordsWithBrush(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ x : FLOAT, _ y : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillGeometryAtCoordsWithBrush(pThis, geometry, x, y, brush))
        }
    }
    public func FillGeometryAtCoordsWithBrush(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillGeometryAtCoordsWithBrush(RawPointer(geometry), x, y, RawPointer(brush));
    }
    // void FillGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillGeometryAtCoordsWithBrushAndOpacityBrush(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ x : FLOAT, _ y : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ opacityBrush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillGeometryAtCoordsWithBrushAndOpacityBrush(pThis, geometry, x, y, brush, opacityBrush))
        }
    }
    public func FillGeometryAtCoordsWithBrushAndOpacityBrush(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillGeometryAtCoordsWithBrushAndOpacityBrush(RawPointer(geometry), x, y, RawPointer(brush), RawPointer(opacityBrush));
    }
    // void FillGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, System.Single, System.Single, Windows.UI.Color)
    private func _n_FillGeometryAtCoordsWithColor(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ x : FLOAT, _ y : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillGeometryAtCoordsWithColor(pThis, geometry, x, y, color))
        }
    }
    public func FillGeometryAtCoordsWithColor(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_FillGeometryAtCoordsWithColor(RawPointer(geometry), x, y, color);
    }
    // void FillGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillGeometryAtOriginWithBrush(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillGeometryAtOriginWithBrush(pThis, geometry, brush))
        }
    }
    public func FillGeometryAtOriginWithBrush(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillGeometryAtOriginWithBrush(RawPointer(geometry), RawPointer(brush));
    }
    // void FillGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_FillGeometryAtOriginWithBrushAndOpacityBrush(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ opacityBrush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillGeometryAtOriginWithBrushAndOpacityBrush(pThis, geometry, brush, opacityBrush))
        }
    }
    public func FillGeometryAtOriginWithBrushAndOpacityBrush(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_FillGeometryAtOriginWithBrushAndOpacityBrush(RawPointer(geometry), RawPointer(brush), RawPointer(opacityBrush));
    }
    // void FillGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.UI.Color)
    private func _n_FillGeometryAtOriginWithColor(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillGeometryAtOriginWithColor(pThis, geometry, color))
        }
    }
    public func FillGeometryAtOriginWithColor(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, color : Windows.UI.Color) throws -> Void {
        try self._n_FillGeometryAtOriginWithColor(RawPointer(geometry), color);
    }
    // void DrawCachedGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawCachedGeometryWithBrush(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCachedGeometryWithBrush(pThis, geometry, offset, brush))
        }
    }
    public func DrawCachedGeometryWithBrush(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry>, offset : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawCachedGeometryWithBrush(RawPointer(geometry), offset, RawPointer(brush));
    }
    // void DrawCachedGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry, Windows.Foundation.Numerics.Vector2, Windows.UI.Color)
    private func _n_DrawCachedGeometryWithColor(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCachedGeometryWithColor(pThis, geometry, offset, color))
        }
    }
    public func DrawCachedGeometryWithColor(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry>, offset : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawCachedGeometryWithColor(RawPointer(geometry), offset, color);
    }
    // void DrawCachedGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawCachedGeometryAtCoordsWithBrush(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>>, _ x : FLOAT, _ y : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCachedGeometryAtCoordsWithBrush(pThis, geometry, x, y, brush))
        }
    }
    public func DrawCachedGeometryAtCoordsWithBrush(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawCachedGeometryAtCoordsWithBrush(RawPointer(geometry), x, y, RawPointer(brush));
    }
    // void DrawCachedGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry, System.Single, System.Single, Windows.UI.Color)
    private func _n_DrawCachedGeometryAtCoordsWithColor(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>>, _ x : FLOAT, _ y : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCachedGeometryAtCoordsWithColor(pThis, geometry, x, y, color))
        }
    }
    public func DrawCachedGeometryAtCoordsWithColor(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawCachedGeometryAtCoordsWithColor(RawPointer(geometry), x, y, color);
    }
    // void DrawCachedGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawCachedGeometryAtOriginWithBrush(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>>, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCachedGeometryAtOriginWithBrush(pThis, geometry, brush))
        }
    }
    public func DrawCachedGeometryAtOriginWithBrush(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry>, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawCachedGeometryAtOriginWithBrush(RawPointer(geometry), RawPointer(brush));
    }
    // void DrawCachedGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry, Windows.UI.Color)
    private func _n_DrawCachedGeometryAtOriginWithColor(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>>, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawCachedGeometryAtOriginWithColor(pThis, geometry, color))
        }
    }
    public func DrawCachedGeometryAtOriginWithColor(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry>, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawCachedGeometryAtOriginWithColor(RawPointer(geometry), color);
    }
    // void DrawTextLayout(Microsoft.Graphics.Canvas.Text.CanvasTextLayout, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawTextLayoutWithBrush(_ textLayout : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextLayout>>, _ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextLayoutWithBrush(pThis, textLayout, point, brush))
        }
    }
    public func DrawTextLayoutWithBrush(textLayout : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextLayout>, point : Windows.Foundation.Numerics.Vector2, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawTextLayoutWithBrush(RawPointer(textLayout), point, RawPointer(brush));
    }
    // void DrawTextLayout(Microsoft.Graphics.Canvas.Text.CanvasTextLayout, System.Single, System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawTextLayoutAtCoordsWithBrush(_ textLayout : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextLayout>>, _ x : FLOAT, _ y : FLOAT, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextLayoutAtCoordsWithBrush(pThis, textLayout, x, y, brush))
        }
    }
    public func DrawTextLayoutAtCoordsWithBrush(textLayout : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextLayout>, x : Swift.Float, y : Swift.Float, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawTextLayoutAtCoordsWithBrush(RawPointer(textLayout), x, y, RawPointer(brush));
    }
    // void DrawTextLayout(Microsoft.Graphics.Canvas.Text.CanvasTextLayout, Windows.Foundation.Numerics.Vector2, Windows.UI.Color)
    private func _n_DrawTextLayoutWithColor(_ textLayout : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextLayout>>, _ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextLayoutWithColor(pThis, textLayout, point, color))
        }
    }
    public func DrawTextLayoutWithColor(textLayout : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextLayout>, point : Windows.Foundation.Numerics.Vector2, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawTextLayoutWithColor(RawPointer(textLayout), point, color);
    }
    // void DrawTextLayout(Microsoft.Graphics.Canvas.Text.CanvasTextLayout, System.Single, System.Single, Windows.UI.Color)
    private func _n_DrawTextLayoutAtCoordsWithColor(_ textLayout : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextLayout>>, _ x : FLOAT, _ y : FLOAT, _ color : _q_CWindows_CUI_CColor) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawTextLayoutAtCoordsWithColor(pThis, textLayout, x, y, color))
        }
    }
    public func DrawTextLayoutAtCoordsWithColor(textLayout : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextLayout>, x : Swift.Float, y : Swift.Float, color : Windows.UI.Color) throws -> Void {
        try self._n_DrawTextLayoutAtCoordsWithColor(RawPointer(textLayout), x, y, color);
    }
    // void DrawGradientMesh(Microsoft.Graphics.Canvas.Geometry.CanvasGradientMesh)
    private func _n_DrawGradientMeshAtOrigin(_ gradientMesh : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMesh>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGradientMeshAtOrigin(pThis, gradientMesh))
        }
    }
    public func DrawGradientMeshAtOrigin(gradientMesh : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh>) throws -> Void {
        try self._n_DrawGradientMeshAtOrigin(RawPointer(gradientMesh));
    }
    // void DrawGradientMesh(Microsoft.Graphics.Canvas.Geometry.CanvasGradientMesh, Windows.Foundation.Numerics.Vector2)
    private func _n_DrawGradientMesh(_ gradientMesh : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMesh>>, _ point : _q_CWindows_CFoundation_CNumerics_CVector2) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGradientMesh(pThis, gradientMesh, point))
        }
    }
    public func DrawGradientMesh(gradientMesh : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh>, point : Windows.Foundation.Numerics.Vector2) throws -> Void {
        try self._n_DrawGradientMesh(RawPointer(gradientMesh), point);
    }
    // void DrawGradientMesh(Microsoft.Graphics.Canvas.Geometry.CanvasGradientMesh, System.Single, System.Single)
    private func _n_DrawGradientMeshAtCoords(_ gradientMesh : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMesh>>, _ x : FLOAT, _ y : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGradientMeshAtCoords(pThis, gradientMesh, x, y))
        }
    }
    public func DrawGradientMeshAtCoords(gradientMesh : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh>, x : Swift.Float, y : Swift.Float) throws -> Void {
        try self._n_DrawGradientMeshAtCoords(RawPointer(gradientMesh), x, y);
    }
    // void DrawSvg(Microsoft.Graphics.Canvas.Svg.CanvasSvgDocument, Windows.Foundation.Size)
    private func _n_DrawSvgAtOrigin(_ svgDocument : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CSvg_CICanvasSvgDocument>>, _ viewportSize : _q_CWindows_CFoundation_CSize) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawSvgAtOrigin(pThis, svgDocument, viewportSize))
        }
    }
    public func DrawSvgAtOrigin(svgDocument : Optional<Microsoft.Graphics.Canvas.Svg.ICanvasSvgDocument>, viewportSize : Windows.Foundation.Size) throws -> Void {
        try self._n_DrawSvgAtOrigin(RawPointer(svgDocument), viewportSize);
    }
    // void DrawSvg(Microsoft.Graphics.Canvas.Svg.CanvasSvgDocument, Windows.Foundation.Size, Windows.Foundation.Numerics.Vector2)
    private func _n_DrawSvgAtPoint(_ svgDocument : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CSvg_CICanvasSvgDocument>>, _ viewportSize : _q_CWindows_CFoundation_CSize, _ point : _q_CWindows_CFoundation_CNumerics_CVector2) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawSvgAtPoint(pThis, svgDocument, viewportSize, point))
        }
    }
    public func DrawSvgAtPoint(svgDocument : Optional<Microsoft.Graphics.Canvas.Svg.ICanvasSvgDocument>, viewportSize : Windows.Foundation.Size, point : Windows.Foundation.Numerics.Vector2) throws -> Void {
        try self._n_DrawSvgAtPoint(RawPointer(svgDocument), viewportSize, point);
    }
    // void DrawSvg(Microsoft.Graphics.Canvas.Svg.CanvasSvgDocument, Windows.Foundation.Size, System.Single, System.Single)
    private func _n_DrawSvgAtCoords(_ svgDocument : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CSvg_CICanvasSvgDocument>>, _ viewportSize : _q_CWindows_CFoundation_CSize, _ x : FLOAT, _ y : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawSvgAtCoords(pThis, svgDocument, viewportSize, x, y))
        }
    }
    public func DrawSvgAtCoords(svgDocument : Optional<Microsoft.Graphics.Canvas.Svg.ICanvasSvgDocument>, viewportSize : Windows.Foundation.Size, x : Swift.Float, y : Swift.Float) throws -> Void {
        try self._n_DrawSvgAtCoords(RawPointer(svgDocument), viewportSize, x, y);
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.CanvasAntialiasing get_Antialiasing()
    private func _n_get_Antialiasing(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CCanvasAntialiasing>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Antialiasing(pThis, __presult))
        }
    }
    public func get_Antialiasing() throws -> Microsoft.Graphics.Canvas.CanvasAntialiasing {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAntialiasing = _q_CMicrosoft_CGraphics_CCanvas_CCanvasAntialiasing_Antialiased;
        try self._n_get_Antialiasing(&__result);
        return __result;
    }
    // [IsSpecialName] void put_Antialiasing(Microsoft.Graphics.Canvas.CanvasAntialiasing)
    private func _n_put_Antialiasing(_ value : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAntialiasing) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Antialiasing(pThis, value))
        }
    }
    public func put_Antialiasing(value : Microsoft.Graphics.Canvas.CanvasAntialiasing) throws -> Void {
        try self._n_put_Antialiasing(value);
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.CanvasBlend get_Blend()
    private func _n_get_Blend(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CCanvasBlend>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Blend(pThis, __presult))
        }
    }
    public func get_Blend() throws -> Microsoft.Graphics.Canvas.CanvasBlend {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CCanvasBlend = _q_CMicrosoft_CGraphics_CCanvas_CCanvasBlend_SourceOver;
        try self._n_get_Blend(&__result);
        return __result;
    }
    // [IsSpecialName] void put_Blend(Microsoft.Graphics.Canvas.CanvasBlend)
    private func _n_put_Blend(_ value : _q_CMicrosoft_CGraphics_CCanvas_CCanvasBlend) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Blend(pThis, value))
        }
    }
    public func put_Blend(value : Microsoft.Graphics.Canvas.CanvasBlend) throws -> Void {
        try self._n_put_Blend(value);
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.Text.CanvasTextAntialiasing get_TextAntialiasing()
    private func _n_get_TextAntialiasing(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasTextAntialiasing>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_TextAntialiasing(pThis, __presult))
        }
    }
    public func get_TextAntialiasing() throws -> Microsoft.Graphics.Canvas.Text.CanvasTextAntialiasing {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasTextAntialiasing = _q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasTextAntialiasing_Auto;
        try self._n_get_TextAntialiasing(&__result);
        return __result;
    }
    // [IsSpecialName] void put_TextAntialiasing(Microsoft.Graphics.Canvas.Text.CanvasTextAntialiasing)
    private func _n_put_TextAntialiasing(_ value : _q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasTextAntialiasing) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_TextAntialiasing(pThis, value))
        }
    }
    public func put_TextAntialiasing(value : Microsoft.Graphics.Canvas.Text.CanvasTextAntialiasing) throws -> Void {
        try self._n_put_TextAntialiasing(value);
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.Text.CanvasTextRenderingParameters get_TextRenderingParameters()
    private func _n_get_TextRenderingParameters(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextRenderingParameters>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_TextRenderingParameters(pThis, __presult))
        }
    }
    public func get_TextRenderingParameters() throws -> Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextRenderingParameters> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextRenderingParameters>> = nil;
        try self._n_get_TextRenderingParameters(&__result);
        return Microsoft.Graphics.Canvas.Text.ICanvasTextRenderingParameters(consuming: __result);
    }
    // [IsSpecialName] void put_TextRenderingParameters(Microsoft.Graphics.Canvas.Text.CanvasTextRenderingParameters)
    private func _n_put_TextRenderingParameters(_ value : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextRenderingParameters>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_TextRenderingParameters(pThis, value))
        }
    }
    public func put_TextRenderingParameters(value : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextRenderingParameters>) throws -> Void {
        try self._n_put_TextRenderingParameters(RawPointer(value));
    }
    // [IsSpecialName] Windows.Foundation.Numerics.Matrix3x2 get_Transform()
    private func _n_get_Transform(_ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CMatrix3x2>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Transform(pThis, __presult))
        }
    }
    public func get_Transform() throws -> Windows.Foundation.Numerics.Matrix3x2 {
        var __result : _q_CWindows_CFoundation_CNumerics_CMatrix3x2 = _q_CWindows_CFoundation_CNumerics_CMatrix3x2(M11: 0, M12: 0, M21: 0, M22: 0, M31: 0, M32: 0);
        try self._n_get_Transform(&__result);
        return __result;
    }
    // [IsSpecialName] void put_Transform(Windows.Foundation.Numerics.Matrix3x2)
    private func _n_put_Transform(_ value : _q_CWindows_CFoundation_CNumerics_CMatrix3x2) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Transform(pThis, value))
        }
    }
    public func put_Transform(value : Windows.Foundation.Numerics.Matrix3x2) throws -> Void {
        try self._n_put_Transform(value);
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.CanvasUnits get_Units()
    private func _n_get_Units(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CCanvasUnits>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Units(pThis, __presult))
        }
    }
    public func get_Units() throws -> Microsoft.Graphics.Canvas.CanvasUnits {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CCanvasUnits = _q_CMicrosoft_CGraphics_CCanvas_CCanvasUnits_Dips;
        try self._n_get_Units(&__result);
        return __result;
    }
    // [IsSpecialName] void put_Units(Microsoft.Graphics.Canvas.CanvasUnits)
    private func _n_put_Units(_ value : _q_CMicrosoft_CGraphics_CCanvas_CCanvasUnits) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Units(pThis, value))
        }
    }
    public func put_Units(value : Microsoft.Graphics.Canvas.CanvasUnits) throws -> Void {
        try self._n_put_Units(value);
    }
    // [IsSpecialName] Windows.Foundation.IReference<Microsoft.Graphics.Canvas.CanvasBufferPrecision> get_EffectBufferPrecision()
    private func _n_get_EffectBufferPrecision(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IReference_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_EffectBufferPrecision(pThis, __presult))
        }
    }
    public func get_EffectBufferPrecision() throws -> Optional<ClosedGenerics.IReference_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IReference_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision>> = nil;
        try self._n_get_EffectBufferPrecision(&__result);
        return ClosedGenerics.IReference_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision(consuming: __result);
    }
    // [IsSpecialName] void put_EffectBufferPrecision(Windows.Foundation.IReference<Microsoft.Graphics.Canvas.CanvasBufferPrecision>)
    private func _n_put_EffectBufferPrecision(_ value : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IReference_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_EffectBufferPrecision(pThis, value))
        }
    }
    public func put_EffectBufferPrecision(value : Optional<ClosedGenerics.IReference_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision>) throws -> Void {
        try self._n_put_EffectBufferPrecision(RawPointer(value));
    }
    // [IsSpecialName] Windows.Graphics.Imaging.BitmapSize get_EffectTileSize()
    private func _n_get_EffectTileSize(_ __presult: UnsafeMutablePointer<_q_CWindows_CGraphics_CImaging_CBitmapSize>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_EffectTileSize(pThis, __presult))
        }
    }
    public func get_EffectTileSize() throws -> Windows.Graphics.Imaging.BitmapSize {
        var __result : _q_CWindows_CGraphics_CImaging_CBitmapSize = _q_CWindows_CGraphics_CImaging_CBitmapSize(Width: 0, Height: 0);
        try self._n_get_EffectTileSize(&__result);
        return __result;
    }
    // [IsSpecialName] void put_EffectTileSize(Windows.Graphics.Imaging.BitmapSize)
    private func _n_put_EffectTileSize(_ value : _q_CWindows_CGraphics_CImaging_CBitmapSize) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_EffectTileSize(pThis, value))
        }
    }
    public func put_EffectTileSize(value : Windows.Graphics.Imaging.BitmapSize) throws -> Void {
        try self._n_put_EffectTileSize(value);
    }
    // Microsoft.Graphics.Canvas.CanvasActiveLayer CreateLayer(System.Single)
    private func _n_CreateLayerWithOpacity(_ opacity : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateLayerWithOpacity(pThis, opacity, __presult))
        }
    }
    public func CreateLayerWithOpacity(opacity : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasActiveLayer> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>> = nil;
        try self._n_CreateLayerWithOpacity(opacity, &__result);
        return Microsoft.Graphics.Canvas.ICanvasActiveLayer(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasActiveLayer CreateLayer(Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_CreateLayerWithOpacityBrush(_ opacityBrush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateLayerWithOpacityBrush(pThis, opacityBrush, __presult))
        }
    }
    public func CreateLayerWithOpacityBrush(opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasActiveLayer> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>> = nil;
        try self._n_CreateLayerWithOpacityBrush(RawPointer(opacityBrush), &__result);
        return Microsoft.Graphics.Canvas.ICanvasActiveLayer(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasActiveLayer CreateLayer(System.Single, Windows.Foundation.Rect)
    private func _n_CreateLayerWithOpacityAndClipRectangle(_ opacity : FLOAT, _ clipRectangle : _q_CWindows_CFoundation_CRect, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateLayerWithOpacityAndClipRectangle(pThis, opacity, clipRectangle, __presult))
        }
    }
    public func CreateLayerWithOpacityAndClipRectangle(opacity : Swift.Float, clipRectangle : Windows.Foundation.Rect) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasActiveLayer> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>> = nil;
        try self._n_CreateLayerWithOpacityAndClipRectangle(opacity, clipRectangle, &__result);
        return Microsoft.Graphics.Canvas.ICanvasActiveLayer(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasActiveLayer CreateLayer(Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Windows.Foundation.Rect)
    private func _n_CreateLayerWithOpacityBrushAndClipRectangle(_ opacityBrush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ clipRectangle : _q_CWindows_CFoundation_CRect, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateLayerWithOpacityBrushAndClipRectangle(pThis, opacityBrush, clipRectangle, __presult))
        }
    }
    public func CreateLayerWithOpacityBrushAndClipRectangle(opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, clipRectangle : Windows.Foundation.Rect) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasActiveLayer> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>> = nil;
        try self._n_CreateLayerWithOpacityBrushAndClipRectangle(RawPointer(opacityBrush), clipRectangle, &__result);
        return Microsoft.Graphics.Canvas.ICanvasActiveLayer(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasActiveLayer CreateLayer(System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasGeometry)
    private func _n_CreateLayerWithOpacityAndClipGeometry(_ opacity : FLOAT, _ clipGeometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateLayerWithOpacityAndClipGeometry(pThis, opacity, clipGeometry, __presult))
        }
    }
    public func CreateLayerWithOpacityAndClipGeometry(opacity : Swift.Float, clipGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasActiveLayer> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>> = nil;
        try self._n_CreateLayerWithOpacityAndClipGeometry(opacity, RawPointer(clipGeometry), &__result);
        return Microsoft.Graphics.Canvas.ICanvasActiveLayer(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasActiveLayer CreateLayer(Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Microsoft.Graphics.Canvas.Geometry.CanvasGeometry)
    private func _n_CreateLayerWithOpacityBrushAndClipGeometry(_ opacityBrush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ clipGeometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateLayerWithOpacityBrushAndClipGeometry(pThis, opacityBrush, clipGeometry, __presult))
        }
    }
    public func CreateLayerWithOpacityBrushAndClipGeometry(opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, clipGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasActiveLayer> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>> = nil;
        try self._n_CreateLayerWithOpacityBrushAndClipGeometry(RawPointer(opacityBrush), RawPointer(clipGeometry), &__result);
        return Microsoft.Graphics.Canvas.ICanvasActiveLayer(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasActiveLayer CreateLayer(System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Matrix3x2)
    private func _n_CreateLayerWithOpacityAndClipGeometryAndTransform(_ opacity : FLOAT, _ clipGeometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ geometryTransform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateLayerWithOpacityAndClipGeometryAndTransform(pThis, opacity, clipGeometry, geometryTransform, __presult))
        }
    }
    public func CreateLayerWithOpacityAndClipGeometryAndTransform(opacity : Swift.Float, clipGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, geometryTransform : Windows.Foundation.Numerics.Matrix3x2) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasActiveLayer> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>> = nil;
        try self._n_CreateLayerWithOpacityAndClipGeometryAndTransform(opacity, RawPointer(clipGeometry), geometryTransform, &__result);
        return Microsoft.Graphics.Canvas.ICanvasActiveLayer(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasActiveLayer CreateLayer(Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Matrix3x2)
    private func _n_CreateLayerWithOpacityBrushAndClipGeometryAndTransform(_ opacityBrush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ clipGeometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ geometryTransform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateLayerWithOpacityBrushAndClipGeometryAndTransform(pThis, opacityBrush, clipGeometry, geometryTransform, __presult))
        }
    }
    public func CreateLayerWithOpacityBrushAndClipGeometryAndTransform(opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, clipGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, geometryTransform : Windows.Foundation.Numerics.Matrix3x2) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasActiveLayer> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>> = nil;
        try self._n_CreateLayerWithOpacityBrushAndClipGeometryAndTransform(RawPointer(opacityBrush), RawPointer(clipGeometry), geometryTransform, &__result);
        return Microsoft.Graphics.Canvas.ICanvasActiveLayer(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasActiveLayer CreateLayer(System.Single, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Windows.Foundation.Rect, Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Matrix3x2, Microsoft.Graphics.Canvas.CanvasLayerOptions)
    private func _n_CreateLayerWithAllOptions(_ opacity : FLOAT, _ opacityBrush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ clipRectangle : _q_CWindows_CFoundation_CRect, _ clipGeometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ geometryTransform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ options : _q_CMicrosoft_CGraphics_CCanvas_CCanvasLayerOptions, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateLayerWithAllOptions(pThis, opacity, opacityBrush, clipRectangle, clipGeometry, geometryTransform, options, __presult))
        }
    }
    public func CreateLayerWithAllOptions(opacity : Swift.Float, opacityBrush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, clipRectangle : Windows.Foundation.Rect, clipGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, geometryTransform : Windows.Foundation.Numerics.Matrix3x2, options : Microsoft.Graphics.Canvas.CanvasLayerOptions) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasActiveLayer> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasActiveLayer>> = nil;
        try self._n_CreateLayerWithAllOptions(opacity, RawPointer(opacityBrush), clipRectangle, RawPointer(clipGeometry), geometryTransform, options, &__result);
        return Microsoft.Graphics.Canvas.ICanvasActiveLayer(consuming: __result);
    }
    // void DrawGlyphRun(Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Text.CanvasFontFace, System.Single, Microsoft.Graphics.Canvas.Text.CanvasGlyph[], bool, System.UInt32, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush)
    private func _n_DrawGlyphRun(_ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ fontFace : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasFontFace>>, _ fontSize : FLOAT, _ glyphsLength : UINT32, _ glyphs : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasGlyph>>, _ isSideways : boolean, _ bidiLevel : UINT32, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGlyphRun(pThis, point, fontFace, fontSize, glyphsLength, glyphs, isSideways, bidiLevel, brush))
        }
    }
    public func DrawGlyphRun(point : Windows.Foundation.Numerics.Vector2, fontFace : Optional<Microsoft.Graphics.Canvas.Text.ICanvasFontFace>, fontSize : Swift.Float, glyphsLength : UINT32, glyphs : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasGlyph>>, isSideways : boolean, bidiLevel : Swift.UInt32, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>) throws -> Void {
        try self._n_DrawGlyphRun(point, RawPointer(fontFace), fontSize, glyphsLength, glyphs, isSideways, bidiLevel, RawPointer(brush));
    }
    // void DrawGlyphRun(Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Text.CanvasFontFace, System.Single, Microsoft.Graphics.Canvas.Text.CanvasGlyph[], bool, System.UInt32, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Microsoft.Graphics.Canvas.Text.CanvasTextMeasuringMode)
    private func _n_DrawGlyphRunWithMeasuringMode(_ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ fontFace : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasFontFace>>, _ fontSize : FLOAT, _ glyphsLength : UINT32, _ glyphs : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasGlyph>>, _ isSideways : boolean, _ bidiLevel : UINT32, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ measuringMode : _q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasTextMeasuringMode) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGlyphRunWithMeasuringMode(pThis, point, fontFace, fontSize, glyphsLength, glyphs, isSideways, bidiLevel, brush, measuringMode))
        }
    }
    public func DrawGlyphRunWithMeasuringMode(point : Windows.Foundation.Numerics.Vector2, fontFace : Optional<Microsoft.Graphics.Canvas.Text.ICanvasFontFace>, fontSize : Swift.Float, glyphsLength : UINT32, glyphs : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasGlyph>>, isSideways : boolean, bidiLevel : Swift.UInt32, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, measuringMode : Microsoft.Graphics.Canvas.Text.CanvasTextMeasuringMode) throws -> Void {
        try self._n_DrawGlyphRunWithMeasuringMode(point, RawPointer(fontFace), fontSize, glyphsLength, glyphs, isSideways, bidiLevel, RawPointer(brush), measuringMode);
    }
    // void DrawGlyphRun(Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Text.CanvasFontFace, System.Single, Microsoft.Graphics.Canvas.Text.CanvasGlyph[], bool, System.UInt32, Microsoft.Graphics.Canvas.Brushes.ICanvasBrush, Microsoft.Graphics.Canvas.Text.CanvasTextMeasuringMode, System.String, System.String, System.Int32[], System.UInt32)
    private func _n_DrawGlyphRunWithMeasuringModeAndDescription(_ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ fontFace : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasFontFace>>, _ fontSize : FLOAT, _ glyphsLength : UINT32, _ glyphs : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasGlyph>>, _ isSideways : boolean, _ bidiLevel : UINT32, _ brush : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CBrushes_CICanvasBrush>>, _ measuringMode : _q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasTextMeasuringMode, _ localeName : Optional<HSTRING>, _ textString : Optional<HSTRING>, _ clusterMapIndicesLength : UINT32, _ clusterMapIndices : Optional<UnsafeMutablePointer<INT32>>, _ textPosition : UINT32) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawGlyphRunWithMeasuringModeAndDescription(pThis, point, fontFace, fontSize, glyphsLength, glyphs, isSideways, bidiLevel, brush, measuringMode, localeName, textString, clusterMapIndicesLength, clusterMapIndices, textPosition))
        }
    }
    public func DrawGlyphRunWithMeasuringModeAndDescription(point : Windows.Foundation.Numerics.Vector2, fontFace : Optional<Microsoft.Graphics.Canvas.Text.ICanvasFontFace>, fontSize : Swift.Float, glyphsLength : UINT32, glyphs : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasGlyph>>, isSideways : boolean, bidiLevel : Swift.UInt32, brush : Optional<Microsoft.Graphics.Canvas.Brushes.ICanvasBrush>, measuringMode : Microsoft.Graphics.Canvas.Text.CanvasTextMeasuringMode, localeName : Optional<Swift.String>, textString : Optional<Swift.String>, clusterMapIndicesLength : UINT32, clusterMapIndices : Optional<UnsafeMutablePointer<INT32>>, textPosition : Swift.UInt32) throws -> Void {
        let __hstr_localeName = try HString(localeName!);
        return try withExtendedLifetime(__hstr_localeName) {
        let __hstr_textString = try HString(textString!);
        return try withExtendedLifetime(__hstr_textString) {
        try self._n_DrawGlyphRunWithMeasuringModeAndDescription(point, RawPointer(fontFace), fontSize, glyphsLength, glyphs, isSideways, bidiLevel, RawPointer(brush), measuringMode, __hstr_localeName.Raw(), __hstr_textString.Raw(), clusterMapIndicesLength, clusterMapIndices, textPosition);
        }
        }
    }
    // Microsoft.Graphics.Canvas.CanvasSpriteBatch CreateSpriteBatch()
    private func _n_CreateSpriteBatch(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateSpriteBatch(pThis, __presult))
        }
    }
    public func CreateSpriteBatch() throws -> Optional<Microsoft.Graphics.Canvas.ICanvasSpriteBatch> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch>> = nil;
        try self._n_CreateSpriteBatch(&__result);
        return Microsoft.Graphics.Canvas.ICanvasSpriteBatch(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasSpriteBatch CreateSpriteBatch(Microsoft.Graphics.Canvas.CanvasSpriteSortMode)
    private func _n_CreateSpriteBatchWithSortMode(_ sortMode : _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteSortMode, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateSpriteBatchWithSortMode(pThis, sortMode, __presult))
        }
    }
    public func CreateSpriteBatchWithSortMode(sortMode : Microsoft.Graphics.Canvas.CanvasSpriteSortMode) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasSpriteBatch> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch>> = nil;
        try self._n_CreateSpriteBatchWithSortMode(sortMode, &__result);
        return Microsoft.Graphics.Canvas.ICanvasSpriteBatch(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasSpriteBatch CreateSpriteBatch(Microsoft.Graphics.Canvas.CanvasSpriteSortMode, Microsoft.Graphics.Canvas.CanvasImageInterpolation)
    private func _n_CreateSpriteBatchWithSortModeAndInterpolation(_ sortMode : _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteSortMode, _ interpolation : _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateSpriteBatchWithSortModeAndInterpolation(pThis, sortMode, interpolation, __presult))
        }
    }
    public func CreateSpriteBatchWithSortModeAndInterpolation(sortMode : Microsoft.Graphics.Canvas.CanvasSpriteSortMode, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasSpriteBatch> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch>> = nil;
        try self._n_CreateSpriteBatchWithSortModeAndInterpolation(sortMode, interpolation, &__result);
        return Microsoft.Graphics.Canvas.ICanvasSpriteBatch(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasSpriteBatch CreateSpriteBatch(Microsoft.Graphics.Canvas.CanvasSpriteSortMode, Microsoft.Graphics.Canvas.CanvasImageInterpolation, Microsoft.Graphics.Canvas.CanvasSpriteOptions)
    private func _n_CreateSpriteBatchWithSortModeAndInterpolationAndOptions(_ sortMode : _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteSortMode, _ interpolation : _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation, _ options : _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteOptions, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateSpriteBatchWithSortModeAndInterpolationAndOptions(pThis, sortMode, interpolation, options, __presult))
        }
    }
    public func CreateSpriteBatchWithSortModeAndInterpolationAndOptions(sortMode : Microsoft.Graphics.Canvas.CanvasSpriteSortMode, interpolation : Microsoft.Graphics.Canvas.CanvasImageInterpolation, options : Microsoft.Graphics.Canvas.CanvasSpriteOptions) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasSpriteBatch> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch>> = nil;
        try self._n_CreateSpriteBatchWithSortModeAndInterpolationAndOptions(sortMode, interpolation, options, &__result);
        return Microsoft.Graphics.Canvas.ICanvasSpriteBatch(consuming: __result);
    }
    public var Antialiasing : Microsoft.Graphics.Canvas.CanvasAntialiasing {
        get throws {
            return try get_Antialiasing();
        }
    }
    public var Blend : Microsoft.Graphics.Canvas.CanvasBlend {
        get throws {
            return try get_Blend();
        }
    }
    public var EffectBufferPrecision : Optional<ClosedGenerics.IReference_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision> {
        get throws {
            return try get_EffectBufferPrecision();
        }
    }
    public var EffectTileSize : Windows.Graphics.Imaging.BitmapSize {
        get throws {
            return try get_EffectTileSize();
        }
    }
    public var TextAntialiasing : Microsoft.Graphics.Canvas.Text.CanvasTextAntialiasing {
        get throws {
            return try get_TextAntialiasing();
        }
    }
    public var TextRenderingParameters : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextRenderingParameters> {
        get throws {
            return try get_TextRenderingParameters();
        }
    }
    public var Transform : Windows.Foundation.Numerics.Matrix3x2 {
        get throws {
            return try get_Transform();
        }
    }
    public var Units : Microsoft.Graphics.Canvas.CanvasUnits {
        get throws {
            return try get_Units();
        }
    }
} // ICanvasDrawingSession


// type: Microsoft.Graphics.Canvas.ICanvasImage
// interface type
open class ICanvasImage
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x794966d3, Data2: 0x6a64, Data3 : 0x47e9, Data4 : (0x8d, 0xa8, 0xb4, 0x6a, 0xaa, 0x24, 0xd5, 0x3b)) }
    // Windows.Foundation.Rect GetBounds(Microsoft.Graphics.Canvas.ICanvasResourceCreator)
    private func _n_GetBounds(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CRect>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasImage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetBounds(pThis, resourceCreator, __presult))
        }
    }
    public func GetBounds(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>) throws -> Windows.Foundation.Rect {
        var __result : _q_CWindows_CFoundation_CRect = _q_CWindows_CFoundation_CRect(X: 0, Y: 0, Width: 0, Height: 0);
        try self._n_GetBounds(RawPointer(resourceCreator), &__result);
        return __result;
    }
    // Windows.Foundation.Rect GetBounds(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Numerics.Matrix3x2)
    private func _n_GetBoundsWithTransform(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CRect>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasImage.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetBoundsWithTransform(pThis, resourceCreator, transform, __presult))
        }
    }
    public func GetBoundsWithTransform(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, transform : Windows.Foundation.Numerics.Matrix3x2) throws -> Windows.Foundation.Rect {
        var __result : _q_CWindows_CFoundation_CRect = _q_CWindows_CFoundation_CRect(X: 0, Y: 0, Width: 0, Height: 0);
        try self._n_GetBoundsWithTransform(RawPointer(resourceCreator), transform, &__result);
        return __result;
    }
} // ICanvasImage


// type: Microsoft.Graphics.Canvas.ICanvasImageStatics
// interface type
open class ICanvasImageStatics
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xc54eea15, Data2: 0x5a14, Data3 : 0x489a, Data4 : (0x8f, 0xa0, 0x6e, 0x84, 0x54, 0x1f, 0x92, 0x2d)) }
    // Windows.Foundation.IAsyncAction SaveAsync(Microsoft.Graphics.Canvas.ICanvasImage, Windows.Foundation.Rect, System.Single, Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Storage.Streams.IRandomAccessStream, Microsoft.Graphics.Canvas.CanvasBitmapFileFormat)
    private func _n_SaveAsync(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ dpi : FLOAT, _ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ stream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIRandomAccessStream>>, _ fileFormat : _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasImageStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SaveAsync(pThis, image, sourceRectangle, dpi, resourceCreator, stream, fileFormat, __presult))
        }
    }
    public func SaveAsync(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, dpi : Swift.Float, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat) throws -> Optional<Windows.Foundation.IAsyncAction> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>> = nil;
        try self._n_SaveAsync(RawPointer(image), sourceRectangle, dpi, RawPointer(resourceCreator), RawPointer(stream), fileFormat, &__result);
        return Windows.Foundation.IAsyncAction(consuming: __result);
    }
    public func Save(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, dpi : Swift.Float, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.SaveAsync(image: image, sourceRectangle: sourceRectangle, dpi: dpi, resourceCreator: resourceCreator, stream: stream, fileFormat: fileFormat)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncAction SaveAsync(Microsoft.Graphics.Canvas.ICanvasImage, Windows.Foundation.Rect, System.Single, Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Storage.Streams.IRandomAccessStream, Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, System.Single)
    private func _n_SaveWithQualityAsync(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ dpi : FLOAT, _ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ stream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIRandomAccessStream>>, _ fileFormat : _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat, _ quality : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasImageStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SaveWithQualityAsync(pThis, image, sourceRectangle, dpi, resourceCreator, stream, fileFormat, quality, __presult))
        }
    }
    public func SaveWithQualityAsync(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, dpi : Swift.Float, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float) throws -> Optional<Windows.Foundation.IAsyncAction> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>> = nil;
        try self._n_SaveWithQualityAsync(RawPointer(image), sourceRectangle, dpi, RawPointer(resourceCreator), RawPointer(stream), fileFormat, quality, &__result);
        return Windows.Foundation.IAsyncAction(consuming: __result);
    }
    public func SaveWithQuality(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, dpi : Swift.Float, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.SaveWithQualityAsync(image: image, sourceRectangle: sourceRectangle, dpi: dpi, resourceCreator: resourceCreator, stream: stream, fileFormat: fileFormat, quality: quality)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncAction SaveAsync(Microsoft.Graphics.Canvas.ICanvasImage, Windows.Foundation.Rect, System.Single, Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Storage.Streams.IRandomAccessStream, Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, System.Single, Microsoft.Graphics.Canvas.CanvasBufferPrecision)
    private func _n_SaveWithQualityAndBufferPrecisionAsync(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ dpi : FLOAT, _ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ stream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIRandomAccessStream>>, _ fileFormat : _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat, _ quality : FLOAT, _ bufferPrecision : _q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasImageStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SaveWithQualityAndBufferPrecisionAsync(pThis, image, sourceRectangle, dpi, resourceCreator, stream, fileFormat, quality, bufferPrecision, __presult))
        }
    }
    public func SaveWithQualityAndBufferPrecisionAsync(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, dpi : Swift.Float, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float, bufferPrecision : Microsoft.Graphics.Canvas.CanvasBufferPrecision) throws -> Optional<Windows.Foundation.IAsyncAction> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>> = nil;
        try self._n_SaveWithQualityAndBufferPrecisionAsync(RawPointer(image), sourceRectangle, dpi, RawPointer(resourceCreator), RawPointer(stream), fileFormat, quality, bufferPrecision, &__result);
        return Windows.Foundation.IAsyncAction(consuming: __result);
    }
    public func SaveWithQualityAndBufferPrecision(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, dpi : Swift.Float, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, fileFormat : Microsoft.Graphics.Canvas.CanvasBitmapFileFormat, quality : Swift.Float, bufferPrecision : Microsoft.Graphics.Canvas.CanvasBufferPrecision) async throws -> Void {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.SaveWithQualityAndBufferPrecisionAsync(image: image, sourceRectangle: sourceRectangle, dpi: dpi, resourceCreator: resourceCreator, stream: stream, fileFormat: fileFormat, quality: quality, bufferPrecision: bufferPrecision)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // System.Single[] ComputeHistogram(Microsoft.Graphics.Canvas.ICanvasImage, Windows.Foundation.Rect, Microsoft.Graphics.Canvas.ICanvasResourceCreator, Microsoft.Graphics.Canvas.Effects.EffectChannelSelect, System.Int32)
    private func _n_ComputeHistogram(_ image : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasImage>>, _ sourceRectangle : _q_CWindows_CFoundation_CRect, _ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ channelSelect : _q_CMicrosoft_CGraphics_CCanvas_CEffects_CEffectChannelSelect, _ numberOfBins : INT32, _ __presultLength: UnsafeMutablePointer<UINT32>?, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<FLOAT>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasImageStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputeHistogram(pThis, image, sourceRectangle, resourceCreator, channelSelect, numberOfBins, __presultLength, __presult))
        }
    }
    public func ComputeHistogram(image : Optional<Microsoft.Graphics.Canvas.ICanvasImage>, sourceRectangle : Windows.Foundation.Rect, resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, channelSelect : Microsoft.Graphics.Canvas.Effects.EffectChannelSelect, numberOfBins : Swift.Int32) throws -> UINT32 {
        var __resultLength : UINT32 = 0;
        var __result : Optional<UnsafeMutablePointer<FLOAT>> = nil;
        try self._n_ComputeHistogram(RawPointer(image), sourceRectangle, RawPointer(resourceCreator), channelSelect, numberOfBins, &__resultLength, &__result);
        return __resultLength;
    }
    // bool IsHistogramSupported(Microsoft.Graphics.Canvas.CanvasDevice)
    private func _n_IsHistogramSupported(_ device : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>>, _ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasImageStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IsHistogramSupported(pThis, device, __presult))
        }
    }
    public func IsHistogramSupported(device : Optional<Microsoft.Graphics.Canvas.ICanvasDevice>) throws -> boolean {
        var __result : boolean = 0;
        try self._n_IsHistogramSupported(RawPointer(device), &__result);
        return __result;
    }
} // ICanvasImageStatics


// type: Microsoft.Graphics.Canvas.ICanvasLock
// interface type
open class ICanvasLock
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x7a0e8498, Data2: 0xfba9, Data3 : 0x4fb0, Data4 : (0xaa, 0x8c, 0x6a, 0x48, 0xb5, 0xee, 0x3e, 0x4f)) }
} // ICanvasLock


// type: Microsoft.Graphics.Canvas.ICanvasRenderTarget
// interface type
open class ICanvasRenderTarget
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x2d4c7349, Data2: 0x9a32, Data3 : 0x41b9, Data4 : (0xb3, 0xcc, 0xca, 0xf1, 0xb7, 0xe1, 0x09, 0x9b)) }
    // Microsoft.Graphics.Canvas.CanvasDrawingSession CreateDrawingSession()
    private func _n_CreateDrawingSession(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasRenderTarget.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateDrawingSession(pThis, __presult))
        }
    }
    public func CreateDrawingSession() throws -> Optional<Microsoft.Graphics.Canvas.ICanvasDrawingSession> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession>> = nil;
        try self._n_CreateDrawingSession(&__result);
        return Microsoft.Graphics.Canvas.ICanvasDrawingSession(consuming: __result);
    }
} // ICanvasRenderTarget


// type: Microsoft.Graphics.Canvas.ICanvasRenderTargetFactory
// interface type
// ACTIVATION INTERFACE
open class ICanvasRenderTargetFactory
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x620dfdbb, Data2: 0x9d08, Data3 : 0x406c, Data4 : (0xbf, 0xe6, 0xd9, 0xb8, 0x1e, 0x6d, 0xf8, 0xe7)) }
    // Microsoft.Graphics.Canvas.CanvasRenderTarget CreateWithSize(Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi, Windows.Foundation.Size)
    private func _n_CreateWithSize(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreatorWithDpi>>, _ size : _q_CWindows_CFoundation_CSize, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasRenderTarget>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasRenderTargetFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateWithSize(pThis, resourceCreator, size, __presult))
        }
    }
    public func CreateWithSize(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi>, size : Windows.Foundation.Size) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasRenderTarget> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasRenderTarget>> = nil;
        try self._n_CreateWithSize(RawPointer(resourceCreator), size, &__result);
        return Microsoft.Graphics.Canvas.ICanvasRenderTarget(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasRenderTarget CreateWithWidthAndHeight(Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi, System.Single, System.Single)
    private func _n_CreateWithWidthAndHeight(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreatorWithDpi>>, _ width : FLOAT, _ height : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasRenderTarget>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasRenderTargetFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateWithWidthAndHeight(pThis, resourceCreator, width, height, __presult))
        }
    }
    public func CreateWithWidthAndHeight(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi>, width : Swift.Float, height : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasRenderTarget> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasRenderTarget>> = nil;
        try self._n_CreateWithWidthAndHeight(RawPointer(resourceCreator), width, height, &__result);
        return Microsoft.Graphics.Canvas.ICanvasRenderTarget(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasRenderTarget CreateWithWidthAndHeightAndDpi(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.Single, System.Single, System.Single)
    private func _n_CreateWithWidthAndHeightAndDpi(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ width : FLOAT, _ height : FLOAT, _ dpi : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasRenderTarget>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasRenderTargetFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateWithWidthAndHeightAndDpi(pThis, resourceCreator, width, height, dpi, __presult))
        }
    }
    public func CreateWithWidthAndHeightAndDpi(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, width : Swift.Float, height : Swift.Float, dpi : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasRenderTarget> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasRenderTarget>> = nil;
        try self._n_CreateWithWidthAndHeightAndDpi(RawPointer(resourceCreator), width, height, dpi, &__result);
        return Microsoft.Graphics.Canvas.ICanvasRenderTarget(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasRenderTarget CreateWithWidthAndHeightAndDpiAndFormatAndAlpha(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.Single, System.Single, System.Single, Windows.Graphics.DirectX.DirectXPixelFormat, Microsoft.Graphics.Canvas.CanvasAlphaMode)
    private func _n_CreateWithWidthAndHeightAndDpiAndFormatAndAlpha(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ width : FLOAT, _ height : FLOAT, _ dpi : FLOAT, _ format : _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat, _ alpha : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasRenderTarget>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasRenderTargetFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateWithWidthAndHeightAndDpiAndFormatAndAlpha(pThis, resourceCreator, width, height, dpi, format, alpha, __presult))
        }
    }
    public func CreateWithWidthAndHeightAndDpiAndFormatAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, width : Swift.Float, height : Swift.Float, dpi : Swift.Float, format : Windows.Graphics.DirectX.DirectXPixelFormat, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasRenderTarget> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasRenderTarget>> = nil;
        try self._n_CreateWithWidthAndHeightAndDpiAndFormatAndAlpha(RawPointer(resourceCreator), width, height, dpi, format, alpha, &__result);
        return Microsoft.Graphics.Canvas.ICanvasRenderTarget(consuming: __result);
    }
} // ICanvasRenderTargetFactory


// type: Microsoft.Graphics.Canvas.ICanvasRenderTargetStatics
// interface type
open class ICanvasRenderTargetStatics
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xc7d1fe37, Data2: 0xdd57, Data3 : 0x45d7, Data4 : (0xbc, 0xc1, 0x15, 0x62, 0x5a, 0x21, 0xe8, 0xd5)) }
// method not needed: CreateFromDirect3D11Surface
// method not needed: CreateFromDirect3D11SurfaceWithDpi
// method not needed: CreateFromDirect3D11SurfaceWithDpiAndAlpha
} // ICanvasRenderTargetStatics


// type: Microsoft.Graphics.Canvas.ICanvasResourceCreator
// interface type
open class ICanvasResourceCreator
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x8f6d8aa8, Data2: 0x492f, Data3 : 0x4bc6, Data4 : (0xb3, 0xd0, 0xe7, 0xf5, 0xea, 0xe8, 0x4b, 0x11)) }
    // [IsSpecialName] Microsoft.Graphics.Canvas.CanvasDevice get_Device()
    private func _n_get_Device(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Device(pThis, __presult))
        }
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>> = nil;
        try self._n_get_Device(&__result);
        return Microsoft.Graphics.Canvas.ICanvasDevice(consuming: __result);
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        get throws {
            return try get_Device();
        }
    }
} // ICanvasResourceCreator


// type: Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi
// interface type
open class ICanvasResourceCreatorWithDpi
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x1a75b512, Data2: 0xe9fa, Data3 : 0x49e6, Data4 : (0xa8, 0x76, 0x38, 0xca, 0xe1, 0x94, 0x01, 0x3e)) }
    // [IsSpecialName] System.Single get_Dpi()
    private func _n_get_Dpi(_ __presult: UnsafeMutablePointer<FLOAT>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreatorWithDpi.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Dpi(pThis, __presult))
        }
    }
    public func get_Dpi() throws -> Swift.Float {
        var __result : FLOAT = 0;
        try self._n_get_Dpi(&__result);
        return __result;
    }
    // System.Single ConvertPixelsToDips(System.Int32)
    private func _n_ConvertPixelsToDips(_ pixels : INT32, _ __presult: UnsafeMutablePointer<FLOAT>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreatorWithDpi.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ConvertPixelsToDips(pThis, pixels, __presult))
        }
    }
    public func ConvertPixelsToDips(pixels : Swift.Int32) throws -> Swift.Float {
        var __result : FLOAT = 0;
        try self._n_ConvertPixelsToDips(pixels, &__result);
        return __result;
    }
    // System.Int32 ConvertDipsToPixels(System.Single, Microsoft.Graphics.Canvas.CanvasDpiRounding)
    private func _n_ConvertDipsToPixels(_ dips : FLOAT, _ dpiRounding : _q_CMicrosoft_CGraphics_CCanvas_CCanvasDpiRounding, _ __presult: UnsafeMutablePointer<INT32>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreatorWithDpi.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ConvertDipsToPixels(pThis, dips, dpiRounding, __presult))
        }
    }
    public func ConvertDipsToPixels(dips : Swift.Float, dpiRounding : Microsoft.Graphics.Canvas.CanvasDpiRounding) throws -> Swift.Int32 {
        var __result : INT32 = 0;
        try self._n_ConvertDipsToPixels(dips, dpiRounding, &__result);
        return __result;
    }
    public var Dpi : Swift.Float {
        get throws {
            return try get_Dpi();
        }
    }
} // ICanvasResourceCreatorWithDpi


// type: Microsoft.Graphics.Canvas.ICanvasSpriteBatch
// interface type
open class ICanvasSpriteBatch
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xa065dce4, Data2: 0xa7f2, Data3 : 0x4df4, Data4 : (0x84, 0x05, 0xea, 0x9e, 0x3a, 0x21, 0x5b, 0xf8)) }
    // void Draw(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Rect)
    private func _n_DrawToRect(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ destRect : _q_CWindows_CFoundation_CRect) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawToRect(pThis, bitmap, destRect))
        }
    }
    public func DrawToRect(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, destRect : Windows.Foundation.Rect) throws -> Void {
        try self._n_DrawToRect(RawPointer(bitmap), destRect);
    }
    // void Draw(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Numerics.Vector2)
    private func _n_DrawAtOffset(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawAtOffset(pThis, bitmap, offset))
        }
    }
    public func DrawAtOffset(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2) throws -> Void {
        try self._n_DrawAtOffset(RawPointer(bitmap), offset);
    }
    // void Draw(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Numerics.Matrix3x2)
    private func _n_DrawWithTransform(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawWithTransform(pThis, bitmap, transform))
        }
    }
    public func DrawWithTransform(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, transform : Windows.Foundation.Numerics.Matrix3x2) throws -> Void {
        try self._n_DrawWithTransform(RawPointer(bitmap), transform);
    }
    // void Draw(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Rect, Windows.Foundation.Numerics.Vector4)
    private func _n_DrawToRectWithTint(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ destRect : _q_CWindows_CFoundation_CRect, _ tint : _q_CWindows_CFoundation_CNumerics_CVector4) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawToRectWithTint(pThis, bitmap, destRect, tint))
        }
    }
    public func DrawToRectWithTint(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, destRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4) throws -> Void {
        try self._n_DrawToRectWithTint(RawPointer(bitmap), destRect, tint);
    }
    // void Draw(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Numerics.Vector2, Windows.Foundation.Numerics.Vector4)
    private func _n_DrawAtOffsetWithTint(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ tint : _q_CWindows_CFoundation_CNumerics_CVector4) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawAtOffsetWithTint(pThis, bitmap, offset, tint))
        }
    }
    public func DrawAtOffsetWithTint(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2, tint : Windows.Foundation.Numerics.Vector4) throws -> Void {
        try self._n_DrawAtOffsetWithTint(RawPointer(bitmap), offset, tint);
    }
    // void Draw(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Numerics.Matrix3x2, Windows.Foundation.Numerics.Vector4)
    private func _n_DrawWithTransformAndTint(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ tint : _q_CWindows_CFoundation_CNumerics_CVector4) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawWithTransformAndTint(pThis, bitmap, transform, tint))
        }
    }
    public func DrawWithTransformAndTint(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, transform : Windows.Foundation.Numerics.Matrix3x2, tint : Windows.Foundation.Numerics.Vector4) throws -> Void {
        try self._n_DrawWithTransformAndTint(RawPointer(bitmap), transform, tint);
    }
    // void Draw(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Rect, Windows.Foundation.Numerics.Vector4, Microsoft.Graphics.Canvas.CanvasSpriteFlip)
    private func _n_DrawToRectWithTintAndFlip(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ destRect : _q_CWindows_CFoundation_CRect, _ tint : _q_CWindows_CFoundation_CNumerics_CVector4, _ flip : _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteFlip) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawToRectWithTintAndFlip(pThis, bitmap, destRect, tint, flip))
        }
    }
    public func DrawToRectWithTintAndFlip(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, destRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4, flip : Microsoft.Graphics.Canvas.CanvasSpriteFlip) throws -> Void {
        try self._n_DrawToRectWithTintAndFlip(RawPointer(bitmap), destRect, tint, flip);
    }
    // void Draw(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Numerics.Matrix3x2, Windows.Foundation.Numerics.Vector4, Microsoft.Graphics.Canvas.CanvasSpriteFlip)
    private func _n_DrawWithTransformAndTintAndFlip(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ tint : _q_CWindows_CFoundation_CNumerics_CVector4, _ flip : _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteFlip) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawWithTransformAndTintAndFlip(pThis, bitmap, transform, tint, flip))
        }
    }
    public func DrawWithTransformAndTintAndFlip(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, transform : Windows.Foundation.Numerics.Matrix3x2, tint : Windows.Foundation.Numerics.Vector4, flip : Microsoft.Graphics.Canvas.CanvasSpriteFlip) throws -> Void {
        try self._n_DrawWithTransformAndTintAndFlip(RawPointer(bitmap), transform, tint, flip);
    }
    // void Draw(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Numerics.Vector2, Windows.Foundation.Numerics.Vector4, Windows.Foundation.Numerics.Vector2, System.Single, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.CanvasSpriteFlip)
    private func _n_DrawAtOffsetWithTintAndTransform(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ tint : _q_CWindows_CFoundation_CNumerics_CVector4, _ origin : _q_CWindows_CFoundation_CNumerics_CVector2, _ rotation : FLOAT, _ scale : _q_CWindows_CFoundation_CNumerics_CVector2, _ flip : _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteFlip) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawAtOffsetWithTintAndTransform(pThis, bitmap, offset, tint, origin, rotation, scale, flip))
        }
    }
    public func DrawAtOffsetWithTintAndTransform(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2, tint : Windows.Foundation.Numerics.Vector4, origin : Windows.Foundation.Numerics.Vector2, rotation : Swift.Float, scale : Windows.Foundation.Numerics.Vector2, flip : Microsoft.Graphics.Canvas.CanvasSpriteFlip) throws -> Void {
        try self._n_DrawAtOffsetWithTintAndTransform(RawPointer(bitmap), offset, tint, origin, rotation, scale, flip);
    }
    // void DrawFromSpriteSheet(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Rect, Windows.Foundation.Rect)
    private func _n_DrawFromSpriteSheetToRect(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ destRect : _q_CWindows_CFoundation_CRect, _ sourceRect : _q_CWindows_CFoundation_CRect) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawFromSpriteSheetToRect(pThis, bitmap, destRect, sourceRect))
        }
    }
    public func DrawFromSpriteSheetToRect(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, destRect : Windows.Foundation.Rect, sourceRect : Windows.Foundation.Rect) throws -> Void {
        try self._n_DrawFromSpriteSheetToRect(RawPointer(bitmap), destRect, sourceRect);
    }
    // void DrawFromSpriteSheet(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Numerics.Vector2, Windows.Foundation.Rect)
    private func _n_DrawFromSpriteSheetAtOffset(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ sourceRect : _q_CWindows_CFoundation_CRect) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawFromSpriteSheetAtOffset(pThis, bitmap, offset, sourceRect))
        }
    }
    public func DrawFromSpriteSheetAtOffset(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2, sourceRect : Windows.Foundation.Rect) throws -> Void {
        try self._n_DrawFromSpriteSheetAtOffset(RawPointer(bitmap), offset, sourceRect);
    }
    // void DrawFromSpriteSheet(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Numerics.Matrix3x2, Windows.Foundation.Rect)
    private func _n_DrawFromSpriteSheetWithTransform(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ sourceRect : _q_CWindows_CFoundation_CRect) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawFromSpriteSheetWithTransform(pThis, bitmap, transform, sourceRect))
        }
    }
    public func DrawFromSpriteSheetWithTransform(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, transform : Windows.Foundation.Numerics.Matrix3x2, sourceRect : Windows.Foundation.Rect) throws -> Void {
        try self._n_DrawFromSpriteSheetWithTransform(RawPointer(bitmap), transform, sourceRect);
    }
    // void DrawFromSpriteSheet(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Rect, Windows.Foundation.Rect, Windows.Foundation.Numerics.Vector4)
    private func _n_DrawFromSpriteSheetToRectWithTint(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ destRect : _q_CWindows_CFoundation_CRect, _ sourceRect : _q_CWindows_CFoundation_CRect, _ tint : _q_CWindows_CFoundation_CNumerics_CVector4) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawFromSpriteSheetToRectWithTint(pThis, bitmap, destRect, sourceRect, tint))
        }
    }
    public func DrawFromSpriteSheetToRectWithTint(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, destRect : Windows.Foundation.Rect, sourceRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4) throws -> Void {
        try self._n_DrawFromSpriteSheetToRectWithTint(RawPointer(bitmap), destRect, sourceRect, tint);
    }
    // void DrawFromSpriteSheet(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Numerics.Vector2, Windows.Foundation.Rect, Windows.Foundation.Numerics.Vector4)
    private func _n_DrawFromSpriteSheetAtOffsetWithTint(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ sourceRect : _q_CWindows_CFoundation_CRect, _ tint : _q_CWindows_CFoundation_CNumerics_CVector4) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawFromSpriteSheetAtOffsetWithTint(pThis, bitmap, offset, sourceRect, tint))
        }
    }
    public func DrawFromSpriteSheetAtOffsetWithTint(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2, sourceRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4) throws -> Void {
        try self._n_DrawFromSpriteSheetAtOffsetWithTint(RawPointer(bitmap), offset, sourceRect, tint);
    }
    // void DrawFromSpriteSheet(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Numerics.Matrix3x2, Windows.Foundation.Rect, Windows.Foundation.Numerics.Vector4)
    private func _n_DrawFromSpriteSheetWithTransformAndTint(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ sourceRect : _q_CWindows_CFoundation_CRect, _ tint : _q_CWindows_CFoundation_CNumerics_CVector4) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawFromSpriteSheetWithTransformAndTint(pThis, bitmap, transform, sourceRect, tint))
        }
    }
    public func DrawFromSpriteSheetWithTransformAndTint(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, transform : Windows.Foundation.Numerics.Matrix3x2, sourceRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4) throws -> Void {
        try self._n_DrawFromSpriteSheetWithTransformAndTint(RawPointer(bitmap), transform, sourceRect, tint);
    }
    // void DrawFromSpriteSheet(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Rect, Windows.Foundation.Rect, Windows.Foundation.Numerics.Vector4, Microsoft.Graphics.Canvas.CanvasSpriteFlip)
    private func _n_DrawFromSpriteSheetToRectWithTintAndFlip(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ destRect : _q_CWindows_CFoundation_CRect, _ sourceRect : _q_CWindows_CFoundation_CRect, _ tint : _q_CWindows_CFoundation_CNumerics_CVector4, _ flip : _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteFlip) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawFromSpriteSheetToRectWithTintAndFlip(pThis, bitmap, destRect, sourceRect, tint, flip))
        }
    }
    public func DrawFromSpriteSheetToRectWithTintAndFlip(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, destRect : Windows.Foundation.Rect, sourceRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4, flip : Microsoft.Graphics.Canvas.CanvasSpriteFlip) throws -> Void {
        try self._n_DrawFromSpriteSheetToRectWithTintAndFlip(RawPointer(bitmap), destRect, sourceRect, tint, flip);
    }
    // void DrawFromSpriteSheet(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Numerics.Matrix3x2, Windows.Foundation.Rect, Windows.Foundation.Numerics.Vector4, Microsoft.Graphics.Canvas.CanvasSpriteFlip)
    private func _n_DrawFromSpriteSheetWithTransformAndTintAndFlip(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ sourceRect : _q_CWindows_CFoundation_CRect, _ tint : _q_CWindows_CFoundation_CNumerics_CVector4, _ flip : _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteFlip) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawFromSpriteSheetWithTransformAndTintAndFlip(pThis, bitmap, transform, sourceRect, tint, flip))
        }
    }
    public func DrawFromSpriteSheetWithTransformAndTintAndFlip(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, transform : Windows.Foundation.Numerics.Matrix3x2, sourceRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4, flip : Microsoft.Graphics.Canvas.CanvasSpriteFlip) throws -> Void {
        try self._n_DrawFromSpriteSheetWithTransformAndTintAndFlip(RawPointer(bitmap), transform, sourceRect, tint, flip);
    }
    // void DrawFromSpriteSheet(Microsoft.Graphics.Canvas.CanvasBitmap, Windows.Foundation.Numerics.Vector2, Windows.Foundation.Rect, Windows.Foundation.Numerics.Vector4, Windows.Foundation.Numerics.Vector2, System.Single, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.CanvasSpriteFlip)
    private func _n_DrawFromSpriteSheetAtOffsetWithTintAndTransform(_ bitmap : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasBitmap>>, _ offset : _q_CWindows_CFoundation_CNumerics_CVector2, _ sourceRect : _q_CWindows_CFoundation_CRect, _ tint : _q_CWindows_CFoundation_CNumerics_CVector4, _ origin : _q_CWindows_CFoundation_CNumerics_CVector2, _ rotation : FLOAT, _ scale : _q_CWindows_CFoundation_CNumerics_CVector2, _ flip : _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteFlip) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatch.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DrawFromSpriteSheetAtOffsetWithTintAndTransform(pThis, bitmap, offset, sourceRect, tint, origin, rotation, scale, flip))
        }
    }
    public func DrawFromSpriteSheetAtOffsetWithTintAndTransform(bitmap : Optional<Microsoft.Graphics.Canvas.ICanvasBitmap>, offset : Windows.Foundation.Numerics.Vector2, sourceRect : Windows.Foundation.Rect, tint : Windows.Foundation.Numerics.Vector4, origin : Windows.Foundation.Numerics.Vector2, rotation : Swift.Float, scale : Windows.Foundation.Numerics.Vector2, flip : Microsoft.Graphics.Canvas.CanvasSpriteFlip) throws -> Void {
        try self._n_DrawFromSpriteSheetAtOffsetWithTintAndTransform(RawPointer(bitmap), offset, sourceRect, tint, origin, rotation, scale, flip);
    }
} // ICanvasSpriteBatch


// type: Microsoft.Graphics.Canvas.ICanvasSpriteBatchStatics
// interface type
open class ICanvasSpriteBatchStatics
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x851eb08d, Data2: 0x9d01, Data3 : 0x4b57, Data4 : (0x9e, 0x94, 0x24, 0x11, 0x31, 0x51, 0xb7, 0x4b)) }
    // bool IsSupported(Microsoft.Graphics.Canvas.CanvasDevice)
    private func _n_IsSupported(_ device : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>>, _ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSpriteBatchStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.IsSupported(pThis, device, __presult))
        }
    }
    public func IsSupported(device : Optional<Microsoft.Graphics.Canvas.ICanvasDevice>) throws -> boolean {
        var __result : boolean = 0;
        try self._n_IsSupported(RawPointer(device), &__result);
        return __result;
    }
} // ICanvasSpriteBatchStatics


// type: Microsoft.Graphics.Canvas.ICanvasSwapChain
// interface type
open class ICanvasSwapChain
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x882e3c3a, Data2: 0x5725, Data3 : 0x409c, Data4 : (0x9e, 0x76, 0xf8, 0x0b, 0x3b, 0xac, 0xf1, 0xb4)) }
    // void Present()
    private func _n_Present() throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Present(pThis))
        }
    }
    public func Present() throws -> Void {
        try self._n_Present();
    }
    // void Present(System.Int32)
    private func _n_PresentWithSyncInterval(_ syncInterval : INT32) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.PresentWithSyncInterval(pThis, syncInterval))
        }
    }
    public func PresentWithSyncInterval(syncInterval : Swift.Int32) throws -> Void {
        try self._n_PresentWithSyncInterval(syncInterval);
    }
    // void ResizeBuffers(Windows.Foundation.Size)
    private func _n_ResizeBuffersWithSize(_ newSize : _q_CWindows_CFoundation_CSize) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ResizeBuffersWithSize(pThis, newSize))
        }
    }
    public func ResizeBuffersWithSize(newSize : Windows.Foundation.Size) throws -> Void {
        try self._n_ResizeBuffersWithSize(newSize);
    }
    // void ResizeBuffers(System.Single, System.Single)
    private func _n_ResizeBuffersWithWidthAndHeight(_ newWidth : FLOAT, _ newHeight : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ResizeBuffersWithWidthAndHeight(pThis, newWidth, newHeight))
        }
    }
    public func ResizeBuffersWithWidthAndHeight(newWidth : Swift.Float, newHeight : Swift.Float) throws -> Void {
        try self._n_ResizeBuffersWithWidthAndHeight(newWidth, newHeight);
    }
    // void ResizeBuffers(System.Single, System.Single, System.Single)
    private func _n_ResizeBuffersWithWidthAndHeightAndDpi(_ newWidth : FLOAT, _ newHeight : FLOAT, _ newDpi : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ResizeBuffersWithWidthAndHeightAndDpi(pThis, newWidth, newHeight, newDpi))
        }
    }
    public func ResizeBuffersWithWidthAndHeightAndDpi(newWidth : Swift.Float, newHeight : Swift.Float, newDpi : Swift.Float) throws -> Void {
        try self._n_ResizeBuffersWithWidthAndHeightAndDpi(newWidth, newHeight, newDpi);
    }
    // void ResizeBuffers(System.Single, System.Single, System.Single, Windows.Graphics.DirectX.DirectXPixelFormat, System.Int32)
    private func _n_ResizeBuffersWithAllOptions(_ newWidth : FLOAT, _ newHeight : FLOAT, _ newDpi : FLOAT, _ newFormat : _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat, _ bufferCount : INT32) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ResizeBuffersWithAllOptions(pThis, newWidth, newHeight, newDpi, newFormat, bufferCount))
        }
    }
    public func ResizeBuffersWithAllOptions(newWidth : Swift.Float, newHeight : Swift.Float, newDpi : Swift.Float, newFormat : Windows.Graphics.DirectX.DirectXPixelFormat, bufferCount : Swift.Int32) throws -> Void {
        try self._n_ResizeBuffersWithAllOptions(newWidth, newHeight, newDpi, newFormat, bufferCount);
    }
    // [IsSpecialName] Windows.Foundation.Size get_Size()
    private func _n_get_Size(_ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CSize>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, __presult))
        }
    }
    public func get_Size() throws -> Windows.Foundation.Size {
        var __result : _q_CWindows_CFoundation_CSize = _q_CWindows_CFoundation_CSize(Width: 0, Height: 0);
        try self._n_get_Size(&__result);
        return __result;
    }
    // [IsSpecialName] Windows.Graphics.Imaging.BitmapSize get_SizeInPixels()
    private func _n_get_SizeInPixels(_ __presult: UnsafeMutablePointer<_q_CWindows_CGraphics_CImaging_CBitmapSize>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_SizeInPixels(pThis, __presult))
        }
    }
    public func get_SizeInPixels() throws -> Windows.Graphics.Imaging.BitmapSize {
        var __result : _q_CWindows_CGraphics_CImaging_CBitmapSize = _q_CWindows_CGraphics_CImaging_CBitmapSize(Width: 0, Height: 0);
        try self._n_get_SizeInPixels(&__result);
        return __result;
    }
    // [IsSpecialName] Windows.Graphics.DirectX.DirectXPixelFormat get_Format()
    private func _n_get_Format(_ __presult: UnsafeMutablePointer<_q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Format(pThis, __presult))
        }
    }
    public func get_Format() throws -> Windows.Graphics.DirectX.DirectXPixelFormat {
        var __result : _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat = _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat_Unknown;
        try self._n_get_Format(&__result);
        return __result;
    }
    // [IsSpecialName] System.Int32 get_BufferCount()
    private func _n_get_BufferCount(_ __presult: UnsafeMutablePointer<INT32>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_BufferCount(pThis, __presult))
        }
    }
    public func get_BufferCount() throws -> Swift.Int32 {
        var __result : INT32 = 0;
        try self._n_get_BufferCount(&__result);
        return __result;
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.CanvasAlphaMode get_AlphaMode()
    private func _n_get_AlphaMode(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_AlphaMode(pThis, __presult))
        }
    }
    public func get_AlphaMode() throws -> Microsoft.Graphics.Canvas.CanvasAlphaMode {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode = _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode_Premultiplied;
        try self._n_get_AlphaMode(&__result);
        return __result;
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.CanvasSwapChainRotation get_Rotation()
    private func _n_get_Rotation(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CCanvasSwapChainRotation>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Rotation(pThis, __presult))
        }
    }
    public func get_Rotation() throws -> Microsoft.Graphics.Canvas.CanvasSwapChainRotation {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CCanvasSwapChainRotation = _q_CMicrosoft_CGraphics_CCanvas_CCanvasSwapChainRotation_None;
        try self._n_get_Rotation(&__result);
        return __result;
    }
    // [IsSpecialName] void put_Rotation(Microsoft.Graphics.Canvas.CanvasSwapChainRotation)
    private func _n_put_Rotation(_ value : _q_CMicrosoft_CGraphics_CCanvas_CCanvasSwapChainRotation) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Rotation(pThis, value))
        }
    }
    public func put_Rotation(value : Microsoft.Graphics.Canvas.CanvasSwapChainRotation) throws -> Void {
        try self._n_put_Rotation(value);
    }
    // [IsSpecialName] Windows.Foundation.Size get_SourceSize()
    private func _n_get_SourceSize(_ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CSize>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_SourceSize(pThis, __presult))
        }
    }
    public func get_SourceSize() throws -> Windows.Foundation.Size {
        var __result : _q_CWindows_CFoundation_CSize = _q_CWindows_CFoundation_CSize(Width: 0, Height: 0);
        try self._n_get_SourceSize(&__result);
        return __result;
    }
    // [IsSpecialName] void put_SourceSize(Windows.Foundation.Size)
    private func _n_put_SourceSize(_ value : _q_CWindows_CFoundation_CSize) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_SourceSize(pThis, value))
        }
    }
    public func put_SourceSize(value : Windows.Foundation.Size) throws -> Void {
        try self._n_put_SourceSize(value);
    }
    // [IsSpecialName] Windows.Foundation.Numerics.Matrix3x2 get_TransformMatrix()
    private func _n_get_TransformMatrix(_ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CMatrix3x2>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_TransformMatrix(pThis, __presult))
        }
    }
    public func get_TransformMatrix() throws -> Windows.Foundation.Numerics.Matrix3x2 {
        var __result : _q_CWindows_CFoundation_CNumerics_CMatrix3x2 = _q_CWindows_CFoundation_CNumerics_CMatrix3x2(M11: 0, M12: 0, M21: 0, M22: 0, M31: 0, M32: 0);
        try self._n_get_TransformMatrix(&__result);
        return __result;
    }
    // [IsSpecialName] void put_TransformMatrix(Windows.Foundation.Numerics.Matrix3x2)
    private func _n_put_TransformMatrix(_ value : _q_CWindows_CFoundation_CNumerics_CMatrix3x2) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_TransformMatrix(pThis, value))
        }
    }
    public func put_TransformMatrix(value : Windows.Foundation.Numerics.Matrix3x2) throws -> Void {
        try self._n_put_TransformMatrix(value);
    }
    // Microsoft.Graphics.Canvas.CanvasDrawingSession CreateDrawingSession(Windows.UI.Color)
    private func _n_CreateDrawingSession(_ clearColor : _q_CWindows_CUI_CColor, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateDrawingSession(pThis, clearColor, __presult))
        }
    }
    public func CreateDrawingSession(clearColor : Windows.UI.Color) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasDrawingSession> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDrawingSession>> = nil;
        try self._n_CreateDrawingSession(clearColor, &__result);
        return Microsoft.Graphics.Canvas.ICanvasDrawingSession(consuming: __result);
    }
    // void WaitForVerticalBlank()
    private func _n_WaitForVerticalBlank() throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.WaitForVerticalBlank(pThis))
        }
    }
    public func WaitForVerticalBlank() throws -> Void {
        try self._n_WaitForVerticalBlank();
    }
    public var AlphaMode : Microsoft.Graphics.Canvas.CanvasAlphaMode {
        get throws {
            return try get_AlphaMode();
        }
    }
    public var BufferCount : Swift.Int32 {
        get throws {
            return try get_BufferCount();
        }
    }
    public var Format : Windows.Graphics.DirectX.DirectXPixelFormat {
        get throws {
            return try get_Format();
        }
    }
    public var Rotation : Microsoft.Graphics.Canvas.CanvasSwapChainRotation {
        get throws {
            return try get_Rotation();
        }
    }
    public var Size : Windows.Foundation.Size {
        get throws {
            return try get_Size();
        }
    }
    public var SizeInPixels : Windows.Graphics.Imaging.BitmapSize {
        get throws {
            return try get_SizeInPixels();
        }
    }
    public var SourceSize : Windows.Foundation.Size {
        get throws {
            return try get_SourceSize();
        }
    }
    public var TransformMatrix : Windows.Foundation.Numerics.Matrix3x2 {
        get throws {
            return try get_TransformMatrix();
        }
    }
} // ICanvasSwapChain


// type: Microsoft.Graphics.Canvas.ICanvasSwapChainFactory
// interface type
// ACTIVATION INTERFACE
open class ICanvasSwapChainFactory
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x133c25cb, Data2: 0xed3c, Data3 : 0x492b, Data4 : (0xbf, 0xfe, 0x75, 0x09, 0xb5, 0x21, 0x84, 0x2b)) }
    // Microsoft.Graphics.Canvas.CanvasSwapChain CreateWithSize(Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi, Windows.Foundation.Size)
    private func _n_CreateWithSize(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreatorWithDpi>>, _ size : _q_CWindows_CFoundation_CSize, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChainFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateWithSize(pThis, resourceCreator, size, __presult))
        }
    }
    public func CreateWithSize(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi>, size : Windows.Foundation.Size) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasSwapChain> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain>> = nil;
        try self._n_CreateWithSize(RawPointer(resourceCreator), size, &__result);
        return Microsoft.Graphics.Canvas.ICanvasSwapChain(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasSwapChain CreateWithWidthAndHeight(Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi, System.Single, System.Single)
    private func _n_CreateWithWidthAndHeight(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreatorWithDpi>>, _ width : FLOAT, _ height : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChainFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateWithWidthAndHeight(pThis, resourceCreator, width, height, __presult))
        }
    }
    public func CreateWithWidthAndHeight(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreatorWithDpi>, width : Swift.Float, height : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasSwapChain> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain>> = nil;
        try self._n_CreateWithWidthAndHeight(RawPointer(resourceCreator), width, height, &__result);
        return Microsoft.Graphics.Canvas.ICanvasSwapChain(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasSwapChain CreateWithWidthAndHeightAndDpi(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.Single, System.Single, System.Single)
    private func _n_CreateWithWidthAndHeightAndDpi(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ width : FLOAT, _ height : FLOAT, _ dpi : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChainFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateWithWidthAndHeightAndDpi(pThis, resourceCreator, width, height, dpi, __presult))
        }
    }
    public func CreateWithWidthAndHeightAndDpi(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, width : Swift.Float, height : Swift.Float, dpi : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasSwapChain> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain>> = nil;
        try self._n_CreateWithWidthAndHeightAndDpi(RawPointer(resourceCreator), width, height, dpi, &__result);
        return Microsoft.Graphics.Canvas.ICanvasSwapChain(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasSwapChain CreateWithAllOptions(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.Single, System.Single, System.Single, Windows.Graphics.DirectX.DirectXPixelFormat, System.Int32, Microsoft.Graphics.Canvas.CanvasAlphaMode)
    private func _n_CreateWithAllOptions(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ width : FLOAT, _ height : FLOAT, _ dpi : FLOAT, _ format : _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat, _ bufferCount : INT32, _ alphaMode : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChainFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateWithAllOptions(pThis, resourceCreator, width, height, dpi, format, bufferCount, alphaMode, __presult))
        }
    }
    public func CreateWithAllOptions(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, width : Swift.Float, height : Swift.Float, dpi : Swift.Float, format : Windows.Graphics.DirectX.DirectXPixelFormat, bufferCount : Swift.Int32, alphaMode : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasSwapChain> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain>> = nil;
        try self._n_CreateWithAllOptions(RawPointer(resourceCreator), width, height, dpi, format, bufferCount, alphaMode, &__result);
        return Microsoft.Graphics.Canvas.ICanvasSwapChain(consuming: __result);
    }
} // ICanvasSwapChainFactory


// type: Microsoft.Graphics.Canvas.ICanvasSwapChainStatics
// interface type
open class ICanvasSwapChainStatics
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x05376d8f, Data2: 0x3e8d, Data3 : 0x4a82, Data4 : (0x98, 0x38, 0x69, 0x16, 0x80, 0xd3, 0x2a, 0x52)) }
    // Microsoft.Graphics.Canvas.CanvasSwapChain CreateForCoreWindow(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.UI.Core.CoreWindow, System.Single)
    private func _n_CreateForCoreWindowWithDpi(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ coreWindow : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CCore_CICoreWindow>>, _ dpi : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChainStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateForCoreWindowWithDpi(pThis, resourceCreator, coreWindow, dpi, __presult))
        }
    }
    public func CreateForCoreWindowWithDpi(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, coreWindow : Optional<Windows.UI.Core.ICoreWindow>, dpi : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasSwapChain> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain>> = nil;
        try self._n_CreateForCoreWindowWithDpi(RawPointer(resourceCreator), RawPointer(coreWindow), dpi, &__result);
        return Microsoft.Graphics.Canvas.ICanvasSwapChain(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.CanvasSwapChain CreateForCoreWindow(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.UI.Core.CoreWindow, System.Single, System.Single, System.Single, Windows.Graphics.DirectX.DirectXPixelFormat, System.Int32)
    private func _n_CreateForCoreWindowWithAllOptions(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ coreWindow : Optional<UnsafeMutablePointer<_q_CWindows_CUI_CCore_CICoreWindow>>, _ width : FLOAT, _ height : FLOAT, _ dpi : FLOAT, _ format : _q_CWindows_CGraphics_CDirectX_CDirectXPixelFormat, _ bufferCount : INT32, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChainStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateForCoreWindowWithAllOptions(pThis, resourceCreator, coreWindow, width, height, dpi, format, bufferCount, __presult))
        }
    }
    public func CreateForCoreWindowWithAllOptions(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, coreWindow : Optional<Windows.UI.Core.ICoreWindow>, width : Swift.Float, height : Swift.Float, dpi : Swift.Float, format : Windows.Graphics.DirectX.DirectXPixelFormat, bufferCount : Swift.Int32) throws -> Optional<Microsoft.Graphics.Canvas.ICanvasSwapChain> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasSwapChain>> = nil;
        try self._n_CreateForCoreWindowWithAllOptions(RawPointer(resourceCreator), RawPointer(coreWindow), width, height, dpi, format, bufferCount, &__result);
        return Microsoft.Graphics.Canvas.ICanvasSwapChain(consuming: __result);
    }
} // ICanvasSwapChainStatics


// type: Microsoft.Graphics.Canvas.ICanvasVirtualBitmap
// interface type
open class ICanvasVirtualBitmap
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x707d8bb0, Data2: 0x05f9, Data3 : 0x484c, Data4 : (0x9e, 0xe2, 0x17, 0x9e, 0x06, 0x81, 0xc8, 0xa7)) }
    // [IsSpecialName] Microsoft.Graphics.Canvas.CanvasDevice get_Device()
    private func _n_get_Device(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Device(pThis, __presult))
        }
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>> = nil;
        try self._n_get_Device(&__result);
        return Microsoft.Graphics.Canvas.ICanvasDevice(consuming: __result);
    }
    // [IsSpecialName] bool get_IsCachedOnDemand()
    private func _n_get_IsCachedOnDemand(_ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_IsCachedOnDemand(pThis, __presult))
        }
    }
    public func get_IsCachedOnDemand() throws -> boolean {
        var __result : boolean = 0;
        try self._n_get_IsCachedOnDemand(&__result);
        return __result;
    }
    // [IsSpecialName] Windows.Graphics.Imaging.BitmapSize get_SizeInPixels()
    private func _n_get_SizeInPixels(_ __presult: UnsafeMutablePointer<_q_CWindows_CGraphics_CImaging_CBitmapSize>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_SizeInPixels(pThis, __presult))
        }
    }
    public func get_SizeInPixels() throws -> Windows.Graphics.Imaging.BitmapSize {
        var __result : _q_CWindows_CGraphics_CImaging_CBitmapSize = _q_CWindows_CGraphics_CImaging_CBitmapSize(Width: 0, Height: 0);
        try self._n_get_SizeInPixels(&__result);
        return __result;
    }
    // [IsSpecialName] Windows.Foundation.Size get_Size()
    private func _n_get_Size(_ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CSize>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Size(pThis, __presult))
        }
    }
    public func get_Size() throws -> Windows.Foundation.Size {
        var __result : _q_CWindows_CFoundation_CSize = _q_CWindows_CFoundation_CSize(Width: 0, Height: 0);
        try self._n_get_Size(&__result);
        return __result;
    }
    // [IsSpecialName] Windows.Foundation.Rect get_Bounds()
    private func _n_get_Bounds(_ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CRect>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmap.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Bounds(pThis, __presult))
        }
    }
    public func get_Bounds() throws -> Windows.Foundation.Rect {
        var __result : _q_CWindows_CFoundation_CRect = _q_CWindows_CFoundation_CRect(X: 0, Y: 0, Width: 0, Height: 0);
        try self._n_get_Bounds(&__result);
        return __result;
    }
    public var Bounds : Windows.Foundation.Rect {
        get throws {
            return try get_Bounds();
        }
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        get throws {
            return try get_Device();
        }
    }
    public var IsCachedOnDemand : boolean {
        get throws {
            return try get_IsCachedOnDemand();
        }
    }
    public var Size : Windows.Foundation.Size {
        get throws {
            return try get_Size();
        }
    }
    public var SizeInPixels : Windows.Graphics.Imaging.BitmapSize {
        get throws {
            return try get_SizeInPixels();
        }
    }
} // ICanvasVirtualBitmap


// type: Microsoft.Graphics.Canvas.ICanvasVirtualBitmapStatics
// interface type
open class ICanvasVirtualBitmapStatics
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xb2f1f8e9, Data2: 0x0770, Data3 : 0x4dd4, Data4 : (0x95, 0x6d, 0x78, 0xd9, 0x11, 0x39, 0x09, 0x57)) }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.String)
    private func _n_LoadAsyncFromFileName(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ fileName : Optional<HSTRING>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromFileName(pThis, resourceCreator, fileName, __presult))
        }
    }
    public func LoadAsyncFromFileName(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Optional<Swift.String>) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        let __hstr_fileName = try HString(fileName!);
        return try withExtendedLifetime(__hstr_fileName) {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>> = nil;
        try self._n_LoadAsyncFromFileName(RawPointer(resourceCreator), __hstr_fileName.Raw(), &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap(consuming: __result);
        }
    }
    public func LoadAsyncFromFileName(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Optional<Swift.String>) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromFileName(resourceCreator: resourceCreator, fileName: fileName)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.String, Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions)
    private func _n_LoadAsyncFromFileNameWithOptions(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ fileName : Optional<HSTRING>, _ options : _q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmapOptions, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromFileNameWithOptions(pThis, resourceCreator, fileName, options, __presult))
        }
    }
    public func LoadAsyncFromFileNameWithOptions(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Optional<Swift.String>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        let __hstr_fileName = try HString(fileName!);
        return try withExtendedLifetime(__hstr_fileName) {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>> = nil;
        try self._n_LoadAsyncFromFileNameWithOptions(RawPointer(resourceCreator), __hstr_fileName.Raw(), options, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap(consuming: __result);
        }
    }
    public func LoadAsyncFromFileNameWithOptions(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Optional<Swift.String>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromFileNameWithOptions(resourceCreator: resourceCreator, fileName: fileName, options: options)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.String, Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, Microsoft.Graphics.Canvas.CanvasAlphaMode)
    private func _n_LoadAsyncFromFileNameWithOptionsAndAlpha(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ fileName : Optional<HSTRING>, _ options : _q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmapOptions, _ alpha : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromFileNameWithOptionsAndAlpha(pThis, resourceCreator, fileName, options, alpha, __presult))
        }
    }
    public func LoadAsyncFromFileNameWithOptionsAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Optional<Swift.String>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        let __hstr_fileName = try HString(fileName!);
        return try withExtendedLifetime(__hstr_fileName) {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>> = nil;
        try self._n_LoadAsyncFromFileNameWithOptionsAndAlpha(RawPointer(resourceCreator), __hstr_fileName.Raw(), options, alpha, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap(consuming: __result);
        }
    }
    public func LoadAsyncFromFileNameWithOptionsAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, fileName : Optional<Swift.String>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromFileNameWithOptionsAndAlpha(resourceCreator: resourceCreator, fileName: fileName, options: options, alpha: alpha)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Uri)
    private func _n_LoadAsyncFromUri(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ uri : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIUriRuntimeClass>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromUri(pThis, resourceCreator, uri, __presult))
        }
    }
    public func LoadAsyncFromUri(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.IUriRuntimeClass>) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>> = nil;
        try self._n_LoadAsyncFromUri(RawPointer(resourceCreator), RawPointer(uri), &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap(consuming: __result);
    }
    public func LoadAsyncFromUri(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.IUriRuntimeClass>) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromUri(resourceCreator: resourceCreator, uri: uri)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Uri, Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions)
    private func _n_LoadAsyncFromUriWithOptions(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ uri : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIUriRuntimeClass>>, _ options : _q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmapOptions, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromUriWithOptions(pThis, resourceCreator, uri, options, __presult))
        }
    }
    public func LoadAsyncFromUriWithOptions(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.IUriRuntimeClass>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>> = nil;
        try self._n_LoadAsyncFromUriWithOptions(RawPointer(resourceCreator), RawPointer(uri), options, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap(consuming: __result);
    }
    public func LoadAsyncFromUriWithOptions(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.IUriRuntimeClass>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromUriWithOptions(resourceCreator: resourceCreator, uri: uri, options: options)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Uri, Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, Microsoft.Graphics.Canvas.CanvasAlphaMode)
    private func _n_LoadAsyncFromUriWithOptionsAndAlpha(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ uri : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIUriRuntimeClass>>, _ options : _q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmapOptions, _ alpha : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromUriWithOptionsAndAlpha(pThis, resourceCreator, uri, options, alpha, __presult))
        }
    }
    public func LoadAsyncFromUriWithOptionsAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.IUriRuntimeClass>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>> = nil;
        try self._n_LoadAsyncFromUriWithOptionsAndAlpha(RawPointer(resourceCreator), RawPointer(uri), options, alpha, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap(consuming: __result);
    }
    public func LoadAsyncFromUriWithOptionsAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, uri : Optional<Windows.Foundation.IUriRuntimeClass>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromUriWithOptionsAndAlpha(resourceCreator: resourceCreator, uri: uri, options: options, alpha: alpha)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Storage.Streams.IRandomAccessStream)
    private func _n_LoadAsyncFromStream(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ stream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIRandomAccessStream>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromStream(pThis, resourceCreator, stream, __presult))
        }
    }
    public func LoadAsyncFromStream(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>> = nil;
        try self._n_LoadAsyncFromStream(RawPointer(resourceCreator), RawPointer(stream), &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap(consuming: __result);
    }
    public func LoadAsyncFromStream(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromStream(resourceCreator: resourceCreator, stream: stream)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Storage.Streams.IRandomAccessStream, Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions)
    private func _n_LoadAsyncFromStreamWithOptions(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ stream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIRandomAccessStream>>, _ options : _q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmapOptions, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromStreamWithOptions(pThis, resourceCreator, stream, options, __presult))
        }
    }
    public func LoadAsyncFromStreamWithOptions(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>> = nil;
        try self._n_LoadAsyncFromStreamWithOptions(RawPointer(resourceCreator), RawPointer(stream), options, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap(consuming: __result);
    }
    public func LoadAsyncFromStreamWithOptions(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromStreamWithOptions(resourceCreator: resourceCreator, stream: stream, options: options)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Microsoft.Graphics.Canvas.CanvasVirtualBitmap> LoadAsync(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Storage.Streams.IRandomAccessStream, Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, Microsoft.Graphics.Canvas.CanvasAlphaMode)
    private func _n_LoadAsyncFromStreamWithOptionsAndAlpha(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ stream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIRandomAccessStream>>, _ options : _q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmapOptions, _ alpha : _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CICanvasVirtualBitmapStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.LoadAsyncFromStreamWithOptionsAndAlpha(pThis, resourceCreator, stream, options, alpha, __presult))
        }
    }
    public func LoadAsyncFromStreamWithOptionsAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap>> = nil;
        try self._n_LoadAsyncFromStreamWithOptionsAndAlpha(RawPointer(resourceCreator), RawPointer(stream), options, alpha, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmap(consuming: __result);
    }
    public func LoadAsyncFromStreamWithOptionsAndAlpha(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, stream : Optional<Windows.Storage.Streams.IRandomAccessStream>, options : Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions, alpha : Microsoft.Graphics.Canvas.CanvasAlphaMode) async throws -> Optional<Microsoft.Graphics.Canvas.ICanvasVirtualBitmap> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.LoadAsyncFromStreamWithOptionsAndAlpha(resourceCreator: resourceCreator, stream: stream, options: options, alpha: alpha)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
} // ICanvasVirtualBitmapStatics


}
extension Microsoft.Graphics.Canvas.CanvasAlphaMode {
    public static var Premultiplied : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode_Premultiplied;
        }
    }
    public static var Straight : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode_Straight;
        }
    }
    public static var Ignore : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasAlphaMode_Ignore;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasAntialiasing {
    public static var Antialiased : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasAntialiasing_Antialiased;
        }
    }
    public static var Aliased : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasAntialiasing_Aliased;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasBitmapFileFormat {
    public static var Auto : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat_Auto;
        }
    }
    public static var Bmp : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat_Bmp;
        }
    }
    public static var Png : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat_Png;
        }
    }
    public static var Jpeg : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat_Jpeg;
        }
    }
    public static var Tiff : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat_Tiff;
        }
    }
    public static var Gif : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat_Gif;
        }
    }
    public static var JpegXR : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBitmapFileFormat_JpegXR;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasBlend {
    public static var SourceOver : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBlend_SourceOver;
        }
    }
    public static var Copy : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBlend_Copy;
        }
    }
    public static var Min : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBlend_Min;
        }
    }
    public static var Add : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBlend_Add;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasBufferPrecision {
    public static var Precision8UIntNormalized : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision_Precision8UIntNormalized;
        }
    }
    public static var Precision8UIntNormalizedSrgb : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision_Precision8UIntNormalizedSrgb;
        }
    }
    public static var Precision16UIntNormalized : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision_Precision16UIntNormalized;
        }
    }
    public static var Precision16Float : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision_Precision16Float;
        }
    }
    public static var Precision32Float : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasBufferPrecision_Precision32Float;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasColorSpace {
    public static var Custom : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasColorSpace_Custom;
        }
    }
    public static var Srgb : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasColorSpace_Srgb;
        }
    }
    public static var ScRgb : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasColorSpace_ScRgb;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasComposite {
    public static var SourceOver : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite_SourceOver;
        }
    }
    public static var DestinationOver : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite_DestinationOver;
        }
    }
    public static var SourceIn : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite_SourceIn;
        }
    }
    public static var DestinationIn : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite_DestinationIn;
        }
    }
    public static var SourceOut : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite_SourceOut;
        }
    }
    public static var DestinationOut : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite_DestinationOut;
        }
    }
    public static var SourceAtop : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite_SourceAtop;
        }
    }
    public static var DestinationAtop : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite_DestinationAtop;
        }
    }
    public static var Xor : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite_Xor;
        }
    }
    public static var Add : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite_Add;
        }
    }
    public static var Copy : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite_Copy;
        }
    }
    public static var BoundedCopy : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite_BoundedCopy;
        }
    }
    public static var MaskInvert : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasComposite_MaskInvert;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasDebugLevel {
    public static var None : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasDebugLevel_None;
        }
    }
    public static var Error : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasDebugLevel_Error;
        }
    }
    public static var Warning : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasDebugLevel_Warning;
        }
    }
    public static var Information : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasDebugLevel_Information;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasDpiRounding {
    public static var Floor : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasDpiRounding_Floor;
        }
    }
    public static var Round : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasDpiRounding_Round;
        }
    }
    public static var Ceiling : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasDpiRounding_Ceiling;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasEdgeBehavior {
    public static var Clamp : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasEdgeBehavior_Clamp;
        }
    }
    public static var Wrap : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasEdgeBehavior_Wrap;
        }
    }
    public static var Mirror : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasEdgeBehavior_Mirror;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasImageInterpolation {
    public static var NearestNeighbor : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation_NearestNeighbor;
        }
    }
    public static var Linear : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation_Linear;
        }
    }
    public static var Cubic : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation_Cubic;
        }
    }
    public static var MultiSampleLinear : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation_MultiSampleLinear;
        }
    }
    public static var Anisotropic : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation_Anisotropic;
        }
    }
    public static var HighQualityCubic : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasImageInterpolation_HighQualityCubic;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasLayerOptions {
    public static var None : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasLayerOptions_None;
        }
    }
    public static var InitializeFromBackground : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasLayerOptions_InitializeFromBackground;
        }
    }
    public static var IgnoreAlpha : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasLayerOptions_IgnoreAlpha;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasSpriteFlip {
    public static var None : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteFlip_None;
        }
    }
    public static var Horizontal : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteFlip_Horizontal;
        }
    }
    public static var Vertical : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteFlip_Vertical;
        }
    }
    public static var Both : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteFlip_Both;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasSpriteOptions {
    public static var None : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteOptions_None;
        }
    }
    public static var ClampToSourceRect : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteOptions_ClampToSourceRect;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasSpriteSortMode {
    public static var None : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteSortMode_None;
        }
    }
    public static var Bitmap : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasSpriteSortMode_Bitmap;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasSwapChainRotation {
    public static var None : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasSwapChainRotation_None;
        }
    }
    public static var Rotate90 : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasSwapChainRotation_Rotate90;
        }
    }
    public static var Rotate180 : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasSwapChainRotation_Rotate180;
        }
    }
    public static var Rotate270 : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasSwapChainRotation_Rotate270;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasUnits {
    public static var Dips : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasUnits_Dips;
        }
    }
    public static var Pixels : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasUnits_Pixels;
        }
    }
}
extension Microsoft.Graphics.Canvas.CanvasVirtualBitmapOptions {
    public static var None : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmapOptions_None;
        }
    }
    public static var ReleaseSource : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmapOptions_ReleaseSource;
        }
    }
    public static var CacheOnDemand : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CCanvasVirtualBitmapOptions_CacheOnDemand;
        }
    }
}
