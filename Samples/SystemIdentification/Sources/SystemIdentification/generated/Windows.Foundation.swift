// this file is automatically generated.
// if you modify it by hand, your changes will probably be lost.


import CWinRT;
@_spi(IUnknown) import WinRT;
import C;


extension Windows.Foundation.IAsyncAction: WinRT.Future {
  private final class CompletedHandler: Windows.Foundation.impl_AsyncActionCompletedHandler {
    private var hEvent: HANDLE

    public init(signal event: HANDLE) {
      self.hEvent = event
      super.init()
    }

    override func Invoke(asyncInfo: Windows.Foundation.IAsyncAction?,
                         asyncStatus: Windows.Foundation.AsyncStatus) throws {
      _ = SetEvent(self.hEvent)
    }
  }

  public func get() throws -> Void {
    let info: Windows.Foundation.IAsyncInfo = try QueryInterface()
    if try info.get_Status() == Windows.Foundation.AsyncStatus.Started {
      let event: HANDLE =
          CreateEventW(nil, /*bManualReset=*/true, /*DefaultValue=*/false, nil)
      // TODO(compnerd) validate event
      defer { _ = CloseHandle(event) }

      let completion: Windows.Foundation.impl_AsyncActionCompletedHandler =
          Windows.Foundation.IAsyncAction.CompletedHandler(signal: event)
      try withExtendedLifetime(completion) {
        try self.put_Completed(handler: completion.Interface())
        _ = WaitForSingleObject(event, INFINITE)
      }
    }
    try self.GetResults()
  }
}

extension Windows.Foundation {
// type: Windows.Foundation.AsyncActionCompletedHandler
// delegate type
open class IAsyncActionCompletedHandler
    :
    WinRT.IUnknown
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xa4ed5c81, Data2: 0x76c9, Data3 : 0x40bd, Data4 : (0x8b, 0xe6, 0xb1, 0xd9, 0x0f, 0xb2, 0x0a, 0xe7)) }
    // [IsSpecialName] void Invoke(Windows.Foundation.IAsyncAction, Windows.Foundation.AsyncStatus)
    private func _n_Invoke(_ asyncInfo : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>>, _ asyncStatus : _q_CWindows_CFoundation_CAsyncStatus) throws {
        return try perform(as: _q_CWindows_CFoundation_CIAsyncActionCompletedHandler.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Invoke(pThis, asyncInfo, asyncStatus))
        }
    }
    public func Invoke(asyncInfo : Optional<Windows.Foundation.IAsyncAction>, asyncStatus : Windows.Foundation.AsyncStatus) throws -> Void {
        try self._n_Invoke(RawPointer(asyncInfo), asyncStatus);
    }
}
// impl delegate type
open class impl_AsyncActionCompletedHandler
{
    private static var vtable: _q_CWindows_CFoundation_CIAsyncActionCompletedHandlerVtbl = .init(
    QueryInterface: {
        guard let pUnk = $0, let riid = $1, let ppvObject = $2 else {
            return E_INVALIDARG
        }
        switch riid.pointee {
        case IUnknown.IID, Windows.Foundation.IAsyncActionCompletedHandler.IID:
            _ = pUnk.pointee.lpVtbl.pointee.AddRef(pUnk)
            ppvObject.pointee = UnsafeMutableRawPointer(pUnk)
            return S_OK
        default:
            ppvObject.pointee = nil
            return E_NOINTERFACE
        }
    },
    AddRef: {
        let pinstance = UnsafeMutableRawPointer($0!).bindMemory(to: impl_AsyncActionCompletedHandler.WithTrailingObjects.self, capacity: 1)
        _ = pinstance.pointee.container.retain()
        let __res = ULONG(_getRetainCount(pinstance.pointee.container.takeUnretainedValue()))
        return __res;
    },
    Release: {
        let pinstance = UnsafeMutableRawPointer($0!).bindMemory(to: impl_AsyncActionCompletedHandler.WithTrailingObjects.self, capacity: 1)
        let __res = ULONG(_getRetainCount(pinstance.pointee.container.takeRetainedValue()))
        return __res;
    },
    Invoke: {
        (pThis, _ asyncInfo : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncAction>>, _ asyncStatus : _q_CWindows_CFoundation_CAsyncStatus) in
        guard let self = impl_AsyncActionCompletedHandler.from_impl_AsyncActionCompletedHandler(pThis) else {
            return E_INVALIDARG
        }
        do {
            let _ret : Void = try self.Invoke(asyncInfo: Windows.Foundation.IAsyncAction(asyncInfo), asyncStatus: asyncStatus)
            return S_OK
        }
        catch let _e as WinRT.Error {
            return _e.hr;
        } catch {
            return E_FAIL
        }
    }
    )
    private class Container {
        public var self_ref: impl_AsyncActionCompletedHandler? = nil
    }
    private struct WithTrailingObjects {
        public var interface_struct: _q_CWindows_CFoundation_CIAsyncActionCompletedHandler
        public var container: Unmanaged<Container>
    }
    private var instance: WithTrailingObjects

    private var _cb : Optional<(Optional<Windows.Foundation.IAsyncAction>, Windows.Foundation.AsyncStatus) throws -> Void>
    public init(cb : Optional<(Optional<Windows.Foundation.IAsyncAction>, Windows.Foundation.AsyncStatus) throws -> Void> = nil) {
        _cb = cb
        self.instance = WithTrailingObjects(interface_struct: _q_CWindows_CFoundation_CIAsyncActionCompletedHandler(lpVtbl: &Self.vtable), container: Unmanaged<Container>.passRetained(Container()))
        self.instance.container.takeUnretainedValue().self_ref = self
    }
    private static func from_impl_AsyncActionCompletedHandler(_ pUnk: UnsafeMutableRawPointer?) -> impl_AsyncActionCompletedHandler? {
        return pUnk?.bindMemory(to: impl_AsyncActionCompletedHandler.WithTrailingObjects.self, capacity: 1).pointee.container.takeUnretainedValue().self_ref
    }

    open func Invoke(asyncInfo : Optional<Windows.Foundation.IAsyncAction>, asyncStatus : Windows.Foundation.AsyncStatus) throws -> Void {
        if let cb = _cb {
            return try cb(asyncInfo, asyncStatus)
        }
    }
    public func Interface() -> Windows.Foundation.IAsyncActionCompletedHandler {
        return withUnsafeMutablePointer(to: &self.instance.interface_struct) {
            Windows.Foundation.IAsyncActionCompletedHandler(UnsafeMutableRawPointer($0))
        }
    }
}
// wrap delegate type
open class wrap_AsyncActionCompletedHandler
{
    private var _self : Windows.Foundation.IAsyncActionCompletedHandler;
    public init(plok: Windows.Foundation.IAsyncActionCompletedHandler?) throws {
        _self = plok!
    }
    public func Invoke(asyncInfo : Optional<Windows.Foundation.IAsyncAction>, asyncStatus : Windows.Foundation.AsyncStatus) throws -> Void {
        return try _self.Invoke(asyncInfo: asyncInfo, asyncStatus: asyncStatus);
    }
    public func Interface() -> Windows.Foundation.IAsyncActionCompletedHandler {
        return _self
    }
}

// type: Windows.Foundation.AsyncStatus
// enum type
public typealias AsyncStatus = _q_CWindows_CFoundation_CAsyncStatus;

// type: Windows.Foundation.HResult
// struct type
public typealias HResult = _q_CWindows_CFoundation_CHResult;

// type: Windows.Foundation.IAsyncAction
// interface type
open class IAsyncAction
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x5a648006, Data2: 0x843a, Data3 : 0x4da9, Data4 : (0x86, 0x5b, 0x9d, 0x26, 0xe5, 0xdf, 0xad, 0x7b)) }
    // [IsSpecialName] void put_Completed(Windows.Foundation.AsyncActionCompletedHandler)
    private func _n_put_Completed(_ handler : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncActionCompletedHandler>>) throws {
        return try perform(as: _q_CWindows_CFoundation_CIAsyncAction.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_Completed(pThis, handler))
        }
    }
    public func put_Completed(handler : Optional<Windows.Foundation.IAsyncActionCompletedHandler>) throws -> Void {
        try self._n_put_Completed(RawPointer(handler));
    }
    // [IsSpecialName] Windows.Foundation.AsyncActionCompletedHandler get_Completed()
    private func _n_get_Completed(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncActionCompletedHandler>>>?) throws {
        return try perform(as: _q_CWindows_CFoundation_CIAsyncAction.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Completed(pThis, __presult))
        }
    }
    public func get_Completed() throws -> Optional<Windows.Foundation.IAsyncActionCompletedHandler> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncActionCompletedHandler>> = nil;
        try self._n_get_Completed(&__result);
        return Windows.Foundation.IAsyncActionCompletedHandler(consuming: __result);
    }
    // void GetResults()
    private func _n_GetResults() throws {
        return try perform(as: _q_CWindows_CFoundation_CIAsyncAction.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetResults(pThis))
        }
    }
    public func GetResults() throws -> Void {
        try self._n_GetResults();
    }
    public var Completed : Optional<Windows.Foundation.IAsyncActionCompletedHandler> {
        get throws {
            return try get_Completed();
        }
    }
} // IAsyncAction

// impl class
open class AsyncAction
{
    private class Container {
        public var self_ref: AsyncAction? = nil
    }
    private struct WithTrailingObjects_IAsyncInfo {
        public var interface_struct: _q_CWindows_CFoundation_CIAsyncInfo
        public var container: Unmanaged<Container>
    }
    private var instance_IAsyncInfo: WithTrailingObjects_IAsyncInfo
    private static func from_IAsyncInfo(_ pUnk: UnsafeMutableRawPointer?) -> AsyncAction? {
        return pUnk?.bindMemory(to: AsyncAction.WithTrailingObjects_IAsyncInfo.self, capacity: 1).pointee.container.takeUnretainedValue().self_ref
    }
    private static var vtable_IAsyncInfo: _q_CWindows_CFoundation_CIAsyncInfoVtbl = .init(
    QueryInterface: {
        guard let pUnk = $0, let riid = $1, let ppvObject = $2 else {
            return E_INVALIDARG
        }
        switch riid.pointee {
        case IUnknown.IID, IInspectable.IID, Windows.Foundation.IAsyncInfo.IID:
            _ = pUnk.pointee.lpVtbl.pointee.AddRef(pUnk)
            ppvObject.pointee = UnsafeMutableRawPointer(pUnk)
            return S_OK
        case Windows.Foundation.IAsyncAction.IID:
            guard let self = AsyncAction.from_IAsyncInfo(pUnk) else {
                return E_INVALIDARG
            }
            let p =
                withUnsafeMutablePointer(to: &self.instance_IAsyncAction.interface_struct) {
                    return UnsafeMutableRawPointer($0).bindMemory(to: _q_CWindows_CFoundation_CIAsyncAction.self, capacity: 1)
                }
            _ = p.pointee.lpVtbl.pointee.AddRef(p)
            ppvObject.pointee = UnsafeMutableRawPointer(p)
            return S_OK
        default:
            ppvObject.pointee = nil
            return E_NOINTERFACE
        }
    },
    AddRef: {
        let pinstance = UnsafeMutableRawPointer($0!).bindMemory(to: AsyncAction.WithTrailingObjects_IAsyncInfo.self, capacity: 1)
        _ = pinstance.pointee.container.retain()
        let __res = ULONG(_getRetainCount(pinstance.pointee.container.takeUnretainedValue()))
        return __res;
    },
    Release: {
        let pinstance = UnsafeMutableRawPointer($0!).bindMemory(to: AsyncAction.WithTrailingObjects_IAsyncInfo.self, capacity: 1)
        let __res = ULONG(_getRetainCount(pinstance.pointee.container.takeRetainedValue()))
        return __res;
    },
    GetIids: {
        guard let pThis = $0, let pLen = $1, let ppItems = $2 else {
            return E_INVALIDARG
        }
        let num_interfaces = 2
        pLen.pointee = ULONG(num_interfaces)
        var mem = CoTaskMemAlloc(UInt64(16 * num_interfaces)).bindMemory(to: IID.self, capacity: num_interfaces)
        (mem + 0).pointee = Windows.Foundation.IAsyncInfo.IID
        (mem + 1).pointee = Windows.Foundation.IAsyncAction.IID
        ppItems.pointee = mem
        return S_OK;
    },
    GetRuntimeClassName: {
        guard let pThis = $0, let pstr = $1 else {
            return E_INVALIDARG
        }
        do {
            pstr.pointee = try HString("Windows.Foundation.AsyncAction").Raw()
            return S_OK;
        }
        catch let _e as WinRT.Error {
            return _e.hr;
        } catch {
            return E_FAIL
        }
    },
    GetTrustLevel: {
        guard let pThis = $0, let presult = $1 else {
            return E_INVALIDARG
        }
        presult.pointee = CWinRT.TrustLevel(rawValue: 2);
        return S_OK;
    },
    get_Id: {
        (pThis, _ __presult: UnsafeMutablePointer<UINT32>?) in
        guard let self = AsyncAction.from_IAsyncInfo(pThis) else {
            return E_INVALIDARG
        }
        do {
            let _ret : Swift.UInt32 = try self.get_Id()
            __presult!.pointee = _ret;
            return S_OK
        }
        catch let _e as WinRT.Error {
            return _e.hr;
        } catch {
            return E_FAIL
        }
    },
    get_Status: {
        (pThis, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CAsyncStatus>?) in
        guard let self = AsyncAction.from_IAsyncInfo(pThis) else {
            return E_INVALIDARG
        }
        do {
            let _ret : Windows.Foundation.AsyncStatus = try self.get_Status()
            __presult!.pointee = _ret;
            return S_OK
        }
        catch let _e as WinRT.Error {
            return _e.hr;
        } catch {
            return E_FAIL
        }
    },
    get_ErrorCode: {
        (pThis, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CHResult>?) in
        guard let self = AsyncAction.from_IAsyncInfo(pThis) else {
            return E_INVALIDARG
        }
        do {
            let _ret : Windows.Foundation.HResult = try self.get_ErrorCode()
            __presult!.pointee = _ret;
            return S_OK
        }
        catch let _e as WinRT.Error {
            return _e.hr;
        } catch {
            return E_FAIL
        }
    },
    Cancel: {
        (pThis) in
        guard let self = AsyncAction.from_IAsyncInfo(pThis) else {
            return E_INVALIDARG
        }
        do {
            let _ret : Void = try self.Cancel()
            return S_OK
        }
        catch let _e as WinRT.Error {
            return _e.hr;
        } catch {
            return E_FAIL
        }
    },
    Close: {
        (pThis) in
        guard let self = AsyncAction.from_IAsyncInfo(pThis) else {
            return E_INVALIDARG
        }
        do {
            let _ret : Void = try self.Close()
            return S_OK
        }
        catch let _e as WinRT.Error {
            return _e.hr;
        } catch {
            return E_FAIL
        }
    }
    )
    private struct WithTrailingObjects_IAsyncAction {
        public var interface_struct: _q_CWindows_CFoundation_CIAsyncAction
        public var container: Unmanaged<Container>
    }
    private var instance_IAsyncAction: WithTrailingObjects_IAsyncAction
    private static func from_IAsyncAction(_ pUnk: UnsafeMutableRawPointer?) -> AsyncAction? {
        return pUnk?.bindMemory(to: AsyncAction.WithTrailingObjects_IAsyncAction.self, capacity: 1).pointee.container.takeUnretainedValue().self_ref
    }
    private static var vtable_IAsyncAction: _q_CWindows_CFoundation_CIAsyncActionVtbl = .init(
    QueryInterface: {
        guard let pUnk = $0, let riid = $1, let ppvObject = $2 else {
            return E_INVALIDARG
        }
        switch riid.pointee {
        case IUnknown.IID, IInspectable.IID, Windows.Foundation.IAsyncAction.IID:
            _ = pUnk.pointee.lpVtbl.pointee.AddRef(pUnk)
            ppvObject.pointee = UnsafeMutableRawPointer(pUnk)
            return S_OK
        case Windows.Foundation.IAsyncInfo.IID:
            guard let self = AsyncAction.from_IAsyncAction(pUnk) else {
                return E_INVALIDARG
            }
            let p =
                withUnsafeMutablePointer(to: &self.instance_IAsyncInfo.interface_struct) {
                    return UnsafeMutableRawPointer($0).bindMemory(to: _q_CWindows_CFoundation_CIAsyncInfo.self, capacity: 1)
                }
            _ = p.pointee.lpVtbl.pointee.AddRef(p)
            ppvObject.pointee = UnsafeMutableRawPointer(p)
            return S_OK
        default:
            ppvObject.pointee = nil
            return E_NOINTERFACE
        }
    },
    AddRef: {
        let pinstance = UnsafeMutableRawPointer($0!).bindMemory(to: AsyncAction.WithTrailingObjects_IAsyncAction.self, capacity: 1)
        _ = pinstance.pointee.container.retain()
        let __res = ULONG(_getRetainCount(pinstance.pointee.container.takeUnretainedValue()))
        return __res;
    },
    Release: {
        let pinstance = UnsafeMutableRawPointer($0!).bindMemory(to: AsyncAction.WithTrailingObjects_IAsyncAction.self, capacity: 1)
        let __res = ULONG(_getRetainCount(pinstance.pointee.container.takeRetainedValue()))
        return __res;
    },
    GetIids: {
        guard let pThis = $0, let pLen = $1, let ppItems = $2 else {
            return E_INVALIDARG
        }
        let num_interfaces = 2
        pLen.pointee = ULONG(num_interfaces)
        var mem = CoTaskMemAlloc(UInt64(16 * num_interfaces)).bindMemory(to: IID.self, capacity: num_interfaces)
        (mem + 0).pointee = Windows.Foundation.IAsyncInfo.IID
        (mem + 1).pointee = Windows.Foundation.IAsyncAction.IID
        ppItems.pointee = mem
        return S_OK;
    },
    GetRuntimeClassName: {
        guard let pThis = $0, let pstr = $1 else {
            return E_INVALIDARG
        }
        do {
            pstr.pointee = try HString("Windows.Foundation.AsyncAction").Raw()
            return S_OK;
        }
        catch let _e as WinRT.Error {
            return _e.hr;
        } catch {
            return E_FAIL
        }
    },
    GetTrustLevel: {
        guard let pThis = $0, let presult = $1 else {
            return E_INVALIDARG
        }
        presult.pointee = CWinRT.TrustLevel(rawValue: 2);
        return S_OK;
    },
    put_Completed: {
        (pThis, _ handler : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncActionCompletedHandler>>) in
        guard let self = AsyncAction.from_IAsyncAction(pThis) else {
            return E_INVALIDARG
        }
        do {
            let _ret : Void = try self.put_Completed(handler: Windows.Foundation.wrap_AsyncActionCompletedHandler(plok: Windows.Foundation.IAsyncActionCompletedHandler(handler)))
            return S_OK
        }
        catch let _e as WinRT.Error {
            return _e.hr;
        } catch {
            return E_FAIL
        }
    },
    get_Completed: {
        (pThis, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CIAsyncActionCompletedHandler>>>?) in
        guard let self = AsyncAction.from_IAsyncAction(pThis) else {
            return E_INVALIDARG
        }
        do {
            let _ret : Optional<Windows.Foundation.wrap_AsyncActionCompletedHandler> = try self.get_Completed()
            __presult!.pointee = nil;
            return S_OK
        }
        catch let _e as WinRT.Error {
            return _e.hr;
        } catch {
            return E_FAIL
        }
    },
    GetResults: {
        (pThis) in
        guard let self = AsyncAction.from_IAsyncAction(pThis) else {
            return E_INVALIDARG
        }
        do {
            let _ret : Void = try self.GetResults()
            return S_OK
        }
        catch let _e as WinRT.Error {
            return _e.hr;
        } catch {
            return E_FAIL
        }
    }
    )
    public init() throws {
        self.instance_IAsyncInfo = WithTrailingObjects_IAsyncInfo(interface_struct: _q_CWindows_CFoundation_CIAsyncInfo(lpVtbl: &Self.vtable_IAsyncInfo), container: Unmanaged<Container>.passRetained(Container()))
        self.instance_IAsyncAction = WithTrailingObjects_IAsyncAction(interface_struct: _q_CWindows_CFoundation_CIAsyncAction(lpVtbl: &Self.vtable_IAsyncAction), container: Unmanaged<Container>.passRetained(Container()))
        self.instance_IAsyncInfo.container.takeUnretainedValue().self_ref = self
        self.instance_IAsyncAction.container.takeUnretainedValue().self_ref = self
    }
    open func get_Id() throws -> Swift.UInt32 {
    print("\(#file) \(#line) \(#function)")
    return 0;
    }
    open func get_Status() throws -> Windows.Foundation.AsyncStatus {
    print("\(#file) \(#line) \(#function)")
    return _q_CWindows_CFoundation_CAsyncStatus_Canceled;
    }
    open func get_ErrorCode() throws -> Windows.Foundation.HResult {
    print("\(#file) \(#line) \(#function)")
    return _q_CWindows_CFoundation_CHResult(Value: 0);
    }
    open func Cancel() throws -> Void {
    print("\(#file) \(#line) \(#function)")
    }
    open func Close() throws -> Void {
    print("\(#file) \(#line) \(#function)")
    }
    open func put_Completed(handler : Optional<Windows.Foundation.wrap_AsyncActionCompletedHandler>) throws -> Void {
    print("\(#file) \(#line) \(#function)")
    }
    open func get_Completed() throws -> Optional<Windows.Foundation.wrap_AsyncActionCompletedHandler> {
    print("\(#file) \(#line) \(#function)")
    return nil;
    }
    open func GetResults() throws -> Void {
    print("\(#file) \(#line) \(#function)")
    }
    public func to_IAsyncInfo() -> Windows.Foundation.IAsyncInfo {
        return withUnsafeMutablePointer(to: &self.instance_IAsyncInfo.interface_struct) {
            Windows.Foundation.IAsyncInfo(UnsafeMutableRawPointer($0))
        }
    }
    public func to_IAsyncAction() -> Windows.Foundation.IAsyncAction {
        return withUnsafeMutablePointer(to: &self.instance_IAsyncAction.interface_struct) {
            Windows.Foundation.IAsyncAction(UnsafeMutableRawPointer($0))
        }
    }
}

// type: Windows.Foundation.IAsyncInfo
// interface type
open class IAsyncInfo
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x00000036, Data2: 0x0000, Data3 : 0x0000, Data4 : (0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46)) }
    // [IsSpecialName] System.UInt32 get_Id()
    private func _n_get_Id(_ __presult: UnsafeMutablePointer<UINT32>?) throws {
        return try perform(as: _q_CWindows_CFoundation_CIAsyncInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Id(pThis, __presult))
        }
    }
    public func get_Id() throws -> Swift.UInt32 {
        var __result : UINT32 = 0;
        try self._n_get_Id(&__result);
        return __result;
    }
    // [IsSpecialName] Windows.Foundation.AsyncStatus get_Status()
    private func _n_get_Status(_ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CAsyncStatus>?) throws {
        return try perform(as: _q_CWindows_CFoundation_CIAsyncInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Status(pThis, __presult))
        }
    }
    public func get_Status() throws -> Windows.Foundation.AsyncStatus {
        var __result : _q_CWindows_CFoundation_CAsyncStatus = _q_CWindows_CFoundation_CAsyncStatus_Canceled;
        try self._n_get_Status(&__result);
        return __result;
    }
    // [IsSpecialName] Windows.Foundation.HResult get_ErrorCode()
    private func _n_get_ErrorCode(_ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CHResult>?) throws {
        return try perform(as: _q_CWindows_CFoundation_CIAsyncInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_ErrorCode(pThis, __presult))
        }
    }
    public func get_ErrorCode() throws -> Windows.Foundation.HResult {
        var __result : _q_CWindows_CFoundation_CHResult = _q_CWindows_CFoundation_CHResult(Value: 0);
        try self._n_get_ErrorCode(&__result);
        return __result;
    }
    // void Cancel()
    private func _n_Cancel() throws {
        return try perform(as: _q_CWindows_CFoundation_CIAsyncInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Cancel(pThis))
        }
    }
    public func Cancel() throws -> Void {
        try self._n_Cancel();
    }
    // void Close()
    private func _n_Close() throws {
        return try perform(as: _q_CWindows_CFoundation_CIAsyncInfo.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Close(pThis))
        }
    }
    public func Close() throws -> Void {
        try self._n_Close();
    }
    public var ErrorCode : Windows.Foundation.HResult {
        get throws {
            return try get_ErrorCode();
        }
    }
    public var Id : Swift.UInt32 {
        get throws {
            return try get_Id();
        }
    }
    public var Status : Windows.Foundation.AsyncStatus {
        get throws {
            return try get_Status();
        }
    }
} // IAsyncInfo


}
extension Windows.Foundation.AsyncStatus {
    public static var Canceled : Self {
        get {
            return _q_CWindows_CFoundation_CAsyncStatus_Canceled;
        }
    }
    public static var Completed : Self {
        get {
            return _q_CWindows_CFoundation_CAsyncStatus_Completed;
        }
    }
    public static var Error : Self {
        get {
            return _q_CWindows_CFoundation_CAsyncStatus_Error;
        }
    }
    public static var Started : Self {
        get {
            return _q_CWindows_CFoundation_CAsyncStatus_Started;
        }
    }
}
