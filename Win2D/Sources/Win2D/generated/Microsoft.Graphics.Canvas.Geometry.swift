// this file is automatically generated.
// if you modify it by hand, your changes will probably be lost.


import CWinRT;
@_spi(IUnknown) import WinRT;
import CWin2D;
import WindowsSdk;
import CWindowsSdk;
import WindowsApp;
import CWindowsApp;

extension Microsoft.Graphics.Canvas.Geometry {
// type: Microsoft.Graphics.Canvas.Geometry.CanvasArcSize
// enum type
public typealias CanvasArcSize = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasArcSize;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry
// runtime class
public class CanvasCachedGeometry
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry;
    public init(plok: Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry { return _self; }
    private struct _ICanvasCachedGeometryStatics {
        static var x : ICanvasCachedGeometryStatics =
            try! RoGetActivationFactory("Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry")
    }
    public static var CanvasCachedGeometryStatics : ICanvasCachedGeometryStatics {
        _ICanvasCachedGeometryStatics.x
    }
    public static func CreateFill(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry(plok: CanvasCachedGeometryStatics.CreateFill(geometry: geometry!.Interface()));
    }
    public static func CreateFill(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, flatteningTolerance : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry(plok: CanvasCachedGeometryStatics.CreateFillWithFlatteningTolerance(geometry: geometry!.Interface(), flatteningTolerance: flatteningTolerance));
    }
    public static func CreateStroke(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, strokeWidth : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry(plok: CanvasCachedGeometryStatics.CreateStroke(geometry: geometry!.Interface(), strokeWidth: strokeWidth));
    }
    public static func CreateStroke(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry(plok: CanvasCachedGeometryStatics.CreateStrokeWithStrokeStyle(geometry: geometry!.Interface(), strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface()));
    }
    public static func CreateStroke(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>, flatteningTolerance : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry(plok: CanvasCachedGeometryStatics.CreateStrokeWithStrokeStyleAndFlatteningTolerance(geometry: geometry!.Interface(), strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface(), flatteningTolerance: flatteningTolerance));
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.get_Device());
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.Device);
        }
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle
// enum type
public typealias CanvasCapStyle = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasDashStyle
// enum type
public typealias CanvasDashStyle = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasDashStyle;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasFigureFill
// enum type
public typealias CanvasFigureFill = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureFill;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasFigureLoop
// enum type
public typealias CanvasFigureLoop = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureLoop;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasFigureSegmentOptions
// enum type
public typealias CanvasFigureSegmentOptions = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureSegmentOptions;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasFilledRegionDetermination
// enum type
public typealias CanvasFilledRegionDetermination = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFilledRegionDetermination;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasGeometry
// runtime class
public class CanvasGeometry
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry;
    public init(plok: Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry { return _self; }
    private struct _ICanvasGeometryStatics {
        static var x : ICanvasGeometryStatics =
            try! RoGetActivationFactory("Microsoft.Graphics.Canvas.Geometry.CanvasGeometry")
    }
    public static var CanvasGeometryStatics : ICanvasGeometryStatics {
        _ICanvasGeometryStatics.x
    }
    public static func CreateRectangle(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, rect : Windows.Foundation.Rect) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreateRectangle(resourceCreator: resourceCreator, rect: rect));
    }
    public static func CreateRectangle(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreateRectangleAtCoords(resourceCreator: resourceCreator, x: x, y: y, w: w, h: h));
    }
    public static func CreateRoundedRectangle(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreateRoundedRectangle(resourceCreator: resourceCreator, rect: rect, radiusX: radiusX, radiusY: radiusY));
    }
    public static func CreateRoundedRectangle(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreateRoundedRectangleAtCoords(resourceCreator: resourceCreator, x: x, y: y, w: w, h: h, radiusX: radiusX, radiusY: radiusY));
    }
    public static func CreateEllipse(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreateEllipse(resourceCreator: resourceCreator, centerPoint: centerPoint, radiusX: radiusX, radiusY: radiusY));
    }
    public static func CreateEllipse(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreateEllipseAtCoords(resourceCreator: resourceCreator, x: x, y: y, radiusX: radiusX, radiusY: radiusY));
    }
    public static func CreateCircle(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreateCircle(resourceCreator: resourceCreator, centerPoint: centerPoint, radius: radius));
    }
    public static func CreateCircle(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, x : Swift.Float, y : Swift.Float, radius : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreateCircleAtCoords(resourceCreator: resourceCreator, x: x, y: y, radius: radius));
    }
    public static func CreatePath(pathBuilder : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasPathBuilder>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreatePath(pathBuilder: pathBuilder!.Interface()));
    }
    public static func CreatePolygon(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, pointsLength : UINT32, points : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreatePolygon(resourceCreator: resourceCreator, pointsLength: pointsLength, points: points));
    }
    public static func CreateGroup(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, geometriesLength : UINT32, geometries : Optional<UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreateGroup(resourceCreator: resourceCreator, geometriesLength: geometriesLength, geometries: geometries));
    }
    public static func CreateGroup(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, geometriesLength : UINT32, geometries : Optional<UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>>, filledRegionDetermination : Microsoft.Graphics.Canvas.Geometry.CanvasFilledRegionDetermination) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreateGroupWithFilledRegionDetermination(resourceCreator: resourceCreator, geometriesLength: geometriesLength, geometries: geometries, filledRegionDetermination: filledRegionDetermination));
    }
    public static func CreateText(textLayout : Optional<Microsoft.Graphics.Canvas.Text.CanvasTextLayout>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreateText(textLayout: textLayout!.Interface()));
    }
    public static func CreateGlyphRun(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, point : Windows.Foundation.Numerics.Vector2, fontFace : Optional<Microsoft.Graphics.Canvas.Text.CanvasFontFace>, fontSize : Swift.Float, glyphsLength : UINT32, glyphs : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasGlyph>>, isSideways : boolean, bidiLevel : Swift.UInt32, measuringMode : Microsoft.Graphics.Canvas.Text.CanvasTextMeasuringMode, glyphOrientation : Microsoft.Graphics.Canvas.Text.CanvasGlyphOrientation) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: CanvasGeometryStatics.CreateGlyphRun(resourceCreator: resourceCreator, point: point, fontFace: fontFace!.Interface(), fontSize: fontSize, glyphsLength: glyphsLength, glyphs: glyphs, isSideways: isSideways, bidiLevel: bidiLevel, measuringMode: measuringMode, glyphOrientation: glyphOrientation));
    }
    public static func ComputeFlatteningTolerance(dpi : Swift.Float, maximumZoomFactor : Swift.Float) throws -> Swift.Float {
        return try CanvasGeometryStatics.ComputeFlatteningTolerance(dpi: dpi, maximumZoomFactor: maximumZoomFactor);
    }
    public static func ComputeFlatteningTolerance(dpi : Swift.Float, maximumZoomFactor : Swift.Float, expectedGeometryTransform : Windows.Foundation.Numerics.Matrix3x2) throws -> Swift.Float {
        return try CanvasGeometryStatics.ComputeFlatteningToleranceWithTransform(dpi: dpi, maximumZoomFactor: maximumZoomFactor, expectedGeometryTransform: expectedGeometryTransform);
    }
    public static func get_DefaultFlatteningTolerance() throws -> Swift.Float {
        return try CanvasGeometryStatics.get_DefaultFlatteningTolerance();
    }
    public static var DefaultFlatteningTolerance : Swift.Float {
        get throws {
        return try CanvasGeometryStatics.DefaultFlatteningTolerance;
        }
    }
    public func CombineWith(otherGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, otherGeometryTransform : Windows.Foundation.Numerics.Matrix3x2, combine : Microsoft.Graphics.Canvas.Geometry.CanvasGeometryCombine) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: _ifc.CombineWith(otherGeometry: otherGeometry!.Interface(), otherGeometryTransform: otherGeometryTransform, combine: combine));
    }
    public func CombineWith(otherGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, otherGeometryTransform : Windows.Foundation.Numerics.Matrix3x2, combine : Microsoft.Graphics.Canvas.Geometry.CanvasGeometryCombine, flatteningTolerance : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: _ifc.CombineWithUsingFlatteningTolerance(otherGeometry: otherGeometry!.Interface(), otherGeometryTransform: otherGeometryTransform, combine: combine, flatteningTolerance: flatteningTolerance));
    }
    public func Stroke(strokeWidth : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: _ifc.Stroke(strokeWidth: strokeWidth));
    }
    public func Stroke(strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: _ifc.StrokeWithStrokeStyle(strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface()));
    }
    public func Stroke(strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>, transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: _ifc.StrokeWithAllOptions(strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface(), transform: transform, flatteningTolerance: flatteningTolerance));
    }
    public func Outline() throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: _ifc.Outline());
    }
    public func Outline(transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: _ifc.OutlineWithTransformAndFlatteningTolerance(transform: transform, flatteningTolerance: flatteningTolerance));
    }
    public func Simplify(simplification : Microsoft.Graphics.Canvas.Geometry.CanvasGeometrySimplification) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: _ifc.Simplify(simplification: simplification));
    }
    public func Simplify(simplification : Microsoft.Graphics.Canvas.Geometry.CanvasGeometrySimplification, transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: _ifc.SimplifyWithTransformAndFlatteningTolerance(simplification: simplification, transform: transform, flatteningTolerance: flatteningTolerance));
    }
    public func Transform(transform : Windows.Foundation.Numerics.Matrix3x2) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry> {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.Geometry.CanvasGeometry(plok: _ifc.Transform(transform: transform));
    }
    public func CompareWith(otherGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>) throws -> Microsoft.Graphics.Canvas.Geometry.CanvasGeometryRelation {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.CompareWith(otherGeometry: otherGeometry!.Interface());
    }
    public func CompareWith(otherGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>, otherGeometryTransform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Microsoft.Graphics.Canvas.Geometry.CanvasGeometryRelation {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.CompareWithUsingTransformAndFlatteningTolerance(otherGeometry: otherGeometry!.Interface(), otherGeometryTransform: otherGeometryTransform, flatteningTolerance: flatteningTolerance);
    }
    public func ComputeArea() throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.ComputeArea();
    }
    public func ComputeArea(transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.ComputeAreaWithTransformAndFlatteningTolerance(transform: transform, flatteningTolerance: flatteningTolerance);
    }
    public func ComputePathLength() throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.ComputePathLength();
    }
    public func ComputePathLength(transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.ComputePathLengthWithTransformAndFlatteningTolerance(transform: transform, flatteningTolerance: flatteningTolerance);
    }
    public func ComputePointOnPath(distance : Swift.Float) throws -> Windows.Foundation.Numerics.Vector2 {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.ComputePointOnPath(distance: distance);
    }
    public func ComputePointOnPath(distance : Swift.Float, tangent : inout Windows.Foundation.Numerics.Vector2) throws -> Windows.Foundation.Numerics.Vector2 {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
            var _tmp_out_tangent: Windows.Foundation.Numerics.Vector2 = _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0);
        return try _ifc.ComputePointOnPathWithTangent(distance: distance, tangent: &_tmp_out_tangent);
    }
    public func ComputePointOnPath(length : Swift.Float, transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float, tangent : inout Windows.Foundation.Numerics.Vector2) throws -> Windows.Foundation.Numerics.Vector2 {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
            var _tmp_out_tangent: Windows.Foundation.Numerics.Vector2 = _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0);
        return try _ifc.ComputePointOnPathWithTransformAndFlatteningToleranceAndTangent(length: length, transform: transform, flatteningTolerance: flatteningTolerance, tangent: &_tmp_out_tangent);
    }
    public func FillContainsPoint(point : Windows.Foundation.Numerics.Vector2) throws -> boolean {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.FillContainsPoint(point: point);
    }
    public func FillContainsPoint(point : Windows.Foundation.Numerics.Vector2, transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> boolean {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.FillContainsPointWithTransformAndFlatteningTolerance(point: point, transform: transform, flatteningTolerance: flatteningTolerance);
    }
    public func ComputeBounds() throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.ComputeBounds();
    }
    public func ComputeBounds(transform : Windows.Foundation.Numerics.Matrix3x2) throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.ComputeBoundsWithTransform(transform: transform);
    }
    public func ComputeStrokeBounds(strokeWidth : Swift.Float) throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.ComputeStrokeBounds(strokeWidth: strokeWidth);
    }
    public func ComputeStrokeBounds(strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.ComputeStrokeBoundsWithStrokeStyle(strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func ComputeStrokeBounds(strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>, transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.ComputeStrokeBoundsWithAllOptions(strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface(), transform: transform, flatteningTolerance: flatteningTolerance);
    }
    public func StrokeContainsPoint(point : Windows.Foundation.Numerics.Vector2, strokeWidth : Swift.Float) throws -> boolean {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.StrokeContainsPoint(point: point, strokeWidth: strokeWidth);
    }
    public func StrokeContainsPoint(point : Windows.Foundation.Numerics.Vector2, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>) throws -> boolean {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.StrokeContainsPointWithStrokeStyle(point: point, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface());
    }
    public func StrokeContainsPoint(point : Windows.Foundation.Numerics.Vector2, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle>, transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> boolean {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.StrokeContainsPointWithAllOptions(point: point, strokeWidth: strokeWidth, strokeStyle: strokeStyle!.Interface(), transform: transform, flatteningTolerance: flatteningTolerance);
    }
    public func Tessellate() throws -> UINT32 {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.Tessellate();
    }
    public func Tessellate(transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> UINT32 {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.TessellateWithTransformAndFlatteningTolerance(transform: transform, flatteningTolerance: flatteningTolerance);
    }
    public func SendPathTo(streamReader : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasPathReceiver>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try _ifc.SendPathTo(streamReader: streamReader);
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.get_Device());
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.Device);
        }
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
    // instance interface not needed: Windows.Graphics.IGeometrySource2D
}

// type: Microsoft.Graphics.Canvas.Geometry.CanvasGeometryCombine
// enum type
public typealias CanvasGeometryCombine = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryCombine;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasGeometryRelation
// enum type
public typealias CanvasGeometryRelation = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryRelation;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasGeometrySimplification
// enum type
public typealias CanvasGeometrySimplification = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometrySimplification;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasGradientMesh
// runtime class
public class CanvasGradientMesh
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh;
    public init(plok: Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh { return _self; }
    public init(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, patchElementsLength : UINT32, patchElements : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch>>) throws {
        let _af : ICanvasGradientMeshFactory = try RoGetActivationFactory("Microsoft.Graphics.Canvas.Geometry.CanvasGradientMesh");
        _self = try _af.Create(resourceCreator: resourceCreator, patchElementsLength: patchElementsLength, patchElements: patchElements)!;
        try super.init(plok: _self.QueryInterface())
    }
    private struct _ICanvasGradientMeshStatics {
        static var x : ICanvasGradientMeshStatics =
            try! RoGetActivationFactory("Microsoft.Graphics.Canvas.Geometry.CanvasGradientMesh")
    }
    public static var CanvasGradientMeshStatics : ICanvasGradientMeshStatics {
        _ICanvasGradientMeshStatics.x
    }
    public static func CreateCoonsPatch(pointsLength : UINT32, points : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>>, colorsLength : UINT32, colors : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector4>>, edgesLength : UINT32, edges : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge>>) throws -> Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatch {
        return try CanvasGradientMeshStatics.CreateCoonsPatch(pointsLength: pointsLength, points: points, colorsLength: colorsLength, colors: colors, edgesLength: edgesLength, edges: edges);
    }
    public static func CreateTensorPatch(pointsLength : UINT32, points : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>>, colorsLength : UINT32, colors : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector4>>, edgesLength : UINT32, edges : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge>>) throws -> Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatch {
        return try CanvasGradientMeshStatics.CreateTensorPatch(pointsLength: pointsLength, points: points, colorsLength: colorsLength, colors: colors, edgesLength: edgesLength, edges: edges);
    }
    public func get_Patches() throws -> UINT32 {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh = try _self.QueryInterface();
        return try _ifc.get_Patches();
    }
    public func GetBounds(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>) throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh = try _self.QueryInterface();
        return try _ifc.GetBounds(resourceCreator: resourceCreator);
    }
    public func GetBounds(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, transform : Windows.Foundation.Numerics.Matrix3x2) throws -> Windows.Foundation.Rect {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh = try _self.QueryInterface();
        return try _ifc.GetBoundsWithTransform(resourceCreator: resourceCreator, transform: transform);
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.get_Device());
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.CanvasDevice> {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh = try _self.QueryInterface();
        return try Microsoft.Graphics.Canvas.CanvasDevice(plok: _ifc.Device);
        }
    }
    public var Patches : UINT32 {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh = try _self.QueryInterface();
        return try _ifc.Patches;
        }
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatch
// struct type
public typealias CanvasGradientMeshPatch = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatchEdge
// enum type
public typealias CanvasGradientMeshPatchEdge = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasLineJoin
// enum type
public typealias CanvasLineJoin = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasLineJoin;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasPathBuilder
// runtime class
public class CanvasPathBuilder
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder;
    public init(plok: Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder { return _self; }
    public init(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>) throws {
        let _af : ICanvasPathBuilderFactory = try RoGetActivationFactory("Microsoft.Graphics.Canvas.Geometry.CanvasPathBuilder");
        _self = try _af.Create(resourceCreator: resourceCreator)!;
        try super.init(plok: _self.QueryInterface())
    }
    public func BeginFigure(startPoint : Windows.Foundation.Numerics.Vector2, figureFill : Microsoft.Graphics.Canvas.Geometry.CanvasFigureFill) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.BeginFigureWithFigureFill(startPoint: startPoint, figureFill: figureFill);
    }
    public func BeginFigure(startPoint : Windows.Foundation.Numerics.Vector2) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.BeginFigure(startPoint: startPoint);
    }
    public func BeginFigure(startX : Swift.Float, startY : Swift.Float, figureFill : Microsoft.Graphics.Canvas.Geometry.CanvasFigureFill) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.BeginFigureAtCoordsWithFigureFill(startX: startX, startY: startY, figureFill: figureFill);
    }
    public func BeginFigure(startX : Swift.Float, startY : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.BeginFigureAtCoords(startX: startX, startY: startY);
    }
    public func AddArc(endPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, rotationAngle : Swift.Float, sweepDirection : Microsoft.Graphics.Canvas.Geometry.CanvasSweepDirection, arcSize : Microsoft.Graphics.Canvas.Geometry.CanvasArcSize) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.AddArcToPoint(endPoint: endPoint, radiusX: radiusX, radiusY: radiusY, rotationAngle: rotationAngle, sweepDirection: sweepDirection, arcSize: arcSize);
    }
    public func AddArc(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, startAngle : Swift.Float, sweepAngle : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.AddArcAroundEllipse(centerPoint: centerPoint, radiusX: radiusX, radiusY: radiusY, startAngle: startAngle, sweepAngle: sweepAngle);
    }
    public func AddCubicBezier(controlPoint1 : Windows.Foundation.Numerics.Vector2, controlPoint2 : Windows.Foundation.Numerics.Vector2, endPoint : Windows.Foundation.Numerics.Vector2) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.AddCubicBezier(controlPoint1: controlPoint1, controlPoint2: controlPoint2, endPoint: endPoint);
    }
    public func AddLine(endPoint : Windows.Foundation.Numerics.Vector2) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.AddLine(endPoint: endPoint);
    }
    public func AddLine(x : Swift.Float, y : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.AddLineWithCoords(x: x, y: y);
    }
    public func AddQuadraticBezier(controlPoint : Windows.Foundation.Numerics.Vector2, endPoint : Windows.Foundation.Numerics.Vector2) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.AddQuadraticBezier(controlPoint: controlPoint, endPoint: endPoint);
    }
    public func SetFilledRegionDetermination(filledRegionDetermination : Microsoft.Graphics.Canvas.Geometry.CanvasFilledRegionDetermination) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.SetFilledRegionDetermination(filledRegionDetermination: filledRegionDetermination);
    }
    public func SetSegmentOptions(figureSegmentOptions : Microsoft.Graphics.Canvas.Geometry.CanvasFigureSegmentOptions) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.SetSegmentOptions(figureSegmentOptions: figureSegmentOptions);
    }
    public func EndFigure(figureLoop : Microsoft.Graphics.Canvas.Geometry.CanvasFigureLoop) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.EndFigure(figureLoop: figureLoop);
    }
    public func AddGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.CanvasGeometry>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder = try _self.QueryInterface();
        return try _ifc.AddGeometry(geometry: geometry!.Interface());
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle
// runtime class
public class CanvasStrokeStyle
    :
    WinRT.Object
{
    private var _self : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle;
    public init(plok: Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle { return _self; }
    public init() throws {
        _self = try RoActivateInstance("Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle")
        try super.init(plok: _self.QueryInterface())
    }
    public func get_StartCap() throws -> Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.get_StartCap();
    }
    public func put_StartCap(value : Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.put_StartCap(value: value);
    }
    public func get_EndCap() throws -> Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.get_EndCap();
    }
    public func put_EndCap(value : Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.put_EndCap(value: value);
    }
    public func get_DashCap() throws -> Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.get_DashCap();
    }
    public func put_DashCap(value : Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.put_DashCap(value: value);
    }
    public func get_LineJoin() throws -> Microsoft.Graphics.Canvas.Geometry.CanvasLineJoin {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.get_LineJoin();
    }
    public func put_LineJoin(value : Microsoft.Graphics.Canvas.Geometry.CanvasLineJoin) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.put_LineJoin(value: value);
    }
    public func get_MiterLimit() throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.get_MiterLimit();
    }
    public func put_MiterLimit(value : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.put_MiterLimit(value: value);
    }
    public func get_DashStyle() throws -> Microsoft.Graphics.Canvas.Geometry.CanvasDashStyle {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.get_DashStyle();
    }
    public func put_DashStyle(value : Microsoft.Graphics.Canvas.Geometry.CanvasDashStyle) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.put_DashStyle(value: value);
    }
    public func get_DashOffset() throws -> Swift.Float {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.get_DashOffset();
    }
    public func put_DashOffset(value : Swift.Float) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.put_DashOffset(value: value);
    }
    public func get_CustomDashStyle() throws -> UINT32 {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.get_CustomDashStyle();
    }
    public func put_CustomDashStyle(valueElementsLength : UINT32, valueElements : Optional<UnsafeMutablePointer<FLOAT>>) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.put_CustomDashStyle(valueElementsLength: valueElementsLength, valueElements: valueElements);
    }
    public func get_TransformBehavior() throws -> Microsoft.Graphics.Canvas.Geometry.CanvasStrokeTransformBehavior {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.get_TransformBehavior();
    }
    public func put_TransformBehavior(value : Microsoft.Graphics.Canvas.Geometry.CanvasStrokeTransformBehavior) throws -> Void {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.put_TransformBehavior(value: value);
    }
    public var CustomDashStyle : UINT32 {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.CustomDashStyle;
        }
    }
    public var DashCap : Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.DashCap;
        }
    }
    public var DashOffset : Swift.Float {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.DashOffset;
        }
    }
    public var DashStyle : Microsoft.Graphics.Canvas.Geometry.CanvasDashStyle {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.DashStyle;
        }
    }
    public var EndCap : Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.EndCap;
        }
    }
    public var LineJoin : Microsoft.Graphics.Canvas.Geometry.CanvasLineJoin {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.LineJoin;
        }
    }
    public var MiterLimit : Swift.Float {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.MiterLimit;
        }
    }
    public var StartCap : Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.StartCap;
        }
    }
    public var TransformBehavior : Microsoft.Graphics.Canvas.Geometry.CanvasStrokeTransformBehavior {
        get throws {
        let _ifc : Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle = try _self.QueryInterface();
        return try _ifc.TransformBehavior;
        }
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.Geometry.CanvasStrokeTransformBehavior
// enum type
public typealias CanvasStrokeTransformBehavior = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasStrokeTransformBehavior;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasSweepDirection
// enum type
public typealias CanvasSweepDirection = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasSweepDirection;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasTriangleVertices
// struct type
public typealias CanvasTriangleVertices = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasTriangleVertices;

// type: Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry
// interface type
open class ICanvasCachedGeometry
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xba6cb114, Data2: 0xe1a1, Data3 : 0x448d, Data4 : (0xab, 0x7c, 0x8d, 0x2b, 0x92, 0x67, 0x41, 0x19)) }
    // [IsSpecialName] Microsoft.Graphics.Canvas.CanvasDevice get_Device()
    private func _n_get_Device(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Device(pThis, __presult))
        }
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>> = nil;
        try self._n_get_Device(&__result);
        return Microsoft.Graphics.Canvas.ICanvasDevice(consuming: __result);
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        get throws {
            return try get_Device();
        }
    }
} // ICanvasCachedGeometry


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometryStatics
// interface type
open class ICanvasCachedGeometryStatics
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x80ba1060, Data2: 0xa9d7, Data3 : 0x41ba, Data4 : (0x93, 0x72, 0xec, 0x3f, 0xc1, 0x74, 0x4e, 0x5d)) }
    // Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry CreateFill(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry)
    private func _n_CreateFill(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFill(pThis, geometry, __presult))
        }
    }
    public func CreateFill(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>> = nil;
        try self._n_CreateFill(RawPointer(geometry), &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry CreateFill(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, System.Single)
    private func _n_CreateFillWithFlatteningTolerance(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ flatteningTolerance : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFillWithFlatteningTolerance(pThis, geometry, flatteningTolerance, __presult))
        }
    }
    public func CreateFillWithFlatteningTolerance(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, flatteningTolerance : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>> = nil;
        try self._n_CreateFillWithFlatteningTolerance(RawPointer(geometry), flatteningTolerance, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry CreateStroke(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, System.Single)
    private func _n_CreateStroke(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ strokeWidth : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateStroke(pThis, geometry, strokeWidth, __presult))
        }
    }
    public func CreateStroke(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, strokeWidth : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>> = nil;
        try self._n_CreateStroke(RawPointer(geometry), strokeWidth, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry CreateStroke(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_CreateStrokeWithStrokeStyle(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateStrokeWithStrokeStyle(pThis, geometry, strokeWidth, strokeStyle, __presult))
        }
    }
    public func CreateStrokeWithStrokeStyle(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>> = nil;
        try self._n_CreateStrokeWithStrokeStyle(RawPointer(geometry), strokeWidth, RawPointer(strokeStyle), &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry CreateStroke(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle, System.Single)
    private func _n_CreateStrokeWithStrokeStyleAndFlatteningTolerance(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>, _ flatteningTolerance : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateStrokeWithStrokeStyleAndFlatteningTolerance(pThis, geometry, strokeWidth, strokeStyle, flatteningTolerance, __presult))
        }
    }
    public func CreateStrokeWithStrokeStyleAndFlatteningTolerance(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>, flatteningTolerance : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasCachedGeometry>> = nil;
        try self._n_CreateStrokeWithStrokeStyleAndFlatteningTolerance(RawPointer(geometry), strokeWidth, RawPointer(strokeStyle), flatteningTolerance, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry(consuming: __result);
    }
} // ICanvasCachedGeometryStatics


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry
// interface type
open class ICanvasGeometry
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x74ea89fa, Data2: 0xc87c, Data3 : 0x4d0d, Data4 : (0x90, 0x57, 0x27, 0x43, 0xb8, 0xdb, 0x67, 0xee)) }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CombineWith(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Matrix3x2, Microsoft.Graphics.Canvas.Geometry.CanvasGeometryCombine)
    private func _n_CombineWith(_ otherGeometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ otherGeometryTransform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ combine : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryCombine, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CombineWith(pThis, otherGeometry, otherGeometryTransform, combine, __presult))
        }
    }
    public func CombineWith(otherGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, otherGeometryTransform : Windows.Foundation.Numerics.Matrix3x2, combine : Microsoft.Graphics.Canvas.Geometry.CanvasGeometryCombine) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CombineWith(RawPointer(otherGeometry), otherGeometryTransform, combine, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CombineWith(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Matrix3x2, Microsoft.Graphics.Canvas.Geometry.CanvasGeometryCombine, System.Single)
    private func _n_CombineWithUsingFlatteningTolerance(_ otherGeometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ otherGeometryTransform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ combine : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryCombine, _ flatteningTolerance : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CombineWithUsingFlatteningTolerance(pThis, otherGeometry, otherGeometryTransform, combine, flatteningTolerance, __presult))
        }
    }
    public func CombineWithUsingFlatteningTolerance(otherGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, otherGeometryTransform : Windows.Foundation.Numerics.Matrix3x2, combine : Microsoft.Graphics.Canvas.Geometry.CanvasGeometryCombine, flatteningTolerance : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CombineWithUsingFlatteningTolerance(RawPointer(otherGeometry), otherGeometryTransform, combine, flatteningTolerance, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry Stroke(System.Single)
    private func _n_Stroke(_ strokeWidth : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Stroke(pThis, strokeWidth, __presult))
        }
    }
    public func Stroke(strokeWidth : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_Stroke(strokeWidth, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry Stroke(System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_StrokeWithStrokeStyle(_ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.StrokeWithStrokeStyle(pThis, strokeWidth, strokeStyle, __presult))
        }
    }
    public func StrokeWithStrokeStyle(strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_StrokeWithStrokeStyle(strokeWidth, RawPointer(strokeStyle), &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry Stroke(System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle, Windows.Foundation.Numerics.Matrix3x2, System.Single)
    private func _n_StrokeWithAllOptions(_ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ flatteningTolerance : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.StrokeWithAllOptions(pThis, strokeWidth, strokeStyle, transform, flatteningTolerance, __presult))
        }
    }
    public func StrokeWithAllOptions(strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>, transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_StrokeWithAllOptions(strokeWidth, RawPointer(strokeStyle), transform, flatteningTolerance, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry Outline()
    private func _n_Outline(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Outline(pThis, __presult))
        }
    }
    public func Outline() throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_Outline(&__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry Outline(Windows.Foundation.Numerics.Matrix3x2, System.Single)
    private func _n_OutlineWithTransformAndFlatteningTolerance(_ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ flatteningTolerance : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.OutlineWithTransformAndFlatteningTolerance(pThis, transform, flatteningTolerance, __presult))
        }
    }
    public func OutlineWithTransformAndFlatteningTolerance(transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_OutlineWithTransformAndFlatteningTolerance(transform, flatteningTolerance, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry Simplify(Microsoft.Graphics.Canvas.Geometry.CanvasGeometrySimplification)
    private func _n_Simplify(_ simplification : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometrySimplification, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Simplify(pThis, simplification, __presult))
        }
    }
    public func Simplify(simplification : Microsoft.Graphics.Canvas.Geometry.CanvasGeometrySimplification) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_Simplify(simplification, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry Simplify(Microsoft.Graphics.Canvas.Geometry.CanvasGeometrySimplification, Windows.Foundation.Numerics.Matrix3x2, System.Single)
    private func _n_SimplifyWithTransformAndFlatteningTolerance(_ simplification : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometrySimplification, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ flatteningTolerance : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SimplifyWithTransformAndFlatteningTolerance(pThis, simplification, transform, flatteningTolerance, __presult))
        }
    }
    public func SimplifyWithTransformAndFlatteningTolerance(simplification : Microsoft.Graphics.Canvas.Geometry.CanvasGeometrySimplification, transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_SimplifyWithTransformAndFlatteningTolerance(simplification, transform, flatteningTolerance, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry Transform(Windows.Foundation.Numerics.Matrix3x2)
    private func _n_Transform(_ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Transform(pThis, transform, __presult))
        }
    }
    public func Transform(transform : Windows.Foundation.Numerics.Matrix3x2) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_Transform(transform, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometryRelation CompareWith(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry)
    private func _n_CompareWith(_ otherGeometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryRelation>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CompareWith(pThis, otherGeometry, __presult))
        }
    }
    public func CompareWith(otherGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>) throws -> Microsoft.Graphics.Canvas.Geometry.CanvasGeometryRelation {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryRelation = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryRelation_Disjoint;
        try self._n_CompareWith(RawPointer(otherGeometry), &__result);
        return __result;
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometryRelation CompareWith(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry, Windows.Foundation.Numerics.Matrix3x2, System.Single)
    private func _n_CompareWithUsingTransformAndFlatteningTolerance(_ otherGeometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>, _ otherGeometryTransform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ flatteningTolerance : FLOAT, _ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryRelation>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CompareWithUsingTransformAndFlatteningTolerance(pThis, otherGeometry, otherGeometryTransform, flatteningTolerance, __presult))
        }
    }
    public func CompareWithUsingTransformAndFlatteningTolerance(otherGeometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>, otherGeometryTransform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Microsoft.Graphics.Canvas.Geometry.CanvasGeometryRelation {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryRelation = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryRelation_Disjoint;
        try self._n_CompareWithUsingTransformAndFlatteningTolerance(RawPointer(otherGeometry), otherGeometryTransform, flatteningTolerance, &__result);
        return __result;
    }
    // System.Single ComputeArea()
    private func _n_ComputeArea(_ __presult: UnsafeMutablePointer<FLOAT>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputeArea(pThis, __presult))
        }
    }
    public func ComputeArea() throws -> Swift.Float {
        var __result : FLOAT = 0;
        try self._n_ComputeArea(&__result);
        return __result;
    }
    // System.Single ComputeArea(Windows.Foundation.Numerics.Matrix3x2, System.Single)
    private func _n_ComputeAreaWithTransformAndFlatteningTolerance(_ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ flatteningTolerance : FLOAT, _ __presult: UnsafeMutablePointer<FLOAT>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputeAreaWithTransformAndFlatteningTolerance(pThis, transform, flatteningTolerance, __presult))
        }
    }
    public func ComputeAreaWithTransformAndFlatteningTolerance(transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Swift.Float {
        var __result : FLOAT = 0;
        try self._n_ComputeAreaWithTransformAndFlatteningTolerance(transform, flatteningTolerance, &__result);
        return __result;
    }
    // System.Single ComputePathLength()
    private func _n_ComputePathLength(_ __presult: UnsafeMutablePointer<FLOAT>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputePathLength(pThis, __presult))
        }
    }
    public func ComputePathLength() throws -> Swift.Float {
        var __result : FLOAT = 0;
        try self._n_ComputePathLength(&__result);
        return __result;
    }
    // System.Single ComputePathLength(Windows.Foundation.Numerics.Matrix3x2, System.Single)
    private func _n_ComputePathLengthWithTransformAndFlatteningTolerance(_ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ flatteningTolerance : FLOAT, _ __presult: UnsafeMutablePointer<FLOAT>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputePathLengthWithTransformAndFlatteningTolerance(pThis, transform, flatteningTolerance, __presult))
        }
    }
    public func ComputePathLengthWithTransformAndFlatteningTolerance(transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Swift.Float {
        var __result : FLOAT = 0;
        try self._n_ComputePathLengthWithTransformAndFlatteningTolerance(transform, flatteningTolerance, &__result);
        return __result;
    }
    // Windows.Foundation.Numerics.Vector2 ComputePointOnPath(System.Single)
    private func _n_ComputePointOnPath(_ distance : FLOAT, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputePointOnPath(pThis, distance, __presult))
        }
    }
    public func ComputePointOnPath(distance : Swift.Float) throws -> Windows.Foundation.Numerics.Vector2 {
        var __result : _q_CWindows_CFoundation_CNumerics_CVector2 = _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0);
        try self._n_ComputePointOnPath(distance, &__result);
        return __result;
    }
    // Windows.Foundation.Numerics.Vector2 ComputePointOnPath(System.Single, ref Windows.Foundation.Numerics.Vector2)
    private func _n_ComputePointOnPathWithTangent(_ distance : FLOAT, _ tangent : UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputePointOnPathWithTangent(pThis, distance, tangent, __presult))
        }
    }
    public func ComputePointOnPathWithTangent(distance : Swift.Float, tangent : inout Windows.Foundation.Numerics.Vector2) throws -> Windows.Foundation.Numerics.Vector2 {
        var __result : _q_CWindows_CFoundation_CNumerics_CVector2 = _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0);
            var _tmp_out_tangent: _q_CWindows_CFoundation_CNumerics_CVector2 = _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0);
        try self._n_ComputePointOnPathWithTangent(distance, &_tmp_out_tangent, &__result);
            tangent = _tmp_out_tangent;
        return __result;
    }
    // Windows.Foundation.Numerics.Vector2 ComputePointOnPath(System.Single, Windows.Foundation.Numerics.Matrix3x2, System.Single, ref Windows.Foundation.Numerics.Vector2)
    private func _n_ComputePointOnPathWithTransformAndFlatteningToleranceAndTangent(_ length : FLOAT, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ flatteningTolerance : FLOAT, _ tangent : UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputePointOnPathWithTransformAndFlatteningToleranceAndTangent(pThis, length, transform, flatteningTolerance, tangent, __presult))
        }
    }
    public func ComputePointOnPathWithTransformAndFlatteningToleranceAndTangent(length : Swift.Float, transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float, tangent : inout Windows.Foundation.Numerics.Vector2) throws -> Windows.Foundation.Numerics.Vector2 {
        var __result : _q_CWindows_CFoundation_CNumerics_CVector2 = _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0);
            var _tmp_out_tangent: _q_CWindows_CFoundation_CNumerics_CVector2 = _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0);
        try self._n_ComputePointOnPathWithTransformAndFlatteningToleranceAndTangent(length, transform, flatteningTolerance, &_tmp_out_tangent, &__result);
            tangent = _tmp_out_tangent;
        return __result;
    }
    // bool FillContainsPoint(Windows.Foundation.Numerics.Vector2)
    private func _n_FillContainsPoint(_ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillContainsPoint(pThis, point, __presult))
        }
    }
    public func FillContainsPoint(point : Windows.Foundation.Numerics.Vector2) throws -> boolean {
        var __result : boolean = 0;
        try self._n_FillContainsPoint(point, &__result);
        return __result;
    }
    // bool FillContainsPoint(Windows.Foundation.Numerics.Vector2, Windows.Foundation.Numerics.Matrix3x2, System.Single)
    private func _n_FillContainsPointWithTransformAndFlatteningTolerance(_ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ flatteningTolerance : FLOAT, _ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FillContainsPointWithTransformAndFlatteningTolerance(pThis, point, transform, flatteningTolerance, __presult))
        }
    }
    public func FillContainsPointWithTransformAndFlatteningTolerance(point : Windows.Foundation.Numerics.Vector2, transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> boolean {
        var __result : boolean = 0;
        try self._n_FillContainsPointWithTransformAndFlatteningTolerance(point, transform, flatteningTolerance, &__result);
        return __result;
    }
    // Windows.Foundation.Rect ComputeBounds()
    private func _n_ComputeBounds(_ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CRect>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputeBounds(pThis, __presult))
        }
    }
    public func ComputeBounds() throws -> Windows.Foundation.Rect {
        var __result : _q_CWindows_CFoundation_CRect = _q_CWindows_CFoundation_CRect(X: 0, Y: 0, Width: 0, Height: 0);
        try self._n_ComputeBounds(&__result);
        return __result;
    }
    // Windows.Foundation.Rect ComputeBounds(Windows.Foundation.Numerics.Matrix3x2)
    private func _n_ComputeBoundsWithTransform(_ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CRect>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputeBoundsWithTransform(pThis, transform, __presult))
        }
    }
    public func ComputeBoundsWithTransform(transform : Windows.Foundation.Numerics.Matrix3x2) throws -> Windows.Foundation.Rect {
        var __result : _q_CWindows_CFoundation_CRect = _q_CWindows_CFoundation_CRect(X: 0, Y: 0, Width: 0, Height: 0);
        try self._n_ComputeBoundsWithTransform(transform, &__result);
        return __result;
    }
    // Windows.Foundation.Rect ComputeStrokeBounds(System.Single)
    private func _n_ComputeStrokeBounds(_ strokeWidth : FLOAT, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CRect>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputeStrokeBounds(pThis, strokeWidth, __presult))
        }
    }
    public func ComputeStrokeBounds(strokeWidth : Swift.Float) throws -> Windows.Foundation.Rect {
        var __result : _q_CWindows_CFoundation_CRect = _q_CWindows_CFoundation_CRect(X: 0, Y: 0, Width: 0, Height: 0);
        try self._n_ComputeStrokeBounds(strokeWidth, &__result);
        return __result;
    }
    // Windows.Foundation.Rect ComputeStrokeBounds(System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_ComputeStrokeBoundsWithStrokeStyle(_ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CRect>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputeStrokeBoundsWithStrokeStyle(pThis, strokeWidth, strokeStyle, __presult))
        }
    }
    public func ComputeStrokeBoundsWithStrokeStyle(strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> Windows.Foundation.Rect {
        var __result : _q_CWindows_CFoundation_CRect = _q_CWindows_CFoundation_CRect(X: 0, Y: 0, Width: 0, Height: 0);
        try self._n_ComputeStrokeBoundsWithStrokeStyle(strokeWidth, RawPointer(strokeStyle), &__result);
        return __result;
    }
    // Windows.Foundation.Rect ComputeStrokeBounds(System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle, Windows.Foundation.Numerics.Matrix3x2, System.Single)
    private func _n_ComputeStrokeBoundsWithAllOptions(_ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ flatteningTolerance : FLOAT, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CRect>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputeStrokeBoundsWithAllOptions(pThis, strokeWidth, strokeStyle, transform, flatteningTolerance, __presult))
        }
    }
    public func ComputeStrokeBoundsWithAllOptions(strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>, transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> Windows.Foundation.Rect {
        var __result : _q_CWindows_CFoundation_CRect = _q_CWindows_CFoundation_CRect(X: 0, Y: 0, Width: 0, Height: 0);
        try self._n_ComputeStrokeBoundsWithAllOptions(strokeWidth, RawPointer(strokeStyle), transform, flatteningTolerance, &__result);
        return __result;
    }
    // bool StrokeContainsPoint(Windows.Foundation.Numerics.Vector2, System.Single)
    private func _n_StrokeContainsPoint(_ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ strokeWidth : FLOAT, _ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.StrokeContainsPoint(pThis, point, strokeWidth, __presult))
        }
    }
    public func StrokeContainsPoint(point : Windows.Foundation.Numerics.Vector2, strokeWidth : Swift.Float) throws -> boolean {
        var __result : boolean = 0;
        try self._n_StrokeContainsPoint(point, strokeWidth, &__result);
        return __result;
    }
    // bool StrokeContainsPoint(Windows.Foundation.Numerics.Vector2, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle)
    private func _n_StrokeContainsPointWithStrokeStyle(_ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>, _ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.StrokeContainsPointWithStrokeStyle(pThis, point, strokeWidth, strokeStyle, __presult))
        }
    }
    public func StrokeContainsPointWithStrokeStyle(point : Windows.Foundation.Numerics.Vector2, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>) throws -> boolean {
        var __result : boolean = 0;
        try self._n_StrokeContainsPointWithStrokeStyle(point, strokeWidth, RawPointer(strokeStyle), &__result);
        return __result;
    }
    // bool StrokeContainsPoint(Windows.Foundation.Numerics.Vector2, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle, Windows.Foundation.Numerics.Matrix3x2, System.Single)
    private func _n_StrokeContainsPointWithAllOptions(_ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ strokeWidth : FLOAT, _ strokeStyle : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle>>, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ flatteningTolerance : FLOAT, _ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.StrokeContainsPointWithAllOptions(pThis, point, strokeWidth, strokeStyle, transform, flatteningTolerance, __presult))
        }
    }
    public func StrokeContainsPointWithAllOptions(point : Windows.Foundation.Numerics.Vector2, strokeWidth : Swift.Float, strokeStyle : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle>, transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> boolean {
        var __result : boolean = 0;
        try self._n_StrokeContainsPointWithAllOptions(point, strokeWidth, RawPointer(strokeStyle), transform, flatteningTolerance, &__result);
        return __result;
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasTriangleVertices[] Tessellate()
    private func _n_Tessellate(_ __presultLength: UnsafeMutablePointer<UINT32>?, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasTriangleVertices>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Tessellate(pThis, __presultLength, __presult))
        }
    }
    public func Tessellate() throws -> UINT32 {
        var __resultLength : UINT32 = 0;
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasTriangleVertices>> = nil;
        try self._n_Tessellate(&__resultLength, &__result);
        return __resultLength;
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasTriangleVertices[] Tessellate(Windows.Foundation.Numerics.Matrix3x2, System.Single)
    private func _n_TessellateWithTransformAndFlatteningTolerance(_ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ flatteningTolerance : FLOAT, _ __presultLength: UnsafeMutablePointer<UINT32>?, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasTriangleVertices>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.TessellateWithTransformAndFlatteningTolerance(pThis, transform, flatteningTolerance, __presultLength, __presult))
        }
    }
    public func TessellateWithTransformAndFlatteningTolerance(transform : Windows.Foundation.Numerics.Matrix3x2, flatteningTolerance : Swift.Float) throws -> UINT32 {
        var __resultLength : UINT32 = 0;
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasTriangleVertices>> = nil;
        try self._n_TessellateWithTransformAndFlatteningTolerance(transform, flatteningTolerance, &__resultLength, &__result);
        return __resultLength;
    }
    // void SendPathTo(Microsoft.Graphics.Canvas.Geometry.ICanvasPathReceiver)
    private func _n_SendPathTo(_ streamReader : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathReceiver>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SendPathTo(pThis, streamReader))
        }
    }
    public func SendPathTo(streamReader : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasPathReceiver>) throws -> Void {
        try self._n_SendPathTo(RawPointer(streamReader));
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.CanvasDevice get_Device()
    private func _n_get_Device(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Device(pThis, __presult))
        }
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>> = nil;
        try self._n_get_Device(&__result);
        return Microsoft.Graphics.Canvas.ICanvasDevice(consuming: __result);
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        get throws {
            return try get_Device();
        }
    }
} // ICanvasGeometry


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasGeometryStatics
// interface type
open class ICanvasGeometryStatics
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xd94e33cf, Data2: 0xcd59, Data3 : 0x46f2, Data4 : (0x8d, 0xf4, 0x55, 0x06, 0x6a, 0xab, 0xfd, 0x56)) }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreateRectangle(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Rect)
    private func _n_CreateRectangle(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ rect : _q_CWindows_CFoundation_CRect, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateRectangle(pThis, resourceCreator, rect, __presult))
        }
    }
    public func CreateRectangle(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, rect : Windows.Foundation.Rect) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreateRectangle(RawPointer(resourceCreator), rect, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreateRectangle(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.Single, System.Single, System.Single, System.Single)
    private func _n_CreateRectangleAtCoords(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateRectangleAtCoords(pThis, resourceCreator, x, y, w, h, __presult))
        }
    }
    public func CreateRectangleAtCoords(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreateRectangleAtCoords(RawPointer(resourceCreator), x, y, w, h, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreateRoundedRectangle(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Rect, System.Single, System.Single)
    private func _n_CreateRoundedRectangle(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ rect : _q_CWindows_CFoundation_CRect, _ radiusX : FLOAT, _ radiusY : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateRoundedRectangle(pThis, resourceCreator, rect, radiusX, radiusY, __presult))
        }
    }
    public func CreateRoundedRectangle(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, rect : Windows.Foundation.Rect, radiusX : Swift.Float, radiusY : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreateRoundedRectangle(RawPointer(resourceCreator), rect, radiusX, radiusY, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreateRoundedRectangle(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.Single, System.Single, System.Single, System.Single, System.Single, System.Single)
    private func _n_CreateRoundedRectangleAtCoords(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ x : FLOAT, _ y : FLOAT, _ w : FLOAT, _ h : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateRoundedRectangleAtCoords(pThis, resourceCreator, x, y, w, h, radiusX, radiusY, __presult))
        }
    }
    public func CreateRoundedRectangleAtCoords(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, x : Swift.Float, y : Swift.Float, w : Swift.Float, h : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreateRoundedRectangleAtCoords(RawPointer(resourceCreator), x, y, w, h, radiusX, radiusY, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreateEllipse(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Numerics.Vector2, System.Single, System.Single)
    private func _n_CreateEllipse(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radiusX : FLOAT, _ radiusY : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateEllipse(pThis, resourceCreator, centerPoint, radiusX, radiusY, __presult))
        }
    }
    public func CreateEllipse(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreateEllipse(RawPointer(resourceCreator), centerPoint, radiusX, radiusY, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreateEllipse(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.Single, System.Single, System.Single, System.Single)
    private func _n_CreateEllipseAtCoords(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ x : FLOAT, _ y : FLOAT, _ radiusX : FLOAT, _ radiusY : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateEllipseAtCoords(pThis, resourceCreator, x, y, radiusX, radiusY, __presult))
        }
    }
    public func CreateEllipseAtCoords(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, x : Swift.Float, y : Swift.Float, radiusX : Swift.Float, radiusY : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreateEllipseAtCoords(RawPointer(resourceCreator), x, y, radiusX, radiusY, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreateCircle(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Numerics.Vector2, System.Single)
    private func _n_CreateCircle(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radius : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateCircle(pThis, resourceCreator, centerPoint, radius, __presult))
        }
    }
    public func CreateCircle(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, centerPoint : Windows.Foundation.Numerics.Vector2, radius : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreateCircle(RawPointer(resourceCreator), centerPoint, radius, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreateCircle(Microsoft.Graphics.Canvas.ICanvasResourceCreator, System.Single, System.Single, System.Single)
    private func _n_CreateCircleAtCoords(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ x : FLOAT, _ y : FLOAT, _ radius : FLOAT, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateCircleAtCoords(pThis, resourceCreator, x, y, radius, __presult))
        }
    }
    public func CreateCircleAtCoords(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, x : Swift.Float, y : Swift.Float, radius : Swift.Float) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreateCircleAtCoords(RawPointer(resourceCreator), x, y, radius, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreatePath(Microsoft.Graphics.Canvas.Geometry.CanvasPathBuilder)
    private func _n_CreatePath(_ pathBuilder : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreatePath(pThis, pathBuilder, __presult))
        }
    }
    public func CreatePath(pathBuilder : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreatePath(RawPointer(pathBuilder), &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreatePolygon(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Numerics.Vector2[])
    private func _n_CreatePolygon(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ pointsLength : UINT32, _ points : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreatePolygon(pThis, resourceCreator, pointsLength, points, __presult))
        }
    }
    public func CreatePolygon(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, pointsLength : UINT32, points : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreatePolygon(RawPointer(resourceCreator), pointsLength, points, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreateGroup(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Microsoft.Graphics.Canvas.Geometry.CanvasGeometry[])
    private func _n_CreateGroup(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ geometriesLength : UINT32, _ geometries : Optional<UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateGroup(pThis, resourceCreator, geometriesLength, geometries, __presult))
        }
    }
    public func CreateGroup(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, geometriesLength : UINT32, geometries : Optional<UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreateGroup(RawPointer(resourceCreator), geometriesLength, geometries, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreateGroup(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Microsoft.Graphics.Canvas.Geometry.CanvasGeometry[], Microsoft.Graphics.Canvas.Geometry.CanvasFilledRegionDetermination)
    private func _n_CreateGroupWithFilledRegionDetermination(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ geometriesLength : UINT32, _ geometries : Optional<UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>>, _ filledRegionDetermination : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFilledRegionDetermination, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateGroupWithFilledRegionDetermination(pThis, resourceCreator, geometriesLength, geometries, filledRegionDetermination, __presult))
        }
    }
    public func CreateGroupWithFilledRegionDetermination(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, geometriesLength : UINT32, geometries : Optional<UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>>, filledRegionDetermination : Microsoft.Graphics.Canvas.Geometry.CanvasFilledRegionDetermination) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreateGroupWithFilledRegionDetermination(RawPointer(resourceCreator), geometriesLength, geometries, filledRegionDetermination, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreateText(Microsoft.Graphics.Canvas.Text.CanvasTextLayout)
    private func _n_CreateText(_ textLayout : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasTextLayout>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateText(pThis, textLayout, __presult))
        }
    }
    public func CreateText(textLayout : Optional<Microsoft.Graphics.Canvas.Text.ICanvasTextLayout>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreateText(RawPointer(textLayout), &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGeometry CreateGlyphRun(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Text.CanvasFontFace, System.Single, Microsoft.Graphics.Canvas.Text.CanvasGlyph[], bool, System.UInt32, Microsoft.Graphics.Canvas.Text.CanvasTextMeasuringMode, Microsoft.Graphics.Canvas.Text.CanvasGlyphOrientation)
    private func _n_CreateGlyphRun(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ point : _q_CWindows_CFoundation_CNumerics_CVector2, _ fontFace : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CICanvasFontFace>>, _ fontSize : FLOAT, _ glyphsLength : UINT32, _ glyphs : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasGlyph>>, _ isSideways : boolean, _ bidiLevel : UINT32, _ measuringMode : _q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasTextMeasuringMode, _ glyphOrientation : _q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasGlyphOrientation, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateGlyphRun(pThis, resourceCreator, point, fontFace, fontSize, glyphsLength, glyphs, isSideways, bidiLevel, measuringMode, glyphOrientation, __presult))
        }
    }
    public func CreateGlyphRun(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, point : Windows.Foundation.Numerics.Vector2, fontFace : Optional<Microsoft.Graphics.Canvas.Text.ICanvasFontFace>, fontSize : Swift.Float, glyphsLength : UINT32, glyphs : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CText_CCanvasGlyph>>, isSideways : boolean, bidiLevel : Swift.UInt32, measuringMode : Microsoft.Graphics.Canvas.Text.CanvasTextMeasuringMode, glyphOrientation : Microsoft.Graphics.Canvas.Text.CanvasGlyphOrientation) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>> = nil;
        try self._n_CreateGlyphRun(RawPointer(resourceCreator), point, RawPointer(fontFace), fontSize, glyphsLength, glyphs, isSideways, bidiLevel, measuringMode, glyphOrientation, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry(consuming: __result);
    }
    // System.Single ComputeFlatteningTolerance(System.Single, System.Single)
    private func _n_ComputeFlatteningTolerance(_ dpi : FLOAT, _ maximumZoomFactor : FLOAT, _ __presult: UnsafeMutablePointer<FLOAT>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputeFlatteningTolerance(pThis, dpi, maximumZoomFactor, __presult))
        }
    }
    public func ComputeFlatteningTolerance(dpi : Swift.Float, maximumZoomFactor : Swift.Float) throws -> Swift.Float {
        var __result : FLOAT = 0;
        try self._n_ComputeFlatteningTolerance(dpi, maximumZoomFactor, &__result);
        return __result;
    }
    // System.Single ComputeFlatteningTolerance(System.Single, System.Single, Windows.Foundation.Numerics.Matrix3x2)
    private func _n_ComputeFlatteningToleranceWithTransform(_ dpi : FLOAT, _ maximumZoomFactor : FLOAT, _ expectedGeometryTransform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ __presult: UnsafeMutablePointer<FLOAT>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ComputeFlatteningToleranceWithTransform(pThis, dpi, maximumZoomFactor, expectedGeometryTransform, __presult))
        }
    }
    public func ComputeFlatteningToleranceWithTransform(dpi : Swift.Float, maximumZoomFactor : Swift.Float, expectedGeometryTransform : Windows.Foundation.Numerics.Matrix3x2) throws -> Swift.Float {
        var __result : FLOAT = 0;
        try self._n_ComputeFlatteningToleranceWithTransform(dpi, maximumZoomFactor, expectedGeometryTransform, &__result);
        return __result;
    }
    // [IsSpecialName] System.Single get_DefaultFlatteningTolerance()
    private func _n_get_DefaultFlatteningTolerance(_ __presult: UnsafeMutablePointer<FLOAT>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometryStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_DefaultFlatteningTolerance(pThis, __presult))
        }
    }
    public func get_DefaultFlatteningTolerance() throws -> Swift.Float {
        var __result : FLOAT = 0;
        try self._n_get_DefaultFlatteningTolerance(&__result);
        return __result;
    }
    public var DefaultFlatteningTolerance : Swift.Float {
        get throws {
            return try get_DefaultFlatteningTolerance();
        }
    }
} // ICanvasGeometryStatics


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh
// interface type
open class ICanvasGradientMesh
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x6bfc2bf1, Data2: 0x0a7a, Data3 : 0x449c, Data4 : (0xa7, 0xef, 0x67, 0x06, 0x32, 0x1b, 0x0c, 0x1a)) }
    // [IsSpecialName] Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatch[] get_Patches()
    private func _n_get_Patches(_ __presultLength: UnsafeMutablePointer<UINT32>?, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMesh.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Patches(pThis, __presultLength, __presult))
        }
    }
    public func get_Patches() throws -> UINT32 {
        var __resultLength : UINT32 = 0;
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch>> = nil;
        try self._n_get_Patches(&__resultLength, &__result);
        return __resultLength;
    }
    // Windows.Foundation.Rect GetBounds(Microsoft.Graphics.Canvas.ICanvasResourceCreator)
    private func _n_GetBounds(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CRect>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMesh.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetBounds(pThis, resourceCreator, __presult))
        }
    }
    public func GetBounds(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>) throws -> Windows.Foundation.Rect {
        var __result : _q_CWindows_CFoundation_CRect = _q_CWindows_CFoundation_CRect(X: 0, Y: 0, Width: 0, Height: 0);
        try self._n_GetBounds(RawPointer(resourceCreator), &__result);
        return __result;
    }
    // Windows.Foundation.Rect GetBounds(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Windows.Foundation.Numerics.Matrix3x2)
    private func _n_GetBoundsWithTransform(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ transform : _q_CWindows_CFoundation_CNumerics_CMatrix3x2, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CRect>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMesh.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetBoundsWithTransform(pThis, resourceCreator, transform, __presult))
        }
    }
    public func GetBoundsWithTransform(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, transform : Windows.Foundation.Numerics.Matrix3x2) throws -> Windows.Foundation.Rect {
        var __result : _q_CWindows_CFoundation_CRect = _q_CWindows_CFoundation_CRect(X: 0, Y: 0, Width: 0, Height: 0);
        try self._n_GetBoundsWithTransform(RawPointer(resourceCreator), transform, &__result);
        return __result;
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.CanvasDevice get_Device()
    private func _n_get_Device(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMesh.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Device(pThis, __presult))
        }
    }
    public func get_Device() throws -> Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasDevice>> = nil;
        try self._n_get_Device(&__result);
        return Microsoft.Graphics.Canvas.ICanvasDevice(consuming: __result);
    }
    public var Device : Optional<Microsoft.Graphics.Canvas.ICanvasDevice> {
        get throws {
            return try get_Device();
        }
    }
    public var Patches : UINT32 {
        get throws {
            return try get_Patches();
        }
    }
} // ICanvasGradientMesh


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMeshFactory
// interface type
// ACTIVATION INTERFACE
open class ICanvasGradientMeshFactory
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x4756492d, Data2: 0x251e, Data3 : 0x421d, Data4 : (0x83, 0x4d, 0x87, 0xec, 0x26, 0x0d, 0x5e, 0x4d)) }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGradientMesh Create(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatch[])
    private func _n_Create(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ patchElementsLength : UINT32, _ patchElements : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMesh>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMeshFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Create(pThis, resourceCreator, patchElementsLength, patchElements, __presult))
        }
    }
    public func Create(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>, patchElementsLength : UINT32, patchElements : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch>>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMesh>> = nil;
        try self._n_Create(RawPointer(resourceCreator), patchElementsLength, patchElements, &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh(consuming: __result);
    }
} // ICanvasGradientMeshFactory


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMeshStatics
// interface type
open class ICanvasGradientMeshStatics
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x44027640, Data2: 0x3eab, Data3 : 0x4199, Data4 : (0xaa, 0x3b, 0x64, 0x48, 0x90, 0xd0, 0x12, 0x3d)) }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatch CreateCoonsPatch(Windows.Foundation.Numerics.Vector2[], Windows.Foundation.Numerics.Vector4[], Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatchEdge[])
    private func _n_CreateCoonsPatch(_ pointsLength : UINT32, _ points : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>>, _ colorsLength : UINT32, _ colors : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector4>>, _ edgesLength : UINT32, _ edges : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge>>, _ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMeshStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateCoonsPatch(pThis, pointsLength, points, colorsLength, colors, edgesLength, edges, __presult))
        }
    }
    public func CreateCoonsPatch(pointsLength : UINT32, points : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>>, colorsLength : UINT32, colors : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector4>>, edgesLength : UINT32, edges : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge>>) throws -> Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatch {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch(Point00: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point01: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point02: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point03: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point10: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point11: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point12: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point13: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point20: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point21: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point22: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point23: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point30: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point31: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point32: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point33: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Color00: _q_CWindows_CFoundation_CNumerics_CVector4(X: 0, Y: 0, Z: 0, W: 0), Color03: _q_CWindows_CFoundation_CNumerics_CVector4(X: 0, Y: 0, Z: 0, W: 0), Color30: _q_CWindows_CFoundation_CNumerics_CVector4(X: 0, Y: 0, Z: 0, W: 0), Color33: _q_CWindows_CFoundation_CNumerics_CVector4(X: 0, Y: 0, Z: 0, W: 0), Edge00To03: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_Aliased, Edge03To33: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_Aliased, Edge33To30: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_Aliased, Edge30To00: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_Aliased);
        try self._n_CreateCoonsPatch(pointsLength, points, colorsLength, colors, edgesLength, edges, &__result);
        return __result;
    }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatch CreateTensorPatch(Windows.Foundation.Numerics.Vector2[], Windows.Foundation.Numerics.Vector4[], Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatchEdge[])
    private func _n_CreateTensorPatch(_ pointsLength : UINT32, _ points : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>>, _ colorsLength : UINT32, _ colors : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector4>>, _ edgesLength : UINT32, _ edges : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge>>, _ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMeshStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateTensorPatch(pThis, pointsLength, points, colorsLength, colors, edgesLength, edges, __presult))
        }
    }
    public func CreateTensorPatch(pointsLength : UINT32, points : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector2>>, colorsLength : UINT32, colors : Optional<UnsafeMutablePointer<_q_CWindows_CFoundation_CNumerics_CVector4>>, edgesLength : UINT32, edges : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge>>) throws -> Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatch {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch(Point00: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point01: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point02: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point03: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point10: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point11: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point12: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point13: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point20: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point21: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point22: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point23: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point30: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point31: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point32: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Point33: _q_CWindows_CFoundation_CNumerics_CVector2(X: 0, Y: 0), Color00: _q_CWindows_CFoundation_CNumerics_CVector4(X: 0, Y: 0, Z: 0, W: 0), Color03: _q_CWindows_CFoundation_CNumerics_CVector4(X: 0, Y: 0, Z: 0, W: 0), Color30: _q_CWindows_CFoundation_CNumerics_CVector4(X: 0, Y: 0, Z: 0, W: 0), Color33: _q_CWindows_CFoundation_CNumerics_CVector4(X: 0, Y: 0, Z: 0, W: 0), Edge00To03: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_Aliased, Edge03To33: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_Aliased, Edge33To30: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_Aliased, Edge30To00: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_Aliased);
        try self._n_CreateTensorPatch(pointsLength, points, colorsLength, colors, edgesLength, edges, &__result);
        return __result;
    }
} // ICanvasGradientMeshStatics


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder
// interface type
open class ICanvasPathBuilder
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xbcf5822f, Data2: 0x8127, Data3 : 0x4e5c, Data4 : (0x96, 0xb8, 0x29, 0x98, 0x3b, 0x91, 0x55, 0x41)) }
    // void BeginFigure(Windows.Foundation.Numerics.Vector2, Microsoft.Graphics.Canvas.Geometry.CanvasFigureFill)
    private func _n_BeginFigureWithFigureFill(_ startPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ figureFill : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureFill) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.BeginFigureWithFigureFill(pThis, startPoint, figureFill))
        }
    }
    public func BeginFigureWithFigureFill(startPoint : Windows.Foundation.Numerics.Vector2, figureFill : Microsoft.Graphics.Canvas.Geometry.CanvasFigureFill) throws -> Void {
        try self._n_BeginFigureWithFigureFill(startPoint, figureFill);
    }
    // void BeginFigure(Windows.Foundation.Numerics.Vector2)
    private func _n_BeginFigure(_ startPoint : _q_CWindows_CFoundation_CNumerics_CVector2) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.BeginFigure(pThis, startPoint))
        }
    }
    public func BeginFigure(startPoint : Windows.Foundation.Numerics.Vector2) throws -> Void {
        try self._n_BeginFigure(startPoint);
    }
    // void BeginFigure(System.Single, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasFigureFill)
    private func _n_BeginFigureAtCoordsWithFigureFill(_ startX : FLOAT, _ startY : FLOAT, _ figureFill : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureFill) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.BeginFigureAtCoordsWithFigureFill(pThis, startX, startY, figureFill))
        }
    }
    public func BeginFigureAtCoordsWithFigureFill(startX : Swift.Float, startY : Swift.Float, figureFill : Microsoft.Graphics.Canvas.Geometry.CanvasFigureFill) throws -> Void {
        try self._n_BeginFigureAtCoordsWithFigureFill(startX, startY, figureFill);
    }
    // void BeginFigure(System.Single, System.Single)
    private func _n_BeginFigureAtCoords(_ startX : FLOAT, _ startY : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.BeginFigureAtCoords(pThis, startX, startY))
        }
    }
    public func BeginFigureAtCoords(startX : Swift.Float, startY : Swift.Float) throws -> Void {
        try self._n_BeginFigureAtCoords(startX, startY);
    }
    // void AddArc(Windows.Foundation.Numerics.Vector2, System.Single, System.Single, System.Single, Microsoft.Graphics.Canvas.Geometry.CanvasSweepDirection, Microsoft.Graphics.Canvas.Geometry.CanvasArcSize)
    private func _n_AddArcToPoint(_ endPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radiusX : FLOAT, _ radiusY : FLOAT, _ rotationAngle : FLOAT, _ sweepDirection : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasSweepDirection, _ arcSize : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasArcSize) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.AddArcToPoint(pThis, endPoint, radiusX, radiusY, rotationAngle, sweepDirection, arcSize))
        }
    }
    public func AddArcToPoint(endPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, rotationAngle : Swift.Float, sweepDirection : Microsoft.Graphics.Canvas.Geometry.CanvasSweepDirection, arcSize : Microsoft.Graphics.Canvas.Geometry.CanvasArcSize) throws -> Void {
        try self._n_AddArcToPoint(endPoint, radiusX, radiusY, rotationAngle, sweepDirection, arcSize);
    }
    // void AddArc(Windows.Foundation.Numerics.Vector2, System.Single, System.Single, System.Single, System.Single)
    private func _n_AddArcAroundEllipse(_ centerPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ radiusX : FLOAT, _ radiusY : FLOAT, _ startAngle : FLOAT, _ sweepAngle : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.AddArcAroundEllipse(pThis, centerPoint, radiusX, radiusY, startAngle, sweepAngle))
        }
    }
    public func AddArcAroundEllipse(centerPoint : Windows.Foundation.Numerics.Vector2, radiusX : Swift.Float, radiusY : Swift.Float, startAngle : Swift.Float, sweepAngle : Swift.Float) throws -> Void {
        try self._n_AddArcAroundEllipse(centerPoint, radiusX, radiusY, startAngle, sweepAngle);
    }
    // void AddCubicBezier(Windows.Foundation.Numerics.Vector2, Windows.Foundation.Numerics.Vector2, Windows.Foundation.Numerics.Vector2)
    private func _n_AddCubicBezier(_ controlPoint1 : _q_CWindows_CFoundation_CNumerics_CVector2, _ controlPoint2 : _q_CWindows_CFoundation_CNumerics_CVector2, _ endPoint : _q_CWindows_CFoundation_CNumerics_CVector2) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.AddCubicBezier(pThis, controlPoint1, controlPoint2, endPoint))
        }
    }
    public func AddCubicBezier(controlPoint1 : Windows.Foundation.Numerics.Vector2, controlPoint2 : Windows.Foundation.Numerics.Vector2, endPoint : Windows.Foundation.Numerics.Vector2) throws -> Void {
        try self._n_AddCubicBezier(controlPoint1, controlPoint2, endPoint);
    }
    // void AddLine(Windows.Foundation.Numerics.Vector2)
    private func _n_AddLine(_ endPoint : _q_CWindows_CFoundation_CNumerics_CVector2) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.AddLine(pThis, endPoint))
        }
    }
    public func AddLine(endPoint : Windows.Foundation.Numerics.Vector2) throws -> Void {
        try self._n_AddLine(endPoint);
    }
    // void AddLine(System.Single, System.Single)
    private func _n_AddLineWithCoords(_ x : FLOAT, _ y : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.AddLineWithCoords(pThis, x, y))
        }
    }
    public func AddLineWithCoords(x : Swift.Float, y : Swift.Float) throws -> Void {
        try self._n_AddLineWithCoords(x, y);
    }
    // void AddQuadraticBezier(Windows.Foundation.Numerics.Vector2, Windows.Foundation.Numerics.Vector2)
    private func _n_AddQuadraticBezier(_ controlPoint : _q_CWindows_CFoundation_CNumerics_CVector2, _ endPoint : _q_CWindows_CFoundation_CNumerics_CVector2) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.AddQuadraticBezier(pThis, controlPoint, endPoint))
        }
    }
    public func AddQuadraticBezier(controlPoint : Windows.Foundation.Numerics.Vector2, endPoint : Windows.Foundation.Numerics.Vector2) throws -> Void {
        try self._n_AddQuadraticBezier(controlPoint, endPoint);
    }
    // void SetFilledRegionDetermination(Microsoft.Graphics.Canvas.Geometry.CanvasFilledRegionDetermination)
    private func _n_SetFilledRegionDetermination(_ filledRegionDetermination : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFilledRegionDetermination) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetFilledRegionDetermination(pThis, filledRegionDetermination))
        }
    }
    public func SetFilledRegionDetermination(filledRegionDetermination : Microsoft.Graphics.Canvas.Geometry.CanvasFilledRegionDetermination) throws -> Void {
        try self._n_SetFilledRegionDetermination(filledRegionDetermination);
    }
    // void SetSegmentOptions(Microsoft.Graphics.Canvas.Geometry.CanvasFigureSegmentOptions)
    private func _n_SetSegmentOptions(_ figureSegmentOptions : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureSegmentOptions) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.SetSegmentOptions(pThis, figureSegmentOptions))
        }
    }
    public func SetSegmentOptions(figureSegmentOptions : Microsoft.Graphics.Canvas.Geometry.CanvasFigureSegmentOptions) throws -> Void {
        try self._n_SetSegmentOptions(figureSegmentOptions);
    }
    // void EndFigure(Microsoft.Graphics.Canvas.Geometry.CanvasFigureLoop)
    private func _n_EndFigure(_ figureLoop : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureLoop) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.EndFigure(pThis, figureLoop))
        }
    }
    public func EndFigure(figureLoop : Microsoft.Graphics.Canvas.Geometry.CanvasFigureLoop) throws -> Void {
        try self._n_EndFigure(figureLoop);
    }
    // void AddGeometry(Microsoft.Graphics.Canvas.Geometry.CanvasGeometry)
    private func _n_AddGeometry(_ geometry : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGeometry>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.AddGeometry(pThis, geometry))
        }
    }
    public func AddGeometry(geometry : Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry>) throws -> Void {
        try self._n_AddGeometry(RawPointer(geometry));
    }
} // ICanvasPathBuilder


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilderFactory
// interface type
// ACTIVATION INTERFACE
open class ICanvasPathBuilderFactory
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xac2bee14, Data2: 0xefd1, Data3 : 0x4343, Data4 : (0x8e, 0x53, 0xba, 0x62, 0x15, 0x3d, 0x89, 0x66)) }
    // Microsoft.Graphics.Canvas.Geometry.CanvasPathBuilder Create(Microsoft.Graphics.Canvas.ICanvasResourceCreator)
    private func _n_Create(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilderFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Create(pThis, resourceCreator, __presult))
        }
    }
    public func Create(resourceCreator : Optional<Microsoft.Graphics.Canvas.ICanvasResourceCreator>) throws -> Optional<Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasPathBuilder>> = nil;
        try self._n_Create(RawPointer(resourceCreator), &__result);
        return Microsoft.Graphics.Canvas.Geometry.ICanvasPathBuilder(consuming: __result);
    }
} // ICanvasPathBuilderFactory


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasPathReceiver
// interface type
open class ICanvasPathReceiver
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x70e65373, Data2: 0x7fb3, Data3 : 0x4645, Data4 : (0x8b, 0x6d, 0xf6, 0x16, 0xd1, 0xb9, 0xa9, 0xd7)) }
// method not needed: BeginFigure
// method not needed: AddArc
// method not needed: AddCubicBezier
// method not needed: AddLine
// method not needed: AddQuadraticBezier
// method not needed: SetFilledRegionDetermination
// method not needed: SetSegmentOptions
// method not needed: EndFigure
} // ICanvasPathReceiver


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle
// interface type
open class ICanvasStrokeStyle
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xfd3e1cd2, Data2: 0x6019, Data3 : 0x40a1, Data4 : (0xb3, 0x15, 0x26, 0x7e, 0xef, 0x6c, 0x2a, 0xeb)) }
    // [IsSpecialName] Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle get_StartCap()
    private func _n_get_StartCap(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_StartCap(pThis, __presult))
        }
    }
    public func get_StartCap() throws -> Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle_Flat;
        try self._n_get_StartCap(&__result);
        return __result;
    }
    // [IsSpecialName] void put_StartCap(Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle)
    private func _n_put_StartCap(_ value : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_StartCap(pThis, value))
        }
    }
    public func put_StartCap(value : Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle) throws -> Void {
        try self._n_put_StartCap(value);
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle get_EndCap()
    private func _n_get_EndCap(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_EndCap(pThis, __presult))
        }
    }
    public func get_EndCap() throws -> Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle_Flat;
        try self._n_get_EndCap(&__result);
        return __result;
    }
    // [IsSpecialName] void put_EndCap(Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle)
    private func _n_put_EndCap(_ value : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_EndCap(pThis, value))
        }
    }
    public func put_EndCap(value : Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle) throws -> Void {
        try self._n_put_EndCap(value);
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle get_DashCap()
    private func _n_get_DashCap(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_DashCap(pThis, __presult))
        }
    }
    public func get_DashCap() throws -> Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle_Flat;
        try self._n_get_DashCap(&__result);
        return __result;
    }
    // [IsSpecialName] void put_DashCap(Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle)
    private func _n_put_DashCap(_ value : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_DashCap(pThis, value))
        }
    }
    public func put_DashCap(value : Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle) throws -> Void {
        try self._n_put_DashCap(value);
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.Geometry.CanvasLineJoin get_LineJoin()
    private func _n_get_LineJoin(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasLineJoin>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_LineJoin(pThis, __presult))
        }
    }
    public func get_LineJoin() throws -> Microsoft.Graphics.Canvas.Geometry.CanvasLineJoin {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasLineJoin = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasLineJoin_Miter;
        try self._n_get_LineJoin(&__result);
        return __result;
    }
    // [IsSpecialName] void put_LineJoin(Microsoft.Graphics.Canvas.Geometry.CanvasLineJoin)
    private func _n_put_LineJoin(_ value : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasLineJoin) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_LineJoin(pThis, value))
        }
    }
    public func put_LineJoin(value : Microsoft.Graphics.Canvas.Geometry.CanvasLineJoin) throws -> Void {
        try self._n_put_LineJoin(value);
    }
    // [IsSpecialName] System.Single get_MiterLimit()
    private func _n_get_MiterLimit(_ __presult: UnsafeMutablePointer<FLOAT>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_MiterLimit(pThis, __presult))
        }
    }
    public func get_MiterLimit() throws -> Swift.Float {
        var __result : FLOAT = 0;
        try self._n_get_MiterLimit(&__result);
        return __result;
    }
    // [IsSpecialName] void put_MiterLimit(System.Single)
    private func _n_put_MiterLimit(_ value : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_MiterLimit(pThis, value))
        }
    }
    public func put_MiterLimit(value : Swift.Float) throws -> Void {
        try self._n_put_MiterLimit(value);
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.Geometry.CanvasDashStyle get_DashStyle()
    private func _n_get_DashStyle(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasDashStyle>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_DashStyle(pThis, __presult))
        }
    }
    public func get_DashStyle() throws -> Microsoft.Graphics.Canvas.Geometry.CanvasDashStyle {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasDashStyle = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasDashStyle_Solid;
        try self._n_get_DashStyle(&__result);
        return __result;
    }
    // [IsSpecialName] void put_DashStyle(Microsoft.Graphics.Canvas.Geometry.CanvasDashStyle)
    private func _n_put_DashStyle(_ value : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasDashStyle) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_DashStyle(pThis, value))
        }
    }
    public func put_DashStyle(value : Microsoft.Graphics.Canvas.Geometry.CanvasDashStyle) throws -> Void {
        try self._n_put_DashStyle(value);
    }
    // [IsSpecialName] System.Single get_DashOffset()
    private func _n_get_DashOffset(_ __presult: UnsafeMutablePointer<FLOAT>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_DashOffset(pThis, __presult))
        }
    }
    public func get_DashOffset() throws -> Swift.Float {
        var __result : FLOAT = 0;
        try self._n_get_DashOffset(&__result);
        return __result;
    }
    // [IsSpecialName] void put_DashOffset(System.Single)
    private func _n_put_DashOffset(_ value : FLOAT) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_DashOffset(pThis, value))
        }
    }
    public func put_DashOffset(value : Swift.Float) throws -> Void {
        try self._n_put_DashOffset(value);
    }
    // [IsSpecialName] System.Single[] get_CustomDashStyle()
    private func _n_get_CustomDashStyle(_ __presultLength: UnsafeMutablePointer<UINT32>?, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<FLOAT>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_CustomDashStyle(pThis, __presultLength, __presult))
        }
    }
    public func get_CustomDashStyle() throws -> UINT32 {
        var __resultLength : UINT32 = 0;
        var __result : Optional<UnsafeMutablePointer<FLOAT>> = nil;
        try self._n_get_CustomDashStyle(&__resultLength, &__result);
        return __resultLength;
    }
    // [IsSpecialName] void put_CustomDashStyle(System.Single[])
    private func _n_put_CustomDashStyle(_ valueElementsLength : UINT32, _ valueElements : Optional<UnsafeMutablePointer<FLOAT>>) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_CustomDashStyle(pThis, valueElementsLength, valueElements))
        }
    }
    public func put_CustomDashStyle(valueElementsLength : UINT32, valueElements : Optional<UnsafeMutablePointer<FLOAT>>) throws -> Void {
        try self._n_put_CustomDashStyle(valueElementsLength, valueElements);
    }
    // [IsSpecialName] Microsoft.Graphics.Canvas.Geometry.CanvasStrokeTransformBehavior get_TransformBehavior()
    private func _n_get_TransformBehavior(_ __presult: UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasStrokeTransformBehavior>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_TransformBehavior(pThis, __presult))
        }
    }
    public func get_TransformBehavior() throws -> Microsoft.Graphics.Canvas.Geometry.CanvasStrokeTransformBehavior {
        var __result : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasStrokeTransformBehavior = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasStrokeTransformBehavior_Normal;
        try self._n_get_TransformBehavior(&__result);
        return __result;
    }
    // [IsSpecialName] void put_TransformBehavior(Microsoft.Graphics.Canvas.Geometry.CanvasStrokeTransformBehavior)
    private func _n_put_TransformBehavior(_ value : _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasStrokeTransformBehavior) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasStrokeStyle.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.put_TransformBehavior(pThis, value))
        }
    }
    public func put_TransformBehavior(value : Microsoft.Graphics.Canvas.Geometry.CanvasStrokeTransformBehavior) throws -> Void {
        try self._n_put_TransformBehavior(value);
    }
    public var CustomDashStyle : UINT32 {
        get throws {
            return try get_CustomDashStyle();
        }
    }
    public var DashCap : Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle {
        get throws {
            return try get_DashCap();
        }
    }
    public var DashOffset : Swift.Float {
        get throws {
            return try get_DashOffset();
        }
    }
    public var DashStyle : Microsoft.Graphics.Canvas.Geometry.CanvasDashStyle {
        get throws {
            return try get_DashStyle();
        }
    }
    public var EndCap : Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle {
        get throws {
            return try get_EndCap();
        }
    }
    public var LineJoin : Microsoft.Graphics.Canvas.Geometry.CanvasLineJoin {
        get throws {
            return try get_LineJoin();
        }
    }
    public var MiterLimit : Swift.Float {
        get throws {
            return try get_MiterLimit();
        }
    }
    public var StartCap : Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle {
        get throws {
            return try get_StartCap();
        }
    }
    public var TransformBehavior : Microsoft.Graphics.Canvas.Geometry.CanvasStrokeTransformBehavior {
        get throws {
            return try get_TransformBehavior();
        }
    }
} // ICanvasStrokeStyle


}
extension Microsoft.Graphics.Canvas.Geometry.CanvasArcSize {
    public static var Small : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasArcSize_Small;
        }
    }
    public static var Large : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasArcSize_Large;
        }
    }
}
extension Microsoft.Graphics.Canvas.Geometry.CanvasCapStyle {
    public static var Flat : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle_Flat;
        }
    }
    public static var Square : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle_Square;
        }
    }
    public static var Round : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle_Round;
        }
    }
    public static var Triangle : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasCapStyle_Triangle;
        }
    }
}
extension Microsoft.Graphics.Canvas.Geometry.CanvasDashStyle {
    public static var Solid : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasDashStyle_Solid;
        }
    }
    public static var Dash : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasDashStyle_Dash;
        }
    }
    public static var Dot : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasDashStyle_Dot;
        }
    }
    public static var DashDot : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasDashStyle_DashDot;
        }
    }
    public static var DashDotDot : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasDashStyle_DashDotDot;
        }
    }
}
extension Microsoft.Graphics.Canvas.Geometry.CanvasFigureFill {
    public static var Default : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureFill_Default;
        }
    }
    public static var DoesNotAffectFills : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureFill_DoesNotAffectFills;
        }
    }
}
extension Microsoft.Graphics.Canvas.Geometry.CanvasFigureLoop {
    public static var Open : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureLoop_Open;
        }
    }
    public static var Closed : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureLoop_Closed;
        }
    }
}
extension Microsoft.Graphics.Canvas.Geometry.CanvasFigureSegmentOptions {
    public static var None : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureSegmentOptions_None;
        }
    }
    public static var ForceUnstroked : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureSegmentOptions_ForceUnstroked;
        }
    }
    public static var ForceRoundLineJoin : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFigureSegmentOptions_ForceRoundLineJoin;
        }
    }
}
extension Microsoft.Graphics.Canvas.Geometry.CanvasFilledRegionDetermination {
    public static var Alternate : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFilledRegionDetermination_Alternate;
        }
    }
    public static var Winding : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasFilledRegionDetermination_Winding;
        }
    }
}
extension Microsoft.Graphics.Canvas.Geometry.CanvasGeometryCombine {
    public static var Union : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryCombine_Union;
        }
    }
    public static var Intersect : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryCombine_Intersect;
        }
    }
    public static var Xor : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryCombine_Xor;
        }
    }
    public static var Exclude : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryCombine_Exclude;
        }
    }
}
extension Microsoft.Graphics.Canvas.Geometry.CanvasGeometryRelation {
    public static var Disjoint : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryRelation_Disjoint;
        }
    }
    public static var Contained : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryRelation_Contained;
        }
    }
    public static var Contains : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryRelation_Contains;
        }
    }
    public static var Overlap : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometryRelation_Overlap;
        }
    }
}
extension Microsoft.Graphics.Canvas.Geometry.CanvasGeometrySimplification {
    public static var CubicsAndLines : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometrySimplification_CubicsAndLines;
        }
    }
    public static var Lines : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGeometrySimplification_Lines;
        }
    }
}
extension Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatchEdge {
    public static var Aliased : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_Aliased;
        }
    }
    public static var Antialiased : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_Antialiased;
        }
    }
    public static var AliasedAndInflated : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_AliasedAndInflated;
        }
    }
}
extension Microsoft.Graphics.Canvas.Geometry.CanvasLineJoin {
    public static var Miter : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasLineJoin_Miter;
        }
    }
    public static var Bevel : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasLineJoin_Bevel;
        }
    }
    public static var Round : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasLineJoin_Round;
        }
    }
    public static var MiterOrBevel : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasLineJoin_MiterOrBevel;
        }
    }
}
extension Microsoft.Graphics.Canvas.Geometry.CanvasStrokeTransformBehavior {
    public static var Normal : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasStrokeTransformBehavior_Normal;
        }
    }
    public static var Fixed : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasStrokeTransformBehavior_Fixed;
        }
    }
    public static var Hairline : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasStrokeTransformBehavior_Hairline;
        }
    }
}
extension Microsoft.Graphics.Canvas.Geometry.CanvasSweepDirection {
    public static var CounterClockwise : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasSweepDirection_CounterClockwise;
        }
    }
    public static var Clockwise : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasSweepDirection_Clockwise;
        }
    }
}
