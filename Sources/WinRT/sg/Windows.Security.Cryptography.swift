// this file is automatically generated.
// if you modify it by hand, your changes will probably be lost.


import CWinRT;

extension Windows.Security.Cryptography {
// type: Windows.Security.Cryptography.CryptographicBuffer
// static class
public class CryptographicBuffer
{
    private struct _ICryptographicBufferStatics {
        static var x : ICryptographicBufferStatics =
            try! RoGetActivationFactory(HString("Windows.Security.Cryptography.CryptographicBuffer"))
    }
    public static var CryptographicBufferStatics : ICryptographicBufferStatics {
        _ICryptographicBufferStatics.x
    }
// method not needed: Compare
// method not needed: GenerateRandom
// method not needed: GenerateRandomNumber
// method not needed: CreateFromByteArray
// method not needed: CopyToByteArray
// method not needed: DecodeFromHexString
    public static func EncodeToHexString(buffer : Optional<WinRT.Windows.Storage.Streams.IBuffer>) throws -> Swift.String {
        return try CryptographicBufferStatics.EncodeToHexString(buffer: buffer);
    }
// method not needed: DecodeFromBase64String
    public static func EncodeToBase64String(buffer : Optional<WinRT.Windows.Storage.Streams.IBuffer>) throws -> Swift.String {
        return try CryptographicBufferStatics.EncodeToBase64String(buffer: buffer);
    }
// method not needed: ConvertStringToBinary
// method not needed: ConvertBinaryToString
}

// type: Windows.Security.Cryptography.ICryptographicBufferStatics
// interface type
open class ICryptographicBufferStatics
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x320b7e22, Data2: 0x3cb0, Data3 : 0x4cdf, Data4 : (0x86, 0x63, 0x1d, 0x28, 0x91, 0x00, 0x65, 0xeb)) }
// method not needed: Compare
// method not needed: GenerateRandom
// method not needed: GenerateRandomNumber
// method not needed: CreateFromByteArray
// method not needed: CopyToByteArray
// method not needed: DecodeFromHexString
    // System.String EncodeToHexString(Windows.Storage.Streams.IBuffer)
    public func _n_EncodeToHexString(_ buffer : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ __presult: UnsafeMutablePointer<Optional<HSTRING>>?) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CICryptographicBufferStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.EncodeToHexString(pThis, buffer, __presult))
        }
    }
    public func EncodeToHexString(buffer : Optional<WinRT.Windows.Storage.Streams.IBuffer>) throws -> Swift.String {
        var __result : Optional<HSTRING> = nil;
        try self._n_EncodeToHexString(RawPointer(buffer), &__result);
        return Swift.String(from: __result);
    }
// method not needed: DecodeFromBase64String
    // System.String EncodeToBase64String(Windows.Storage.Streams.IBuffer)
    public func _n_EncodeToBase64String(_ buffer : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ __presult: UnsafeMutablePointer<Optional<HSTRING>>?) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CICryptographicBufferStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.EncodeToBase64String(pThis, buffer, __presult))
        }
    }
    public func EncodeToBase64String(buffer : Optional<WinRT.Windows.Storage.Streams.IBuffer>) throws -> Swift.String {
        var __result : Optional<HSTRING> = nil;
        try self._n_EncodeToBase64String(RawPointer(buffer), &__result);
        return Swift.String(from: __result);
    }
// method not needed: ConvertStringToBinary
// method not needed: ConvertBinaryToString
} // ICryptographicBufferStatics


}
