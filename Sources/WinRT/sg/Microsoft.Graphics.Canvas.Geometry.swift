// this file is automatically generated.
// if you modify it by hand, your changes will probably be lost.


import CWinRT;

extension Microsoft.Graphics.Canvas.Geometry {
// type: Microsoft.Graphics.Canvas.Geometry.CanvasCachedGeometry
// runtime class
public class CanvasCachedGeometry
    :
    WinRT.Object
{
    private var _self : WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry;
    internal init(plok: WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    internal func Interface() -> WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry { return _self; }
    // static interface not needed: Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometryStatics
    // method not needed: get_Device
    public func Close() throws -> Void {
        let _ifc : WinRT.Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.Geometry.CanvasGeometry
// runtime class
public class CanvasGeometry
    :
    WinRT.Object
{
    private var _self : WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry;
    internal init(plok: WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    internal func Interface() -> WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry { return _self; }
    // static interface not needed: Microsoft.Graphics.Canvas.Geometry.ICanvasGeometryStatics
    // method not needed: CombineWith
    // method not needed: CombineWith
    // method not needed: Stroke
    // method not needed: Stroke
    // method not needed: Stroke
    // method not needed: Outline
    // method not needed: Outline
    // method not needed: Simplify
    // method not needed: Simplify
    // method not needed: Transform
    // method not needed: CompareWith
    // method not needed: CompareWith
    // method not needed: ComputeArea
    // method not needed: ComputeArea
    // method not needed: ComputePathLength
    // method not needed: ComputePathLength
    // method not needed: ComputePointOnPath
    // method not needed: ComputePointOnPath
    // method not needed: ComputePointOnPath
    // method not needed: FillContainsPoint
    // method not needed: FillContainsPoint
    // method not needed: ComputeBounds
    // method not needed: ComputeBounds
    // method not needed: ComputeStrokeBounds
    // method not needed: ComputeStrokeBounds
    // method not needed: ComputeStrokeBounds
    // method not needed: StrokeContainsPoint
    // method not needed: StrokeContainsPoint
    // method not needed: StrokeContainsPoint
    // method not needed: Tessellate
    // method not needed: Tessellate
    // method not needed: SendPathTo
    // method not needed: get_Device
    public func Close() throws -> Void {
        let _ifc : WinRT.Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
    // instance interface not needed: Windows.Graphics.IGeometrySource2D
}

// type: Microsoft.Graphics.Canvas.Geometry.CanvasGradientMesh
// runtime class
public class CanvasGradientMesh
    :
    WinRT.Object
{
    private var _self : WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh;
    internal init(plok: WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    internal func Interface() -> WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh { return _self; }
    public init(resourceCreator : Optional<WinRT.Microsoft.Graphics.Canvas.ICanvasResourceCreator>, patchElementsLength : UINT32, patchElements : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch>>) throws {
        let _af : ICanvasGradientMeshFactory = try RoGetActivationFactory("Microsoft.Graphics.Canvas.Geometry.CanvasGradientMesh");
        _self = try _af.Create(resourceCreator: resourceCreator, patchElementsLength: patchElementsLength, patchElements: patchElements)!;
        try super.init(plok: _self.QueryInterface())
    }
    // static interface not needed: Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMeshStatics
    // method not needed: get_Patches
    // method not needed: GetBounds
    // method not needed: GetBounds
    // method not needed: get_Device
    public func Close() throws -> Void {
        let _ifc : WinRT.Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatch
// struct type
public typealias CanvasGradientMeshPatch = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatchEdge
// enum type
public typealias CanvasGradientMeshPatchEdge = _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge;

// type: Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle
// runtime class
public class CanvasStrokeStyle
    :
    WinRT.Object
{
    private var _self : WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle;
    internal init(plok: WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    internal func Interface() -> WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle { return _self; }
    public init() throws {
        _self = try RoActivateInstance("Microsoft.Graphics.Canvas.Geometry.CanvasStrokeStyle")
        try super.init(plok: _self.QueryInterface())
    }
    // method not needed: get_StartCap
    // method not needed: put_StartCap
    // method not needed: get_EndCap
    // method not needed: put_EndCap
    // method not needed: get_DashCap
    // method not needed: put_DashCap
    // method not needed: get_LineJoin
    // method not needed: put_LineJoin
    // method not needed: get_MiterLimit
    // method not needed: put_MiterLimit
    // method not needed: get_DashStyle
    // method not needed: put_DashStyle
    // method not needed: get_DashOffset
    // method not needed: put_DashOffset
    // method not needed: get_CustomDashStyle
    // method not needed: put_CustomDashStyle
    // method not needed: get_TransformBehavior
    // method not needed: put_TransformBehavior
    public func Close() throws -> Void {
        let _ifc : WinRT.Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Microsoft.Graphics.Canvas.Geometry.ICanvasCachedGeometry
// interface type
open class ICanvasCachedGeometry
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xba6cb114, Data2: 0xe1a1, Data3 : 0x448d, Data4 : (0xab, 0x7c, 0x8d, 0x2b, 0x92, 0x67, 0x41, 0x19)) }
// method not needed: get_Device
} // ICanvasCachedGeometry


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasGeometry
// interface type
open class ICanvasGeometry
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x74ea89fa, Data2: 0xc87c, Data3 : 0x4d0d, Data4 : (0x90, 0x57, 0x27, 0x43, 0xb8, 0xdb, 0x67, 0xee)) }
// method not needed: CombineWith
// method not needed: CombineWithUsingFlatteningTolerance
// method not needed: Stroke
// method not needed: StrokeWithStrokeStyle
// method not needed: StrokeWithAllOptions
// method not needed: Outline
// method not needed: OutlineWithTransformAndFlatteningTolerance
// method not needed: Simplify
// method not needed: SimplifyWithTransformAndFlatteningTolerance
// method not needed: Transform
// method not needed: CompareWith
// method not needed: CompareWithUsingTransformAndFlatteningTolerance
// method not needed: ComputeArea
// method not needed: ComputeAreaWithTransformAndFlatteningTolerance
// method not needed: ComputePathLength
// method not needed: ComputePathLengthWithTransformAndFlatteningTolerance
// method not needed: ComputePointOnPath
// method not needed: ComputePointOnPathWithTangent
// method not needed: ComputePointOnPathWithTransformAndFlatteningToleranceAndTangent
// method not needed: FillContainsPoint
// method not needed: FillContainsPointWithTransformAndFlatteningTolerance
// method not needed: ComputeBounds
// method not needed: ComputeBoundsWithTransform
// method not needed: ComputeStrokeBounds
// method not needed: ComputeStrokeBoundsWithStrokeStyle
// method not needed: ComputeStrokeBoundsWithAllOptions
// method not needed: StrokeContainsPoint
// method not needed: StrokeContainsPointWithStrokeStyle
// method not needed: StrokeContainsPointWithAllOptions
// method not needed: Tessellate
// method not needed: TessellateWithTransformAndFlatteningTolerance
// method not needed: SendPathTo
// method not needed: get_Device
} // ICanvasGeometry


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh
// interface type
open class ICanvasGradientMesh
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x6bfc2bf1, Data2: 0x0a7a, Data3 : 0x449c, Data4 : (0xa7, 0xef, 0x67, 0x06, 0x32, 0x1b, 0x0c, 0x1a)) }
// method not needed: get_Patches
// method not needed: GetBounds
// method not needed: GetBoundsWithTransform
// method not needed: get_Device
} // ICanvasGradientMesh


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMeshFactory
// interface type
// ACTIVATION INTERFACE
open class ICanvasGradientMeshFactory
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x4756492d, Data2: 0x251e, Data3 : 0x421d, Data4 : (0x83, 0x4d, 0x87, 0xec, 0x26, 0x0d, 0x5e, 0x4d)) }
    // Microsoft.Graphics.Canvas.Geometry.CanvasGradientMesh Create(Microsoft.Graphics.Canvas.ICanvasResourceCreator, Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatch[])
    private func _n_Create(_ resourceCreator : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CICanvasResourceCreator>>, _ patchElementsLength : UINT32, _ patchElements : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMesh>>>?) throws {
        return try perform(as: _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMeshFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Create(pThis, resourceCreator, patchElementsLength, patchElements, __presult))
        }
    }
    public func Create(resourceCreator : Optional<WinRT.Microsoft.Graphics.Canvas.ICanvasResourceCreator>, patchElementsLength : UINT32, patchElements : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatch>>) throws -> Optional<WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh> {
        var __result : Optional<UnsafeMutablePointer<_q_CMicrosoft_CGraphics_CCanvas_CGeometry_CICanvasGradientMesh>> = nil;
        try self._n_Create(RawPointer(resourceCreator), patchElementsLength, patchElements, &__result);
        return WinRT.Microsoft.Graphics.Canvas.Geometry.ICanvasGradientMesh(consuming: __result);
    }
} // ICanvasGradientMeshFactory


// type: Microsoft.Graphics.Canvas.Geometry.ICanvasStrokeStyle
// interface type
open class ICanvasStrokeStyle
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xfd3e1cd2, Data2: 0x6019, Data3 : 0x40a1, Data4 : (0xb3, 0x15, 0x26, 0x7e, 0xef, 0x6c, 0x2a, 0xeb)) }
// method not needed: get_StartCap
// method not needed: put_StartCap
// method not needed: get_EndCap
// method not needed: put_EndCap
// method not needed: get_DashCap
// method not needed: put_DashCap
// method not needed: get_LineJoin
// method not needed: put_LineJoin
// method not needed: get_MiterLimit
// method not needed: put_MiterLimit
// method not needed: get_DashStyle
// method not needed: put_DashStyle
// method not needed: get_DashOffset
// method not needed: put_DashOffset
// method not needed: get_CustomDashStyle
// method not needed: put_CustomDashStyle
// method not needed: get_TransformBehavior
// method not needed: put_TransformBehavior
} // ICanvasStrokeStyle


}
extension WinRT.Microsoft.Graphics.Canvas.Geometry.CanvasGradientMeshPatchEdge {
    public static var Aliased : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_Aliased;
        }
    }
    public static var Antialiased : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_Antialiased;
        }
    }
    public static var AliasedAndInflated : Self {
        get {
            return _q_CMicrosoft_CGraphics_CCanvas_CGeometry_CCanvasGradientMeshPatchEdge_AliasedAndInflated;
        }
    }
}
