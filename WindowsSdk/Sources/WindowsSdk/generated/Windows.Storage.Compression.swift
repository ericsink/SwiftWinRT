// this file is automatically generated.
// if you modify it by hand, your changes will probably be lost.


import CWinRT;
@_spi(IUnknown) import WinRT;
import CWindowsSdk;

extension Windows.Storage.Compression {
// type: Windows.Storage.Compression.CompressAlgorithm
// enum type
public typealias CompressAlgorithm = _q_CWindows_CStorage_CCompression_CCompressAlgorithm;

// type: Windows.Storage.Compression.Compressor
// runtime class
public class Compressor
    :
    WinRT.Object
{
    private var _self : Windows.Storage.Compression.ICompressor;
    public init(plok: Windows.Storage.Compression.ICompressor?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Windows.Storage.Compression.ICompressor { return _self; }
    public init(underlyingStream : Optional<Windows.Storage.Streams.IOutputStream>) throws {
        let _af : ICompressorFactory = try RoGetActivationFactory("Windows.Storage.Compression.Compressor");
        _self = try _af.CreateCompressor(underlyingStream: underlyingStream)!;
        try super.init(plok: _self.QueryInterface())
    }
    public init(underlyingStream : Optional<Windows.Storage.Streams.IOutputStream>, algorithm : Windows.Storage.Compression.CompressAlgorithm, blockSize : Swift.UInt32) throws {
        let _af : ICompressorFactory = try RoGetActivationFactory("Windows.Storage.Compression.Compressor");
        _self = try _af.CreateCompressorEx(underlyingStream: underlyingStream, algorithm: algorithm, blockSize: blockSize)!;
        try super.init(plok: _self.QueryInterface())
    }
    public func FinishAsync() throws -> Optional<ClosedGenerics.IAsyncOperation_1_boolean> {
        let _ifc : Windows.Storage.Compression.ICompressor = try _self.QueryInterface();
        return try _ifc.FinishAsync();
    }
    public func Finish() async throws -> boolean {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.FinishAsync()!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func DetachStream() throws -> Optional<Windows.Storage.Streams.IOutputStream> {
        let _ifc : Windows.Storage.Compression.ICompressor = try _self.QueryInterface();
        return try _ifc.DetachStream();
    }
    public func WriteAsync(buffer : Optional<Windows.Storage.Streams.IBuffer>) throws -> Optional<ClosedGenerics.IAsyncOperationWithProgress_2_UINT32_UINT32> {
        let _ifc : Windows.Storage.Streams.IOutputStream = try _self.QueryInterface();
        return try _ifc.WriteAsync(buffer: buffer);
    }
    public func Write(buffer : Optional<Windows.Storage.Streams.IBuffer>) async throws -> Swift.UInt32 {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.WriteAsync(buffer: buffer)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func FlushAsync() throws -> Optional<ClosedGenerics.IAsyncOperation_1_boolean> {
        let _ifc : Windows.Storage.Streams.IOutputStream = try _self.QueryInterface();
        return try _ifc.FlushAsync();
    }
    public func Flush() async throws -> boolean {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.FlushAsync()!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Windows.Storage.Compression.Decompressor
// runtime class
public class Decompressor
    :
    WinRT.Object
{
    private var _self : Windows.Storage.Compression.IDecompressor;
    public init(plok: Windows.Storage.Compression.IDecompressor?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Windows.Storage.Compression.IDecompressor { return _self; }
    public init(underlyingStream : Optional<Windows.Storage.Streams.IInputStream>) throws {
        let _af : IDecompressorFactory = try RoGetActivationFactory("Windows.Storage.Compression.Decompressor");
        _self = try _af.CreateDecompressor(underlyingStream: underlyingStream)!;
        try super.init(plok: _self.QueryInterface())
    }
    public func DetachStream() throws -> Optional<Windows.Storage.Streams.IInputStream> {
        let _ifc : Windows.Storage.Compression.IDecompressor = try _self.QueryInterface();
        return try _ifc.DetachStream();
    }
    public func ReadAsync(buffer : Optional<Windows.Storage.Streams.IBuffer>, count : Swift.UInt32, options : Windows.Storage.Streams.InputStreamOptions) throws -> Optional<ClosedGenerics.IAsyncOperationWithProgress_2__q_CWindows_CStorage_CStreams_CIBuffer_UINT32> {
        let _ifc : Windows.Storage.Streams.IInputStream = try _self.QueryInterface();
        return try _ifc.ReadAsync(buffer: buffer, count: count, options: options);
    }
    public func Read(buffer : Optional<Windows.Storage.Streams.IBuffer>, count : Swift.UInt32, options : Windows.Storage.Streams.InputStreamOptions) async throws -> Optional<Windows.Storage.Streams.IBuffer> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.ReadAsync(buffer: buffer, count: count, options: options)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func Close() throws -> Void {
        let _ifc : Windows.Foundation.IClosable = try _self.QueryInterface();
        return try _ifc.Close();
    }
}

// type: Windows.Storage.Compression.ICompressor
// interface type
open class ICompressor
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x0ac3645a, Data2: 0x57ac, Data3 : 0x4ee1, Data4 : (0xb7, 0x02, 0x84, 0xd3, 0x9d, 0x54, 0x24, 0xe0)) }
    // Windows.Foundation.IAsyncOperation<bool> FinishAsync()
    private func _n_FinishAsync(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1_boolean>>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CCompression_CICompressor.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.FinishAsync(pThis, __presult))
        }
    }
    public func FinishAsync() throws -> Optional<ClosedGenerics.IAsyncOperation_1_boolean> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1_boolean>> = nil;
        try self._n_FinishAsync(&__result);
        return ClosedGenerics.IAsyncOperation_1_boolean(consuming: __result);
    }
    public func Finish() async throws -> boolean {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.FinishAsync()!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Storage.Streams.IOutputStream DetachStream()
    private func _n_DetachStream(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIOutputStream>>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CCompression_CICompressor.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DetachStream(pThis, __presult))
        }
    }
    public func DetachStream() throws -> Optional<Windows.Storage.Streams.IOutputStream> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIOutputStream>> = nil;
        try self._n_DetachStream(&__result);
        return Windows.Storage.Streams.IOutputStream(consuming: __result);
    }
} // ICompressor


// type: Windows.Storage.Compression.ICompressorFactory
// interface type
// ACTIVATION INTERFACE
open class ICompressorFactory
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x5f3d96a4, Data2: 0x2cfb, Data3 : 0x442c, Data4 : (0xa8, 0xba, 0xd7, 0xd1, 0x1b, 0x03, 0x9d, 0xa0)) }
    // Windows.Storage.Compression.Compressor CreateCompressor(Windows.Storage.Streams.IOutputStream)
    private func _n_CreateCompressor(_ underlyingStream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIOutputStream>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CCompression_CICompressor>>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CCompression_CICompressorFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateCompressor(pThis, underlyingStream, __presult))
        }
    }
    public func CreateCompressor(underlyingStream : Optional<Windows.Storage.Streams.IOutputStream>) throws -> Optional<Windows.Storage.Compression.ICompressor> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CCompression_CICompressor>> = nil;
        try self._n_CreateCompressor(RawPointer(underlyingStream), &__result);
        return Windows.Storage.Compression.ICompressor(consuming: __result);
    }
    // Windows.Storage.Compression.Compressor CreateCompressorEx(Windows.Storage.Streams.IOutputStream, Windows.Storage.Compression.CompressAlgorithm, System.UInt32)
    private func _n_CreateCompressorEx(_ underlyingStream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIOutputStream>>, _ algorithm : _q_CWindows_CStorage_CCompression_CCompressAlgorithm, _ blockSize : UINT32, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CCompression_CICompressor>>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CCompression_CICompressorFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateCompressorEx(pThis, underlyingStream, algorithm, blockSize, __presult))
        }
    }
    public func CreateCompressorEx(underlyingStream : Optional<Windows.Storage.Streams.IOutputStream>, algorithm : Windows.Storage.Compression.CompressAlgorithm, blockSize : Swift.UInt32) throws -> Optional<Windows.Storage.Compression.ICompressor> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CCompression_CICompressor>> = nil;
        try self._n_CreateCompressorEx(RawPointer(underlyingStream), algorithm, blockSize, &__result);
        return Windows.Storage.Compression.ICompressor(consuming: __result);
    }
} // ICompressorFactory


// type: Windows.Storage.Compression.IDecompressor
// interface type
open class IDecompressor
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xb883fe46, Data2: 0xd68a, Data3 : 0x4c8b, Data4 : (0xad, 0xa0, 0x4e, 0xe8, 0x13, 0xfc, 0x52, 0x83)) }
    // Windows.Storage.Streams.IInputStream DetachStream()
    private func _n_DetachStream(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIInputStream>>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CCompression_CIDecompressor.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DetachStream(pThis, __presult))
        }
    }
    public func DetachStream() throws -> Optional<Windows.Storage.Streams.IInputStream> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIInputStream>> = nil;
        try self._n_DetachStream(&__result);
        return Windows.Storage.Streams.IInputStream(consuming: __result);
    }
} // IDecompressor


// type: Windows.Storage.Compression.IDecompressorFactory
// interface type
// ACTIVATION INTERFACE
open class IDecompressorFactory
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x5337e252, Data2: 0x1da2, Data3 : 0x42e1, Data4 : (0x88, 0x34, 0x03, 0x79, 0xd2, 0x8d, 0x74, 0x2f)) }
    // Windows.Storage.Compression.Decompressor CreateDecompressor(Windows.Storage.Streams.IInputStream)
    private func _n_CreateDecompressor(_ underlyingStream : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIInputStream>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CCompression_CIDecompressor>>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CCompression_CIDecompressorFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateDecompressor(pThis, underlyingStream, __presult))
        }
    }
    public func CreateDecompressor(underlyingStream : Optional<Windows.Storage.Streams.IInputStream>) throws -> Optional<Windows.Storage.Compression.IDecompressor> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CCompression_CIDecompressor>> = nil;
        try self._n_CreateDecompressor(RawPointer(underlyingStream), &__result);
        return Windows.Storage.Compression.IDecompressor(consuming: __result);
    }
} // IDecompressorFactory


}
extension Windows.Storage.Compression.CompressAlgorithm {
    public static var InvalidAlgorithm : Self {
        get {
            return _q_CWindows_CStorage_CCompression_CCompressAlgorithm_InvalidAlgorithm;
        }
    }
    public static var NullAlgorithm : Self {
        get {
            return _q_CWindows_CStorage_CCompression_CCompressAlgorithm_NullAlgorithm;
        }
    }
    public static var Mszip : Self {
        get {
            return _q_CWindows_CStorage_CCompression_CCompressAlgorithm_Mszip;
        }
    }
    public static var Xpress : Self {
        get {
            return _q_CWindows_CStorage_CCompression_CCompressAlgorithm_Xpress;
        }
    }
    public static var XpressHuff : Self {
        get {
            return _q_CWindows_CStorage_CCompression_CCompressAlgorithm_XpressHuff;
        }
    }
    public static var Lzms : Self {
        get {
            return _q_CWindows_CStorage_CCompression_CCompressAlgorithm_Lzms;
        }
    }
}
