// this file is automatically generated.
// if you modify it by hand, your changes will probably be lost.


import CWinRT;
import CWindowsSdk;
@_spi(IUnknown) import WinRT;

extension Windows.Security.Cryptography {
// type: Windows.Security.Cryptography.BinaryStringEncoding
// enum type
public typealias BinaryStringEncoding = _q_CWindows_CSecurity_CCryptography_CBinaryStringEncoding;

// type: Windows.Security.Cryptography.CryptographicBuffer
// static class
public class CryptographicBuffer
{
    private struct _ICryptographicBufferStatics {
        static var x : ICryptographicBufferStatics =
            try! RoGetActivationFactory("Windows.Security.Cryptography.CryptographicBuffer")
    }
    public static var CryptographicBufferStatics : ICryptographicBufferStatics {
        _ICryptographicBufferStatics.x
    }
    public static func Compare(object1 : Optional<Windows.Storage.Streams.IBuffer>, object2 : Optional<Windows.Storage.Streams.IBuffer>) throws -> boolean {
        return try CryptographicBufferStatics.Compare(object1: object1, object2: object2);
    }
    public static func GenerateRandom(length : Swift.UInt32) throws -> Optional<Windows.Storage.Streams.IBuffer> {
        return try CryptographicBufferStatics.GenerateRandom(length: length);
    }
    public static func GenerateRandomNumber() throws -> Swift.UInt32 {
        return try CryptographicBufferStatics.GenerateRandomNumber();
    }
    public static func CreateFromByteArray(valueLength : UINT32, value : Optional<UnsafeMutablePointer<UINT8>>) throws -> Optional<Windows.Storage.Streams.IBuffer> {
        return try CryptographicBufferStatics.CreateFromByteArray(valueLength: valueLength, value: value);
    }
    public static func CopyToByteArray(buffer : Optional<Windows.Storage.Streams.IBuffer>, valueLength : inout UINT32, value : inout Optional<UnsafeMutablePointer<UINT8>>) throws -> Void {
            var _tmp_out_valueLength: UINT32 = 0;
            var _tmp_out_value: Optional<UnsafeMutablePointer<UINT8>> = nil;
        return try CryptographicBufferStatics.CopyToByteArray(buffer: buffer, valueLength: &_tmp_out_valueLength, value: &_tmp_out_value);
    }
    public static func DecodeFromHexString(value : Swift.String) throws -> Optional<Windows.Storage.Streams.IBuffer> {
        return try CryptographicBufferStatics.DecodeFromHexString(value: value);
    }
    public static func EncodeToHexString(buffer : Optional<Windows.Storage.Streams.IBuffer>) throws -> Optional<Swift.String> {
        return try CryptographicBufferStatics.EncodeToHexString(buffer: buffer);
    }
    public static func DecodeFromBase64String(value : Swift.String) throws -> Optional<Windows.Storage.Streams.IBuffer> {
        return try CryptographicBufferStatics.DecodeFromBase64String(value: value);
    }
    public static func EncodeToBase64String(buffer : Optional<Windows.Storage.Streams.IBuffer>) throws -> Optional<Swift.String> {
        return try CryptographicBufferStatics.EncodeToBase64String(buffer: buffer);
    }
    public static func ConvertStringToBinary(value : Swift.String, encoding : Windows.Security.Cryptography.BinaryStringEncoding) throws -> Optional<Windows.Storage.Streams.IBuffer> {
        return try CryptographicBufferStatics.ConvertStringToBinary(value: value, encoding: encoding);
    }
    public static func ConvertBinaryToString(encoding : Windows.Security.Cryptography.BinaryStringEncoding, buffer : Optional<Windows.Storage.Streams.IBuffer>) throws -> Optional<Swift.String> {
        return try CryptographicBufferStatics.ConvertBinaryToString(encoding: encoding, buffer: buffer);
    }
}

// type: Windows.Security.Cryptography.ICryptographicBufferStatics
// interface type
open class ICryptographicBufferStatics
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x320b7e22, Data2: 0x3cb0, Data3 : 0x4cdf, Data4 : (0x86, 0x63, 0x1d, 0x28, 0x91, 0x00, 0x65, 0xeb)) }
    // bool Compare(Windows.Storage.Streams.IBuffer, Windows.Storage.Streams.IBuffer)
    private func _n_Compare(_ object1 : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ object2 : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CICryptographicBufferStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Compare(pThis, object1, object2, __presult))
        }
    }
    public func Compare(object1 : Optional<Windows.Storage.Streams.IBuffer>, object2 : Optional<Windows.Storage.Streams.IBuffer>) throws -> boolean {
        var __result : boolean = 0;
        try self._n_Compare(RawPointer(object1), RawPointer(object2), &__result);
        return __result;
    }
    // Windows.Storage.Streams.IBuffer GenerateRandom(System.UInt32)
    private func _n_GenerateRandom(_ length : UINT32, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>>?) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CICryptographicBufferStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GenerateRandom(pThis, length, __presult))
        }
    }
    public func GenerateRandom(length : Swift.UInt32) throws -> Optional<Windows.Storage.Streams.IBuffer> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>> = nil;
        try self._n_GenerateRandom(length, &__result);
        return Windows.Storage.Streams.IBuffer(consuming: __result);
    }
    // System.UInt32 GenerateRandomNumber()
    private func _n_GenerateRandomNumber(_ __presult: UnsafeMutablePointer<UINT32>?) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CICryptographicBufferStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GenerateRandomNumber(pThis, __presult))
        }
    }
    public func GenerateRandomNumber() throws -> Swift.UInt32 {
        var __result : UINT32 = 0;
        try self._n_GenerateRandomNumber(&__result);
        return __result;
    }
    // Windows.Storage.Streams.IBuffer CreateFromByteArray(System.Byte[])
    private func _n_CreateFromByteArray(_ valueLength : UINT32, _ value : Optional<UnsafeMutablePointer<UINT8>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>>?) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CICryptographicBufferStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateFromByteArray(pThis, valueLength, value, __presult))
        }
    }
    public func CreateFromByteArray(valueLength : UINT32, value : Optional<UnsafeMutablePointer<UINT8>>) throws -> Optional<Windows.Storage.Streams.IBuffer> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>> = nil;
        try self._n_CreateFromByteArray(valueLength, value, &__result);
        return Windows.Storage.Streams.IBuffer(consuming: __result);
    }
    // void CopyToByteArray(Windows.Storage.Streams.IBuffer, ref System.Byte[])
    private func _n_CopyToByteArray(_ buffer : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ valueLength : UnsafeMutablePointer<UINT32>, _ value : UnsafeMutablePointer<Optional<UnsafeMutablePointer<UINT8>>>) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CICryptographicBufferStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CopyToByteArray(pThis, buffer, valueLength, value))
        }
    }
    public func CopyToByteArray(buffer : Optional<Windows.Storage.Streams.IBuffer>, valueLength : inout UINT32, value : inout Optional<UnsafeMutablePointer<UINT8>>) throws -> Void {
            var _tmp_out_valueLength: UINT32 = 0;
            var _tmp_out_value: Optional<UnsafeMutablePointer<UINT8>> = nil;
        try self._n_CopyToByteArray(RawPointer(buffer), &_tmp_out_valueLength, &_tmp_out_value);
            value = _tmp_out_value;
    }
    // Windows.Storage.Streams.IBuffer DecodeFromHexString(System.String)
    private func _n_DecodeFromHexString(_ value : Optional<HSTRING>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>>?) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CICryptographicBufferStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DecodeFromHexString(pThis, value, __presult))
        }
    }
    public func DecodeFromHexString(value : Swift.String) throws -> Optional<Windows.Storage.Streams.IBuffer> {
        let __hstr_value = try HString(value);
        return try withExtendedLifetime(__hstr_value) {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>> = nil;
        try self._n_DecodeFromHexString(__hstr_value.Raw(), &__result);
        return Windows.Storage.Streams.IBuffer(consuming: __result);
        }
    }
    // System.String EncodeToHexString(Windows.Storage.Streams.IBuffer)
    private func _n_EncodeToHexString(_ buffer : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ __presult: UnsafeMutablePointer<Optional<HSTRING>>?) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CICryptographicBufferStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.EncodeToHexString(pThis, buffer, __presult))
        }
    }
    public func EncodeToHexString(buffer : Optional<Windows.Storage.Streams.IBuffer>) throws -> Swift.String {
        var __result : Optional<HSTRING> = nil;
        try self._n_EncodeToHexString(RawPointer(buffer), &__result);
        return Swift.String(from: __result);
    }
    // Windows.Storage.Streams.IBuffer DecodeFromBase64String(System.String)
    private func _n_DecodeFromBase64String(_ value : Optional<HSTRING>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>>?) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CICryptographicBufferStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.DecodeFromBase64String(pThis, value, __presult))
        }
    }
    public func DecodeFromBase64String(value : Swift.String) throws -> Optional<Windows.Storage.Streams.IBuffer> {
        let __hstr_value = try HString(value);
        return try withExtendedLifetime(__hstr_value) {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>> = nil;
        try self._n_DecodeFromBase64String(__hstr_value.Raw(), &__result);
        return Windows.Storage.Streams.IBuffer(consuming: __result);
        }
    }
    // System.String EncodeToBase64String(Windows.Storage.Streams.IBuffer)
    private func _n_EncodeToBase64String(_ buffer : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ __presult: UnsafeMutablePointer<Optional<HSTRING>>?) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CICryptographicBufferStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.EncodeToBase64String(pThis, buffer, __presult))
        }
    }
    public func EncodeToBase64String(buffer : Optional<Windows.Storage.Streams.IBuffer>) throws -> Swift.String {
        var __result : Optional<HSTRING> = nil;
        try self._n_EncodeToBase64String(RawPointer(buffer), &__result);
        return Swift.String(from: __result);
    }
    // Windows.Storage.Streams.IBuffer ConvertStringToBinary(System.String, Windows.Security.Cryptography.BinaryStringEncoding)
    private func _n_ConvertStringToBinary(_ value : Optional<HSTRING>, _ encoding : _q_CWindows_CSecurity_CCryptography_CBinaryStringEncoding, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>>?) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CICryptographicBufferStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ConvertStringToBinary(pThis, value, encoding, __presult))
        }
    }
    public func ConvertStringToBinary(value : Swift.String, encoding : Windows.Security.Cryptography.BinaryStringEncoding) throws -> Optional<Windows.Storage.Streams.IBuffer> {
        let __hstr_value = try HString(value);
        return try withExtendedLifetime(__hstr_value) {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>> = nil;
        try self._n_ConvertStringToBinary(__hstr_value.Raw(), encoding, &__result);
        return Windows.Storage.Streams.IBuffer(consuming: __result);
        }
    }
    // System.String ConvertBinaryToString(Windows.Security.Cryptography.BinaryStringEncoding, Windows.Storage.Streams.IBuffer)
    private func _n_ConvertBinaryToString(_ encoding : _q_CWindows_CSecurity_CCryptography_CBinaryStringEncoding, _ buffer : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ __presult: UnsafeMutablePointer<Optional<HSTRING>>?) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CICryptographicBufferStatics.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ConvertBinaryToString(pThis, encoding, buffer, __presult))
        }
    }
    public func ConvertBinaryToString(encoding : Windows.Security.Cryptography.BinaryStringEncoding, buffer : Optional<Windows.Storage.Streams.IBuffer>) throws -> Swift.String {
        var __result : Optional<HSTRING> = nil;
        try self._n_ConvertBinaryToString(encoding, RawPointer(buffer), &__result);
        return Swift.String(from: __result);
    }
} // ICryptographicBufferStatics


}
extension Windows.Security.Cryptography.BinaryStringEncoding {
    public static var Utf8 : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CBinaryStringEncoding_Utf8;
        }
    }
    public static var Utf16LE : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CBinaryStringEncoding_Utf16LE;
        }
    }
    public static var Utf16BE : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CBinaryStringEncoding_Utf16BE;
        }
    }
}
