// this file is automatically generated.
// if you modify it by hand, your changes will probably be lost.


import CWinRT;
@_spi(IUnknown) import WinRT;
import CWindowsSdk;

extension Windows.Storage.AccessCache {
// type: Windows.Storage.AccessCache.AccessCacheOptions
// enum type
public typealias AccessCacheOptions = _q_CWindows_CStorage_CAccessCache_CAccessCacheOptions;

// type: Windows.Storage.AccessCache.AccessListEntry
// struct type
public typealias AccessListEntry = _q_CWindows_CStorage_CAccessCache_CAccessListEntry;

// type: Windows.Storage.AccessCache.AccessListEntryView
// runtime class
public class AccessListEntryView
    :
    WinRT.Object
{
    private var _self : ClosedGenerics.IVectorView_1__q_CWindows_CStorage_CAccessCache_CAccessListEntry;
    public init(plok: ClosedGenerics.IVectorView_1__q_CWindows_CStorage_CAccessCache_CAccessListEntry?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> ClosedGenerics.IVectorView_1__q_CWindows_CStorage_CAccessCache_CAccessListEntry { return _self; }
    // method not needed: GetAt
    // method not needed: get_Size
    // method not needed: IndexOf
    // method not needed: GetMany
    // method not needed: First
}

// type: Windows.Storage.AccessCache.IItemRemovedEventArgs
// interface type
open class IItemRemovedEventArgs
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x59677e5c, Data2: 0x55be, Data3 : 0x4c66, Data4 : (0xba, 0x66, 0x5e, 0xae, 0xa7, 0x9d, 0x26, 0x31)) }
    // [IsSpecialName] Windows.Storage.AccessCache.AccessListEntry get_RemovedEntry()
    private func _n_get_RemovedEntry(_ __presult: UnsafeMutablePointer<_q_CWindows_CStorage_CAccessCache_CAccessListEntry>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIItemRemovedEventArgs.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_RemovedEntry(pThis, __presult))
        }
    }
    public func get_RemovedEntry() throws -> Windows.Storage.AccessCache.AccessListEntry {
        var __result : _q_CWindows_CStorage_CAccessCache_CAccessListEntry = _q_CWindows_CStorage_CAccessCache_CAccessListEntry(Token: nil, Metadata: nil);
        try self._n_get_RemovedEntry(&__result);
        return __result;
    }
    public var RemovedEntry : Windows.Storage.AccessCache.AccessListEntry {
        get throws {
            return try get_RemovedEntry();
        }
    }
} // IItemRemovedEventArgs


// type: Windows.Storage.AccessCache.IStorageItemAccessList
// interface type
open class IStorageItemAccessList
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x2caff6ad, Data2: 0xde90, Data3 : 0x47f5, Data4 : (0xb2, 0xc3, 0xdd, 0x36, 0xc9, 0xfd, 0xd4, 0x53)) }
    // System.String Add(Windows.Storage.IStorageItem)
    private func _n_AddOverloadDefaultMetadata(_ file : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CIStorageItem>>, _ __presult: UnsafeMutablePointer<Optional<HSTRING>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.AddOverloadDefaultMetadata(pThis, file, __presult))
        }
    }
    public func AddOverloadDefaultMetadata(file : Optional<Windows.Storage.IStorageItem>) throws -> Swift.String {
        var __result : Optional<HSTRING> = nil;
        try self._n_AddOverloadDefaultMetadata(RawPointer(file), &__result);
        return Swift.String(from: __result);
    }
    // System.String Add(Windows.Storage.IStorageItem, System.String)
    private func _n_Add(_ file : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CIStorageItem>>, _ metadata : Optional<HSTRING>, _ __presult: UnsafeMutablePointer<Optional<HSTRING>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Add(pThis, file, metadata, __presult))
        }
    }
    public func Add(file : Optional<Windows.Storage.IStorageItem>, metadata : Swift.String) throws -> Swift.String {
        let __hstr_metadata = try HString(metadata);
        return try withExtendedLifetime(__hstr_metadata) {
        var __result : Optional<HSTRING> = nil;
        try self._n_Add(RawPointer(file), __hstr_metadata.Raw(), &__result);
        return Swift.String(from: __result);
        }
    }
    // void AddOrReplace(System.String, Windows.Storage.IStorageItem)
    private func _n_AddOrReplaceOverloadDefaultMetadata(_ token : Optional<HSTRING>, _ file : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CIStorageItem>>) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.AddOrReplaceOverloadDefaultMetadata(pThis, token, file))
        }
    }
    public func AddOrReplaceOverloadDefaultMetadata(token : Swift.String, file : Optional<Windows.Storage.IStorageItem>) throws -> Void {
        let __hstr_token = try HString(token);
        return try withExtendedLifetime(__hstr_token) {
        try self._n_AddOrReplaceOverloadDefaultMetadata(__hstr_token.Raw(), RawPointer(file));
        }
    }
    // void AddOrReplace(System.String, Windows.Storage.IStorageItem, System.String)
    private func _n_AddOrReplace(_ token : Optional<HSTRING>, _ file : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CIStorageItem>>, _ metadata : Optional<HSTRING>) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.AddOrReplace(pThis, token, file, metadata))
        }
    }
    public func AddOrReplace(token : Swift.String, file : Optional<Windows.Storage.IStorageItem>, metadata : Swift.String) throws -> Void {
        let __hstr_token = try HString(token);
        return try withExtendedLifetime(__hstr_token) {
        let __hstr_metadata = try HString(metadata);
        return try withExtendedLifetime(__hstr_metadata) {
        try self._n_AddOrReplace(__hstr_token.Raw(), RawPointer(file), __hstr_metadata.Raw());
        }
        }
    }
    // Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem> GetItemAsync(System.String)
    private func _n_GetItemAsync(_ token : Optional<HSTRING>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CWindows_CStorage_CIStorageItem>>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetItemAsync(pThis, token, __presult))
        }
    }
    public func GetItemAsync(token : Swift.String) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CIStorageItem> {
        let __hstr_token = try HString(token);
        return try withExtendedLifetime(__hstr_token) {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CWindows_CStorage_CIStorageItem>> = nil;
        try self._n_GetItemAsync(__hstr_token.Raw(), &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CIStorageItem(consuming: __result);
        }
    }
    public func GetItem(token : Swift.String) async throws -> Optional<Windows.Storage.IStorageItem> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.GetItemAsync(token: token)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile> GetFileAsync(System.String)
    private func _n_GetFileAsync(_ token : Optional<HSTRING>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CWindows_CStorage_CStorageFile>>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetFileAsync(pThis, token, __presult))
        }
    }
    public func GetFileAsync(token : Swift.String) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFile> {
        let __hstr_token = try HString(token);
        return try withExtendedLifetime(__hstr_token) {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CWindows_CStorage_CStorageFile>> = nil;
        try self._n_GetFileAsync(__hstr_token.Raw(), &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFile(consuming: __result);
        }
    }
    public func GetFile(token : Swift.String) async throws -> Optional<Windows.Storage.IStorageFile> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.GetFileAsync(token: token)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder> GetFolderAsync(System.String)
    private func _n_GetFolderAsync(_ token : Optional<HSTRING>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CWindows_CStorage_CStorageFolder>>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetFolderAsync(pThis, token, __presult))
        }
    }
    public func GetFolderAsync(token : Swift.String) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFolder> {
        let __hstr_token = try HString(token);
        return try withExtendedLifetime(__hstr_token) {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CWindows_CStorage_CStorageFolder>> = nil;
        try self._n_GetFolderAsync(__hstr_token.Raw(), &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFolder(consuming: __result);
        }
    }
    public func GetFolder(token : Swift.String) async throws -> Optional<Windows.Storage.IStorageFolder> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.GetFolderAsync(token: token)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Windows.Storage.IStorageItem> GetItemAsync(System.String, Windows.Storage.AccessCache.AccessCacheOptions)
    private func _n_GetItemWithOptionsAsync(_ token : Optional<HSTRING>, _ options : _q_CWindows_CStorage_CAccessCache_CAccessCacheOptions, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CWindows_CStorage_CIStorageItem>>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetItemWithOptionsAsync(pThis, token, options, __presult))
        }
    }
    public func GetItemWithOptionsAsync(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CIStorageItem> {
        let __hstr_token = try HString(token);
        return try withExtendedLifetime(__hstr_token) {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CWindows_CStorage_CIStorageItem>> = nil;
        try self._n_GetItemWithOptionsAsync(__hstr_token.Raw(), options, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CIStorageItem(consuming: __result);
        }
    }
    public func GetItemWithOptions(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) async throws -> Optional<Windows.Storage.IStorageItem> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.GetItemWithOptionsAsync(token: token, options: options)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFile> GetFileAsync(System.String, Windows.Storage.AccessCache.AccessCacheOptions)
    private func _n_GetFileWithOptionsAsync(_ token : Optional<HSTRING>, _ options : _q_CWindows_CStorage_CAccessCache_CAccessCacheOptions, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CWindows_CStorage_CStorageFile>>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetFileWithOptionsAsync(pThis, token, options, __presult))
        }
    }
    public func GetFileWithOptionsAsync(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFile> {
        let __hstr_token = try HString(token);
        return try withExtendedLifetime(__hstr_token) {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CWindows_CStorage_CStorageFile>> = nil;
        try self._n_GetFileWithOptionsAsync(__hstr_token.Raw(), options, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFile(consuming: __result);
        }
    }
    public func GetFileWithOptions(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) async throws -> Optional<Windows.Storage.IStorageFile> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.GetFileWithOptionsAsync(token: token, options: options)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // Windows.Foundation.IAsyncOperation<Windows.Storage.StorageFolder> GetFolderAsync(System.String, Windows.Storage.AccessCache.AccessCacheOptions)
    private func _n_GetFolderWithOptionsAsync(_ token : Optional<HSTRING>, _ options : _q_CWindows_CStorage_CAccessCache_CAccessCacheOptions, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CWindows_CStorage_CStorageFolder>>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.GetFolderWithOptionsAsync(pThis, token, options, __presult))
        }
    }
    public func GetFolderWithOptionsAsync(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFolder> {
        let __hstr_token = try HString(token);
        return try withExtendedLifetime(__hstr_token) {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_IAsyncOperation_1__q_CWindows_CStorage_CStorageFolder>> = nil;
        try self._n_GetFolderWithOptionsAsync(__hstr_token.Raw(), options, &__result);
        return ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFolder(consuming: __result);
        }
    }
    public func GetFolderWithOptions(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) async throws -> Optional<Windows.Storage.IStorageFolder> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.GetFolderWithOptionsAsync(token: token, options: options)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    // void Remove(System.String)
    private func _n_Remove(_ token : Optional<HSTRING>) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Remove(pThis, token))
        }
    }
    public func Remove(token : Swift.String) throws -> Void {
        let __hstr_token = try HString(token);
        return try withExtendedLifetime(__hstr_token) {
        try self._n_Remove(__hstr_token.Raw());
        }
    }
    // bool ContainsItem(System.String)
    private func _n_ContainsItem(_ token : Optional<HSTRING>, _ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.ContainsItem(pThis, token, __presult))
        }
    }
    public func ContainsItem(token : Swift.String) throws -> boolean {
        let __hstr_token = try HString(token);
        return try withExtendedLifetime(__hstr_token) {
        var __result : boolean = 0;
        try self._n_ContainsItem(__hstr_token.Raw(), &__result);
        return __result;
        }
    }
    // void Clear()
    private func _n_Clear() throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.Clear(pThis))
        }
    }
    public func Clear() throws -> Void {
        try self._n_Clear();
    }
    // bool CheckAccess(Windows.Storage.IStorageItem)
    private func _n_CheckAccess(_ file : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CIStorageItem>>, _ __presult: UnsafeMutablePointer<boolean>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CheckAccess(pThis, file, __presult))
        }
    }
    public func CheckAccess(file : Optional<Windows.Storage.IStorageItem>) throws -> boolean {
        var __result : boolean = 0;
        try self._n_CheckAccess(RawPointer(file), &__result);
        return __result;
    }
    // [IsSpecialName] Windows.Storage.AccessCache.AccessListEntryView get_Entries()
    private func _n_get_Entries(_ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_CCollections_IVectorView_1__q_CWindows_CStorage_CAccessCache_CAccessListEntry>>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_Entries(pThis, __presult))
        }
    }
    public func get_Entries() throws -> Optional<ClosedGenerics.IVectorView_1__q_CWindows_CStorage_CAccessCache_CAccessListEntry> {
        var __result : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_CCollections_IVectorView_1__q_CWindows_CStorage_CAccessCache_CAccessListEntry>> = nil;
        try self._n_get_Entries(&__result);
        return ClosedGenerics.IVectorView_1__q_CWindows_CStorage_CAccessCache_CAccessListEntry(consuming: __result);
    }
    // [IsSpecialName] System.UInt32 get_MaximumItemsAllowed()
    private func _n_get_MaximumItemsAllowed(_ __presult: UnsafeMutablePointer<UINT32>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemAccessList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.get_MaximumItemsAllowed(pThis, __presult))
        }
    }
    public func get_MaximumItemsAllowed() throws -> Swift.UInt32 {
        var __result : UINT32 = 0;
        try self._n_get_MaximumItemsAllowed(&__result);
        return __result;
    }
    public var Entries : Optional<ClosedGenerics.IVectorView_1__q_CWindows_CStorage_CAccessCache_CAccessListEntry> {
        get throws {
            return try get_Entries();
        }
    }
    public var MaximumItemsAllowed : Swift.UInt32 {
        get throws {
            return try get_MaximumItemsAllowed();
        }
    }
} // IStorageItemAccessList


// type: Windows.Storage.AccessCache.IStorageItemMostRecentlyUsedList
// interface type
open class IStorageItemMostRecentlyUsedList
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x016239d5, Data2: 0x510d, Data3 : 0x411e, Data4 : (0x8c, 0xf1, 0xc3, 0xd1, 0xef, 0xfa, 0x4c, 0x33)) }
    // [IsSpecialName] Windows.Foundation.EventRegistrationToken add_ItemRemoved(Windows.Foundation.TypedEventHandler<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList,Windows.Storage.AccessCache.ItemRemovedEventArgs>)
    private func _n_add_ItemRemoved(_ handler : Optional<UnsafeMutablePointer<_cg_CWindows_CFoundation_ITypedEventHandler_2__q_CWindows_CStorage_CAccessCache_CStorageItemMostRecentlyUsedList__q_CWindows_CStorage_CAccessCache_CItemRemovedEventArgs>>, _ __presult: UnsafeMutablePointer<_q_CWindows_CFoundation_CEventRegistrationToken>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemMostRecentlyUsedList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.add_ItemRemoved(pThis, handler, __presult))
        }
    }
    public func add_ItemRemoved(handler : Optional<ClosedGenerics.ITypedEventHandler_2__q_CWindows_CStorage_CAccessCache_CStorageItemMostRecentlyUsedList__q_CWindows_CStorage_CAccessCache_CItemRemovedEventArgs>) throws -> Windows.Foundation.EventRegistrationToken {
        var __result : _q_CWindows_CFoundation_CEventRegistrationToken = _q_CWindows_CFoundation_CEventRegistrationToken(Value: 0);
        try self._n_add_ItemRemoved(RawPointer(handler), &__result);
        return __result;
    }
    // [IsSpecialName] void remove_ItemRemoved(Windows.Foundation.EventRegistrationToken)
    private func _n_remove_ItemRemoved(_ eventCookie : _q_CWindows_CFoundation_CEventRegistrationToken) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemMostRecentlyUsedList.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.remove_ItemRemoved(pThis, eventCookie))
        }
    }
    public func remove_ItemRemoved(eventCookie : Windows.Foundation.EventRegistrationToken) throws -> Void {
        try self._n_remove_ItemRemoved(eventCookie);
    }
} // IStorageItemMostRecentlyUsedList


// type: Windows.Storage.AccessCache.IStorageItemMostRecentlyUsedList2
// interface type
open class IStorageItemMostRecentlyUsedList2
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0xda481ea0, Data2: 0xed8d, Data3 : 0x4731, Data4 : (0xa1, 0xdb, 0xe4, 0x4e, 0xe2, 0x20, 0x40, 0x93)) }
    // System.String Add(Windows.Storage.IStorageItem, System.String, Windows.Storage.AccessCache.RecentStorageItemVisibility)
    private func _n_AddWithMetadataAndVisibility(_ file : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CIStorageItem>>, _ metadata : Optional<HSTRING>, _ visibility : _q_CWindows_CStorage_CAccessCache_CRecentStorageItemVisibility, _ __presult: UnsafeMutablePointer<Optional<HSTRING>>?) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemMostRecentlyUsedList2.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.AddWithMetadataAndVisibility(pThis, file, metadata, visibility, __presult))
        }
    }
    public func AddWithMetadataAndVisibility(file : Optional<Windows.Storage.IStorageItem>, metadata : Swift.String, visibility : Windows.Storage.AccessCache.RecentStorageItemVisibility) throws -> Swift.String {
        let __hstr_metadata = try HString(metadata);
        return try withExtendedLifetime(__hstr_metadata) {
        var __result : Optional<HSTRING> = nil;
        try self._n_AddWithMetadataAndVisibility(RawPointer(file), __hstr_metadata.Raw(), visibility, &__result);
        return Swift.String(from: __result);
        }
    }
    // void AddOrReplace(System.String, Windows.Storage.IStorageItem, System.String, Windows.Storage.AccessCache.RecentStorageItemVisibility)
    private func _n_AddOrReplaceWithMetadataAndVisibility(_ token : Optional<HSTRING>, _ file : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CIStorageItem>>, _ metadata : Optional<HSTRING>, _ visibility : _q_CWindows_CStorage_CAccessCache_CRecentStorageItemVisibility) throws {
        return try perform(as: _q_CWindows_CStorage_CAccessCache_CIStorageItemMostRecentlyUsedList2.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.AddOrReplaceWithMetadataAndVisibility(pThis, token, file, metadata, visibility))
        }
    }
    public func AddOrReplaceWithMetadataAndVisibility(token : Swift.String, file : Optional<Windows.Storage.IStorageItem>, metadata : Swift.String, visibility : Windows.Storage.AccessCache.RecentStorageItemVisibility) throws -> Void {
        let __hstr_token = try HString(token);
        return try withExtendedLifetime(__hstr_token) {
        let __hstr_metadata = try HString(metadata);
        return try withExtendedLifetime(__hstr_metadata) {
        try self._n_AddOrReplaceWithMetadataAndVisibility(__hstr_token.Raw(), RawPointer(file), __hstr_metadata.Raw(), visibility);
        }
        }
    }
} // IStorageItemMostRecentlyUsedList2


// type: Windows.Storage.AccessCache.ItemRemovedEventArgs
// runtime class
public class ItemRemovedEventArgs
    :
    WinRT.Object
{
    private var _self : Windows.Storage.AccessCache.IItemRemovedEventArgs;
    public init(plok: Windows.Storage.AccessCache.IItemRemovedEventArgs?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Windows.Storage.AccessCache.IItemRemovedEventArgs { return _self; }
    public func get_RemovedEntry() throws -> Windows.Storage.AccessCache.AccessListEntry {
        let _ifc : Windows.Storage.AccessCache.IItemRemovedEventArgs = try _self.QueryInterface();
        return try _ifc.get_RemovedEntry();
    }
    public var RemovedEntry : Windows.Storage.AccessCache.AccessListEntry {
        get throws {
        let _ifc : Windows.Storage.AccessCache.IItemRemovedEventArgs = try _self.QueryInterface();
        return try _ifc.RemovedEntry;
        }
    }
}

// type: Windows.Storage.AccessCache.RecentStorageItemVisibility
// enum type
public typealias RecentStorageItemVisibility = _q_CWindows_CStorage_CAccessCache_CRecentStorageItemVisibility;

// type: Windows.Storage.AccessCache.StorageItemAccessList
// runtime class
public class StorageItemAccessList
    :
    WinRT.Object
{
    private var _self : Windows.Storage.AccessCache.IStorageItemAccessList;
    public init(plok: Windows.Storage.AccessCache.IStorageItemAccessList?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Windows.Storage.AccessCache.IStorageItemAccessList { return _self; }
    public func Add(file : Optional<Windows.Storage.IStorageItem>) throws -> Optional<Swift.String> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.AddOverloadDefaultMetadata(file: file);
    }
    public func Add(file : Optional<Windows.Storage.IStorageItem>, metadata : Swift.String) throws -> Optional<Swift.String> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.Add(file: file, metadata: metadata);
    }
    public func AddOrReplace(token : Swift.String, file : Optional<Windows.Storage.IStorageItem>) throws -> Void {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.AddOrReplaceOverloadDefaultMetadata(token: token, file: file);
    }
    public func AddOrReplace(token : Swift.String, file : Optional<Windows.Storage.IStorageItem>, metadata : Swift.String) throws -> Void {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.AddOrReplace(token: token, file: file, metadata: metadata);
    }
    public func GetItemAsync(token : Swift.String) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CIStorageItem> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.GetItemAsync(token: token);
    }
    public func GetItem(token : Swift.String) async throws -> Optional<Windows.Storage.IStorageItem> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.GetItemAsync(token: token)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func GetFileAsync(token : Swift.String) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFile> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.GetFileAsync(token: token);
    }
    public func GetFile(token : Swift.String) async throws -> Optional<Windows.Storage.StorageFile> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Windows.Storage.StorageFile(plok: self.GetFileAsync(token: token)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func GetFolderAsync(token : Swift.String) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFolder> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.GetFolderAsync(token: token);
    }
    public func GetFolder(token : Swift.String) async throws -> Optional<Windows.Storage.StorageFolder> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Windows.Storage.StorageFolder(plok: self.GetFolderAsync(token: token)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func GetItemAsync(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CIStorageItem> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.GetItemWithOptionsAsync(token: token, options: options);
    }
    public func GetItem(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) async throws -> Optional<Windows.Storage.IStorageItem> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.GetItemAsync(token: token, options: options)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func GetFileAsync(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFile> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.GetFileWithOptionsAsync(token: token, options: options);
    }
    public func GetFile(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) async throws -> Optional<Windows.Storage.StorageFile> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Windows.Storage.StorageFile(plok: self.GetFileAsync(token: token, options: options)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func GetFolderAsync(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFolder> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.GetFolderWithOptionsAsync(token: token, options: options);
    }
    public func GetFolder(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) async throws -> Optional<Windows.Storage.StorageFolder> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Windows.Storage.StorageFolder(plok: self.GetFolderAsync(token: token, options: options)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func Remove(token : Swift.String) throws -> Void {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.Remove(token: token);
    }
    public func ContainsItem(token : Swift.String) throws -> boolean {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.ContainsItem(token: token);
    }
    public func Clear() throws -> Void {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.Clear();
    }
    public func CheckAccess(file : Optional<Windows.Storage.IStorageItem>) throws -> boolean {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.CheckAccess(file: file);
    }
    public func get_Entries() throws -> Optional<Windows.Storage.AccessCache.AccessListEntryView> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try Windows.Storage.AccessCache.AccessListEntryView(plok: _ifc.get_Entries());
    }
    public func get_MaximumItemsAllowed() throws -> Swift.UInt32 {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.get_MaximumItemsAllowed();
    }
    public var Entries : Optional<Windows.Storage.AccessCache.AccessListEntryView> {
        get throws {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try Windows.Storage.AccessCache.AccessListEntryView(plok: _ifc.Entries);
        }
    }
    public var MaximumItemsAllowed : Swift.UInt32 {
        get throws {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.MaximumItemsAllowed;
        }
    }
}

// type: Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList
// runtime class
public class StorageItemMostRecentlyUsedList
    :
    WinRT.Object
{
    private var _self : Windows.Storage.AccessCache.IStorageItemMostRecentlyUsedList;
    public init(plok: Windows.Storage.AccessCache.IStorageItemMostRecentlyUsedList?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Windows.Storage.AccessCache.IStorageItemMostRecentlyUsedList { return _self; }
    public func add_ItemRemoved(handler : @escaping (Optional<Windows.Storage.AccessCache.StorageItemMostRecentlyUsedList>, Optional<Windows.Storage.AccessCache.ItemRemovedEventArgs>) throws -> Void) throws -> Windows.Foundation.EventRegistrationToken {
        let _ifc : Windows.Storage.AccessCache.IStorageItemMostRecentlyUsedList = try _self.QueryInterface();
        return try _ifc.add_ItemRemoved(handler: ClosedGenerics.TypedEventHandler_2__q_CWindows_CStorage_CAccessCache_CStorageItemMostRecentlyUsedList__q_CWindows_CStorage_CAccessCache_CItemRemovedEventArgs(cb: handler).Interface());
    }
    public func remove_ItemRemoved(eventCookie : Windows.Foundation.EventRegistrationToken) throws -> Void {
        let _ifc : Windows.Storage.AccessCache.IStorageItemMostRecentlyUsedList = try _self.QueryInterface();
        return try _ifc.remove_ItemRemoved(eventCookie: eventCookie);
    }
    public func Add(file : Optional<Windows.Storage.IStorageItem>) throws -> Optional<Swift.String> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.AddOverloadDefaultMetadata(file: file);
    }
    public func Add(file : Optional<Windows.Storage.IStorageItem>, metadata : Swift.String) throws -> Optional<Swift.String> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.Add(file: file, metadata: metadata);
    }
    public func AddOrReplace(token : Swift.String, file : Optional<Windows.Storage.IStorageItem>) throws -> Void {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.AddOrReplaceOverloadDefaultMetadata(token: token, file: file);
    }
    public func AddOrReplace(token : Swift.String, file : Optional<Windows.Storage.IStorageItem>, metadata : Swift.String) throws -> Void {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.AddOrReplace(token: token, file: file, metadata: metadata);
    }
    public func GetItemAsync(token : Swift.String) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CIStorageItem> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.GetItemAsync(token: token);
    }
    public func GetItem(token : Swift.String) async throws -> Optional<Windows.Storage.IStorageItem> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.GetItemAsync(token: token)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func GetFileAsync(token : Swift.String) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFile> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.GetFileAsync(token: token);
    }
    public func GetFile(token : Swift.String) async throws -> Optional<Windows.Storage.StorageFile> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Windows.Storage.StorageFile(plok: self.GetFileAsync(token: token)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func GetFolderAsync(token : Swift.String) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFolder> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.GetFolderAsync(token: token);
    }
    public func GetFolder(token : Swift.String) async throws -> Optional<Windows.Storage.StorageFolder> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Windows.Storage.StorageFolder(plok: self.GetFolderAsync(token: token)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func GetItemAsync(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CIStorageItem> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.GetItemWithOptionsAsync(token: token, options: options);
    }
    public func GetItem(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) async throws -> Optional<Windows.Storage.IStorageItem> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: self.GetItemAsync(token: token, options: options)!.get())
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func GetFileAsync(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFile> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.GetFileWithOptionsAsync(token: token, options: options);
    }
    public func GetFile(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) async throws -> Optional<Windows.Storage.StorageFile> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Windows.Storage.StorageFile(plok: self.GetFileAsync(token: token, options: options)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func GetFolderAsync(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) throws -> Optional<ClosedGenerics.IAsyncOperation_1__q_CWindows_CStorage_CStorageFolder> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.GetFolderWithOptionsAsync(token: token, options: options);
    }
    public func GetFolder(token : Swift.String, options : Windows.Storage.AccessCache.AccessCacheOptions) async throws -> Optional<Windows.Storage.StorageFolder> {
        return try await withUnsafeThrowingContinuation { continuation in
            do {
                return try continuation.resume(returning: Windows.Storage.StorageFolder(plok: self.GetFolderAsync(token: token, options: options)!.get()))
            } catch let error {
                return continuation.resume(throwing: error)
            }
        }
    }
    public func Remove(token : Swift.String) throws -> Void {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.Remove(token: token);
    }
    public func ContainsItem(token : Swift.String) throws -> boolean {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.ContainsItem(token: token);
    }
    public func Clear() throws -> Void {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.Clear();
    }
    public func CheckAccess(file : Optional<Windows.Storage.IStorageItem>) throws -> boolean {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.CheckAccess(file: file);
    }
    public func get_Entries() throws -> Optional<Windows.Storage.AccessCache.AccessListEntryView> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try Windows.Storage.AccessCache.AccessListEntryView(plok: _ifc.get_Entries());
    }
    public func get_MaximumItemsAllowed() throws -> Swift.UInt32 {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.get_MaximumItemsAllowed();
    }
    public var Entries : Optional<Windows.Storage.AccessCache.AccessListEntryView> {
        get throws {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try Windows.Storage.AccessCache.AccessListEntryView(plok: _ifc.Entries);
        }
    }
    public var MaximumItemsAllowed : Swift.UInt32 {
        get throws {
        let _ifc : Windows.Storage.AccessCache.IStorageItemAccessList = try _self.QueryInterface();
        return try _ifc.MaximumItemsAllowed;
        }
    }
    public func Add(file : Optional<Windows.Storage.IStorageItem>, metadata : Swift.String, visibility : Windows.Storage.AccessCache.RecentStorageItemVisibility) throws -> Optional<Swift.String> {
        let _ifc : Windows.Storage.AccessCache.IStorageItemMostRecentlyUsedList2 = try _self.QueryInterface();
        return try _ifc.AddWithMetadataAndVisibility(file: file, metadata: metadata, visibility: visibility);
    }
    public func AddOrReplace(token : Swift.String, file : Optional<Windows.Storage.IStorageItem>, metadata : Swift.String, visibility : Windows.Storage.AccessCache.RecentStorageItemVisibility) throws -> Void {
        let _ifc : Windows.Storage.AccessCache.IStorageItemMostRecentlyUsedList2 = try _self.QueryInterface();
        return try _ifc.AddOrReplaceWithMetadataAndVisibility(token: token, file: file, metadata: metadata, visibility: visibility);
    }
}

}
extension Windows.Storage.AccessCache.AccessCacheOptions {
    public static var None : Self {
        get {
            return _q_CWindows_CStorage_CAccessCache_CAccessCacheOptions_None;
        }
    }
    public static var DisallowUserInput : Self {
        get {
            return _q_CWindows_CStorage_CAccessCache_CAccessCacheOptions_DisallowUserInput;
        }
    }
    public static var FastLocationsOnly : Self {
        get {
            return _q_CWindows_CStorage_CAccessCache_CAccessCacheOptions_FastLocationsOnly;
        }
    }
    public static var UseReadOnlyCachedCopy : Self {
        get {
            return _q_CWindows_CStorage_CAccessCache_CAccessCacheOptions_UseReadOnlyCachedCopy;
        }
    }
    public static var SuppressAccessTimeUpdate : Self {
        get {
            return _q_CWindows_CStorage_CAccessCache_CAccessCacheOptions_SuppressAccessTimeUpdate;
        }
    }
}
extension Windows.Storage.AccessCache.RecentStorageItemVisibility {
    public static var AppOnly : Self {
        get {
            return _q_CWindows_CStorage_CAccessCache_CRecentStorageItemVisibility_AppOnly;
        }
    }
    public static var AppAndSystem : Self {
        get {
            return _q_CWindows_CStorage_CAccessCache_CRecentStorageItemVisibility_AppAndSystem;
        }
    }
}
