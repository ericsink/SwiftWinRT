// this file is automatically generated.
// if you modify it by hand, your changes will probably be lost.


import CWinRT;
@_spi(IUnknown) import WinRT;
import CWindowsSdk;

extension Windows.Security.Cryptography.Certificates {
// type: Windows.Security.Cryptography.Certificates.Certificate
// runtime class
public class Certificate
    :
    WinRT.Object
{
    private var _self : Windows.Security.Cryptography.Certificates.ICertificate;
    public init(plok: Windows.Security.Cryptography.Certificates.ICertificate?) throws {
        _self = plok!
        try super.init(plok: _self.QueryInterface())
    }
    public func Interface() -> Windows.Security.Cryptography.Certificates.ICertificate { return _self; }
    public init(certBlob : Optional<Windows.Storage.Streams.IBuffer>) throws {
        let _af : ICertificateFactory = try RoGetActivationFactory("Windows.Security.Cryptography.Certificates.Certificate");
        _self = try _af.CreateCertificate(certBlob: certBlob)!;
        try super.init(plok: _self.QueryInterface())
    }
    // method not needed: BuildChainAsync
    // method not needed: BuildChainAsync
    // method not needed: get_SerialNumber
    // method not needed: GetHashValue
    // method not needed: GetHashValue
    // method not needed: GetCertificateBlob
    // method not needed: get_Subject
    // method not needed: get_Issuer
    // method not needed: get_HasPrivateKey
    // method not needed: get_IsStronglyProtected
    // method not needed: get_ValidFrom
    // method not needed: get_ValidTo
    // method not needed: get_EnhancedKeyUsages
    // method not needed: put_FriendlyName
    // method not needed: get_FriendlyName
    // instance interface not needed: Windows.Security.Cryptography.Certificates.ICertificate2
    // instance interface not needed: Windows.Security.Cryptography.Certificates.ICertificate3
}

// type: Windows.Security.Cryptography.Certificates.ChainValidationResult
// enum type
public typealias ChainValidationResult = _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult;

// type: Windows.Security.Cryptography.Certificates.ICertificate
// interface type
open class ICertificate
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x333f740c, Data2: 0x04d8, Data3 : 0x43b3, Data4 : (0xb2, 0x78, 0x8c, 0x5f, 0xcc, 0x9b, 0xe5, 0xa0)) }
// method not needed: BuildChainAsync
// method not needed: BuildChainWithParametersAsync
// method not needed: get_SerialNumber
// method not needed: GetHashValue
// method not needed: GetHashValueWithAlgorithm
// method not needed: GetCertificateBlob
// method not needed: get_Subject
// method not needed: get_Issuer
// method not needed: get_HasPrivateKey
// method not needed: get_IsStronglyProtected
// method not needed: get_ValidFrom
// method not needed: get_ValidTo
// method not needed: get_EnhancedKeyUsages
// method not needed: put_FriendlyName
// method not needed: get_FriendlyName
} // ICertificate


// type: Windows.Security.Cryptography.Certificates.ICertificateFactory
// interface type
// ACTIVATION INTERFACE
open class ICertificateFactory
    :
    WinRT.IInspectable
{
    override public class var IID : CWinRT.IID { CWinRT.IID(Data1: 0x17b4221c, Data2: 0x4baf, Data3 : 0x44a2, Data4 : (0x96, 0x08, 0x04, 0xfb, 0x62, 0xb1, 0x69, 0x42)) }
    // Windows.Security.Cryptography.Certificates.Certificate CreateCertificate(Windows.Storage.Streams.IBuffer)
    private func _n_CreateCertificate(_ certBlob : Optional<UnsafeMutablePointer<_q_CWindows_CStorage_CStreams_CIBuffer>>, _ __presult: UnsafeMutablePointer<Optional<UnsafeMutablePointer<_q_CWindows_CSecurity_CCryptography_CCertificates_CICertificate>>>?) throws {
        return try perform(as: _q_CWindows_CSecurity_CCryptography_CCertificates_CICertificateFactory.self) { pThis in
            try CHECKED(pThis.pointee.lpVtbl.pointee.CreateCertificate(pThis, certBlob, __presult))
        }
    }
    public func CreateCertificate(certBlob : Optional<Windows.Storage.Streams.IBuffer>) throws -> Optional<Windows.Security.Cryptography.Certificates.ICertificate> {
        var __result : Optional<UnsafeMutablePointer<_q_CWindows_CSecurity_CCryptography_CCertificates_CICertificate>> = nil;
        try self._n_CreateCertificate(RawPointer(certBlob), &__result);
        return Windows.Security.Cryptography.Certificates.ICertificate(consuming: __result);
    }
} // ICertificateFactory


}
extension Windows.Security.Cryptography.Certificates.ChainValidationResult {
    public static var Success : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_Success;
        }
    }
    public static var Untrusted : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_Untrusted;
        }
    }
    public static var Revoked : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_Revoked;
        }
    }
    public static var Expired : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_Expired;
        }
    }
    public static var IncompleteChain : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_IncompleteChain;
        }
    }
    public static var InvalidSignature : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_InvalidSignature;
        }
    }
    public static var WrongUsage : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_WrongUsage;
        }
    }
    public static var InvalidName : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_InvalidName;
        }
    }
    public static var InvalidCertificateAuthorityPolicy : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_InvalidCertificateAuthorityPolicy;
        }
    }
    public static var BasicConstraintsError : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_BasicConstraintsError;
        }
    }
    public static var UnknownCriticalExtension : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_UnknownCriticalExtension;
        }
    }
    public static var RevocationInformationMissing : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_RevocationInformationMissing;
        }
    }
    public static var RevocationFailure : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_RevocationFailure;
        }
    }
    public static var OtherErrors : Self {
        get {
            return _q_CWindows_CSecurity_CCryptography_CCertificates_CChainValidationResult_OtherErrors;
        }
    }
}
